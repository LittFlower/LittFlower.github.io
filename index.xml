<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>一只花盆.</title>
    <link>http://littflower.github.io/</link>
    <description>Recent content on 一只花盆.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 May 2025 09:31:57 +0800</lastBuildDate><atom:link href="http://littflower.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>UMDCTF2025 WriteUp</title>
      <link>http://littflower.github.io/posts/umdctf2025-writeup/</link>
      <pubDate>Thu, 08 May 2025 09:31:57 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/umdctf2025-writeup/</guid>
      <description>比赛时间和 ACTF2025 基本上冲突了，所以没时间打，赛时只来得及看了两道签到题就遗憾离场，赛后补了所有的用户态题目，剩了几道 v8 暂时摸了（（
gambling2 题目给了源码：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; float rand_float() { float x = (float)rand() / RAND_MAX; printf(&amp;#34;%f\n&amp;#34;, x); return x; } void print_money() { system(&amp;#34;/bin/sh&amp;#34;); } void gamble() { float f[4]; float target = rand_float(); printf(&amp;#34;Enter your lucky numbers: &amp;#34;); scanf(&amp;#34; %lf %lf %lf %lf %lf %lf %lf&amp;#34;, f,f+1,f+2,f+3,f+4,f+5,f+6); if (f[0] == target || f[1] == target || f[2] == target || f[3] == target || f[4] == target || f[5] == target || f[6] == target) { printf(&amp;#34;You win!</description>
    </item>
    
    <item>
      <title>_IO_FILE 任意地址读写攻击面分析</title>
      <link>http://littflower.github.io/posts/iofile%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 08 May 2025 00:31:27 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/iofile%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99%E6%94%BB%E5%87%BB%E9%9D%A2%E5%88%86%E6%9E%90/</guid>
      <description>简介 FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。
在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。
FILE 的结构这里不再详细描述了，之前学 apple 的时候已经看过了，简单来说在 pwndbg 调试时，可以 p _IO_2_1_stdin 查看它们的详细结构。
这里主要介绍一下比较常用的指针：
_IO_buf_base：输入（出）缓冲区的基地址，例如 _IO_file_xsgetn 函数会通过它来判断输入缓冲区是否为空，为空则会调用 _IO_doallocbuf 函数来进行初始化。 _IO_buf_end：输入（出）缓冲区的结束地址。 在建立输入输出缓冲区后，如果缓冲区作为输入缓冲区使用，则会将 _IO_buf_base 基地址赋值给 _IO_read_base，结束地址 _IO_buf_end 赋值给 _IO_read_end
_IO_read_ptr：指向当前已经写入的地址。 _IO_read_base：输入缓冲区的基地址。 _IO_read_end：一般和 _IO_read_ptr 共同使用，_IO_read_end-_IO_read_ptr 表示可用的输入缓冲区大小。 如果缓冲区作为输出缓冲区使用则同理。
而我们在 CTF 题目中非常常见的一个初始化函数是：
setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); 这个函数的作用是设置 _IO_buf_end - _IO_buf_base = 1，这样的效果是缓冲区长度只有 1，也就是 1 字节输入/出一次。</description>
    </item>
    
    <item>
      <title>ACTF2025 WriteUps</title>
      <link>http://littflower.github.io/posts/actf2025-writeups/</link>
      <pubDate>Sun, 27 Apr 2025 15:50:55 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/actf2025-writeups/</guid>
      <description>本次 ACTF 我基本上 24 h 打满了，队伍里一共出了三道 pwn，我参与做了两道，另外一道 qemu pwn 没出，这里写一下 WriteUp。
only_read 题目很简洁，只给了一个不限长度的 read，保护如下：
Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000) RUNPATH: b&amp;#39;.&amp;#39; SHSTK: Enabled IBT: Enabled Stripped: No 看到这个保护肯定是想打 ret2dlresolve 的，但是题目里没有 pop rdi; ret 这种 gadget，所以我这边的思路是打 magic gadget。
我选择了下面这两条 gadget：
libc 里：0x0000000000110a46: pop rbx; pop rbp; pop r12; pop r13; pop r14; ret; 程序中：0x000000000040111c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret 其中第一条是因为倒数第三字节和 libc 中 read 的偏移是一样的，不需要更多的爆破，第二条则是经典的 magic_gadget，两条配合起来可以做一个任意地址写原语。</description>
    </item>
    
    <item>
      <title>RITsecCTF2025 WriteUp</title>
      <link>http://littflower.github.io/posts/ritsecctf2025-writeup/</link>
      <pubDate>Tue, 08 Apr 2025 10:28:47 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/ritsecctf2025-writeup/</guid>
      <description>跟 n1 junior 的师傅们一起打了这场比赛，4 道出了 3 道，简单记录一下。
bit_burger 思路比较简单，利用了函数调用/返回后不会清理栈空间的特性，先通过第一个位操作在栈上构造一个 backdoor 地址出来，第二步直接调用就可以了。
#!/usr/bin/env python3 from pwn import * from sys import argv proc = &amp;#34;bit_burger.bin_patched&amp;#34; context.log_level = &amp;#34;debug&amp;#34; context.binary = proc elf = ELF(proc, checksec=False) libc = ELF(&amp;#34;./libc.so.6&amp;#34;, checksec=False) io = remote(&amp;#34;binex-bitburger.ctf.ritsec.club&amp;#34;, 32200) if argv[1] == &amp;#39;r&amp;#39; else process(proc) if args.G: gdb.attach(io, &amp;#34;b *0x401598&amp;#34;) ogg = 0x401355 s = &amp;#34;0&amp;#34; + bin(ogg)[2:] for i in range(len(s)): if s[len(s) - i - 1] == &amp;#34;1&amp;#34;: io.</description>
    </item>
    
    <item>
      <title>Glibc Exit 函数分析与利用</title>
      <link>http://littflower.github.io/posts/glibc-exit-function-analyze-and-attack/</link>
      <pubDate>Tue, 01 Apr 2025 00:59:36 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/glibc-exit-function-analyze-and-attack/</guid>
      <description>源码分析 用的源码是 glibc 2.35 的，具体版本是 Ubuntu GLIBC 2.35-0ubuntu3.9，在 glibc all in one 里可以下载到。
调试信息我是用 docker 下载的，然后拷出来在我的 arch linux 上慢慢调试。
exit 函数定义在 glibc 的 stdlib/exit.c 中，如下：
void exit (int status) { __run_exit_handlers (status, &amp;amp;__exit_funcs, true, true); } libc_hidden_def (exit) 有一个很重要的结构 __exit_funcs，如下：
enum { ef_free,	/* `ef_free&amp;#39; MUST be zero! */ ef_us, ef_on, ef_at, ef_cxa }; struct exit_function // 析构函数的类型，可以是 {ef_free, ef_us, ef_on, ef_at, ef_cxa} 之一 { // ef_free 表示此位置空闲 // ef_us 表示此位置被占用，但是不知道函数类型 // ef_on ef_at ef_cxa 都表示了具体的函数类型，差别在参数上 /* `flavour&amp;#39; should be of type of the `enum&amp;#39; above but since we need this element in an atomic operation we have to use `long int&amp;#39;.</description>
    </item>
    
    <item>
      <title>UTCTF2025 Writeup</title>
      <link>http://littflower.github.io/posts/utctf2025-writeup/</link>
      <pubDate>Sun, 16 Mar 2025 00:44:32 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/utctf2025-writeup/</guid>
      <description>国赛前一天的一个国际赛，跟 N1 junior 的师傅们一起打一下。
Tic Tac Toe 全都是 gets，baby pwn
无限制的栈溢出可以随便打，溢出一下，覆盖掉 player 的那个 int 就可以 win 了
没写 exp，就不贴了。
RETirement Plan 存在一个对字母的检查，__ctype_b_loc 这个函数见到几次了，它返回的是指向字符属性表的指针，一般写法是 (*__ctype_b_loc())[v5[i]] &amp;amp; 0x100，可以保证线程安全。
题目有个无限制的 gets，还有个格式化字符串，而且没开 NX，所以可以先打印一个栈地址然后返回 main，再读入 shellcode 在栈上执行。
#!/usr/bin/env python3 from pwn import * from sys import argv proc = &amp;#34;./shellcode_patched&amp;#34; context.log_level = &amp;#34;debug&amp;#34; context.binary = proc elf = ELF(proc, checksec=False) libc = ELF(&amp;#34;./libc.so.6&amp;#34;, checksec=False) io = remote(&amp;#39;challenge.utctf.live&amp;#39;,9009) if argv[1] == &amp;#39;r&amp;#39; else process(proc) if args.G: gdb.</description>
    </item>
    
    <item>
      <title>TPCTF2025 WriteUp</title>
      <link>http://littflower.github.io/posts/tpctf2025-writeup/</link>
      <pubDate>Thu, 13 Mar 2025 14:20:23 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/tpctf2025-writeup/</guid>
      <description>和 n1 的师傅一起打了这场比赛，由于不会 web pwn 和 iot，这场基本上只能打签到堆题wwww
师傅们 tql
ezdb Glibc 2.35，洞在这里：
__int16 __fastcall TablePage::InsertRecord(TablePage *this, Record *record) { int Size; // [rsp+10h] [rbp-10h] int v4; // [rsp+14h] [rbp-Ch] Size = Record::GetSize(record); if ( TablePage::GetFreeSpaceSize(this) &amp;lt; (Size + 4LL) ) return -1; LOWORD(v4) = this-&amp;gt;end - Size - this-&amp;gt;page; HIWORD(v4) = Size; *this-&amp;gt;start = v4; this-&amp;gt;start = (this-&amp;gt;start + 4); memcpy(this-&amp;gt;end - Size, record-&amp;gt;content, Size); // off by one this-&amp;gt;end = (this-&amp;gt;end - Size); return (LOWORD(this-&amp;gt;start) - 4 - LOWORD(this-&amp;gt;page)) &amp;gt;&amp;gt; 2; } 这个地方有一个溢出，可以修改 Page 的 length，这个 length 会被用在后面 show 和 edit 功能里，例如 edit：</description>
    </item>
    
    <item>
      <title>WinjaCTF2025 WriteUp</title>
      <link>http://littflower.github.io/posts/winjactf2025-writeup/</link>
      <pubDate>Mon, 03 Mar 2025 16:27:41 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/winjactf2025-writeup/</guid>
      <description>逆天比赛没有 pwn 题，无敌了。
Aura 前一天问我来不来打，我一看 ctftime 权重有 13，感觉还行，就来打了。
结果一上号
👴：我 Pwn 题呢？
👴：垃圾比赛。
Aura：垃圾比赛。
后来从 Reverse 的分区里翻出来一道 Pwn 题，那就做一下吧。
TheChamberofSecrets 程序比较简单，给了一个可执行文件，没给 libc 之类的，这其实很逆天，后面会考。
ida 打开：
__int64 __fastcall main(int a1, char **a2, char **a3) { _BYTE v4[36]; // [rsp+0h] [rbp-30h] BYREF _BYTE v5[4]; // [rsp+24h] [rbp-Ch] BYREF size_t len; // [rsp+28h] [rbp-8h] printf(&amp;#34;Say the Magic Word: &amp;#34;); __isoc99_scanf(&amp;#34;%s&amp;#34;, v5); len = getpagesize(); if ( mprotect((-len &amp;amp; &amp;amp;func1), len, 7) == -1 || mprotect((-len &amp;amp; &amp;amp;func2), len, 7) == -1 ) { perror(&amp;#34;mprotect&amp;#34;); return 1LL; } else { xor(&amp;amp;func1, xor, v5); if ( (func1)(v4) ) { xor(&amp;amp;func2, xor, v4); (func2)(); } else { puts(&amp;#34;Door remains locked!</description>
    </item>
    
    <item>
      <title>西湖论剑 2025 Pwn WriteUp</title>
      <link>http://littflower.github.io/posts/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-2025-pwn-writeup/</link>
      <pubDate>Thu, 20 Feb 2025 08:22:27 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-2025-pwn-writeup/</guid>
      <description>人生第一次打西湖论剑，虽然是跟着 401 的师傅只看了看题，但是感觉还是有一点收获的。
赛后复现 ak 了本场，在这里记录一下。
Vpwn 比较简单的栈虚拟机，逆向无难度，给了任意栈地址读写原语，先泄漏 libc 然后修改返回地址即可。
#!/usr/bin/env python3 from pwn import * from sys import argv proc = &amp;#34;./Vpwn_patched&amp;#34; context.log_level = &amp;#34;debug&amp;#34; context.binary = proc elf = ELF(proc, checksec=False) libc = ELF(&amp;#34;./libc.so.6&amp;#34;, checksec=False) io = remote(&amp;#34;&amp;#34;, ) if argv[1] == &amp;#39;r&amp;#39; else process(proc) if args.G: gdb.attach(io, &amp;#34;&amp;#34;&amp;#34; decompiler connect ida --host localhost --port 3662 breakrva 0x17d0 &amp;#34;&amp;#34;&amp;#34;) def choose(op): io.sendlineafter(b&amp;#34;Enter your choice: &amp;#34;, str(op).encode()) def edit(idx, value): choose(1) io.</description>
    </item>
    
    <item>
      <title>2024年度小结</title>
      <link>http://littflower.github.io/posts/2024-annual-summary/</link>
      <pubDate>Mon, 13 Jan 2025 18:29:39 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/2024-annual-summary/</guid>
      <description>日子过得好快（终于放寒假了嘻嘻
一转眼今年又结束了，今天坐在回家的高铁上，掀开笔记本开始写这个文档。
时间线上的往事 按照时间线捋一捋今年吧，流水账了说是（
1 月 基本上在准备期末考试，20 号才放假。
期间写了份简历，投给了 NAN，Tplus 和 Nightu 师傅人很好，教了我很多。
回家休息了几天，看了几场新国辩，看哲理辩论，看肖磊 vs 黄执中。
2 月 打了几场 CTF，继续看堆。把新生赛的题复现了一遍，然后开心跨年。
和女朋友一起在西安周边转了转，去了游乐园，玩了很多好玩的项目。
对于小学生来说有点幼稚，对大学生来说刚刚好（（
3 月 返校之后看了很久，终于入了一台胶卷相机，买了个比机身贵的镜头，搞了几个胶卷库库拍。
Arch Linux 时不时冒一些小问题，不过也有特别抽象的时候（
打了几场线上赛，摸鱼ing
把编辑器从 vscode 换成了 emacs.
4 月 炉石要回归了，很开心。
开始准备转专业的事情，按理来说应该不需要准备什么，但是因为英语实在不是很能过关，还好专业能力过硬，也是轻松通过了。
其实很焦虑，晚上会睡不着。感觉精神状态越来越不好了。但是我这人不太喜欢跟别人大倒苦水，负能量太多也不好。心里的情绪只能自己消化。现在变成 24 级小登了。
很多事情既然已经发生了，就只能接受它。我只能尽量弥补以前犯的错。
“往者不可谏，来着犹可追。已而已而！”
跟着 NAN 打了几场 CTF 比赛，师傅们好厉害。
5 月 Rx 来了一趟 scu，和他面基了一趟，带他在江安转了一圈，去看了网络靶场和网安楼，基础设施还是蛮不错的。
打了 SCU 校赛，做了 re 和 pwn，pwn 出了两个题，感觉还是不太行，主要是我的问题吧，师傅让我再沉淀沉淀。
读了一些论文，CTF 先放一放，看看别的吧。
6 月 跟同学搞选修课的大作业，写了个 8000+ 字的推理剧本，手法带点抽象，拍摄水平也不行，演员数量也不够，但总体来说效果还行。对得起这个大作业，对得起我小学/初中很迷恋的推理。
然后开始复习期末，英语又爆炸了。真学不会。
报了 ospp，接到了项目，但是完全不会写 qml，然后 wayland 协议也还没读，人机交互也一点不会（</description>
    </item>
    
    <item>
      <title>Pwn 随机数攻击</title>
      <link>http://littflower.github.io/posts/pwn-random-attack/</link>
      <pubDate>Sat, 14 Dec 2024 18:09:23 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/pwn-random-attack/</guid>
      <description>介绍 随机数攻击
主要阅读了 glibc rand 相关的源代码，总结一下 CTF 中常见随机数攻击手法，主要还是打伪随机数预测。
常见写法 以 C 语言的 rand() 为例，主要写法如下：
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;time.h&amp;gt; void gen_random_plus() { srand(time(0)); printf(&amp;#34;%d\n&amp;#34;, rand()); return; } int main() { int seed; srand(seed); printf(&amp;#34;%d\n&amp;#34;, rand()); return 0; } 调用 rand() 函数会返回一个 [0,RAND_MAX] 中的随机非负整数，其中 RAND_MAX 是标准库中的一个宏，在 Linux 系统下 RAND_MAX 等于 $2^{31}-1$。可以用取模来限制所生成的数的大小。
使用 rand() 需要一个随机数种子，可以使用 srand(seed) 函数来将随机种子更改为 seed，当然不初始化也是可以的。
同一程序使用相同的 seed 两次运行，在同一机器、同一编译器下，随机出的结果将会是相同的。
有一个选择是使用当前系统时间来作为随机种子：srand(time(0))。
还有用 linux 的 random 和 urandom 设备的，写法大概如下：
#include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.</description>
    </item>
    
    <item>
      <title>2024 强网杯青少赛线下游记</title>
      <link>http://littflower.github.io/posts/2024-qwbqs-final-travels/</link>
      <pubDate>Mon, 09 Dec 2024 16:23:39 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/2024-qwbqs-final-travels/</guid>
      <description>去郑州玩了两天，线下面了一堆师傅
Day-? 本来都不记得这个事情了，但是 Aura 上离散数学课的时候突然问我来着，于是跟 Aura 和树木一起组队打了线上赛。
但是话又说回来了，Aura 打线上那天咕咕了，去打他那个 b 鹏城杯了，导致我跟树木 2 打 3，web 基本上没做，好在不影响进线下。这是前话。
Day -1 提前买了飞去郑州的机票，由于我不想在飞机上吃那个 b 飞机餐，所以特意买了早一点的飞机，但是时间非常阴间，早上 7 点就得走，Aura 说让我 6 点起，有点幽默哈。
晚上两点睡的。
Day 0 结果当然是起不了一点
定了个闹铃，早上七点的时候把全宿舍人吵醒了（（ 闹麻了。
提前一个多小时就把值机什么的办好了，和 Aura 在机场里找了一家 KFC，吃了顿早餐（好吃而且价格正常），打了两把炉石，期间被偷拍了（
没事，我也拍了 Aura：
闹麻了。
飞机上比较无聊，我因为完全没睡醒，飞机上继续睡，aura 应该也在睡。
中午 12 点左右出机场，坐出租车去酒店。比较难绷的是酒店位置很离谱，不在市区，打出租车过去要 160。
我跟司机师傅说要开发票（主办方报销），师傅说车费 160 给我开 200 的，给我整乐了（（（
下午在酒店里收拾了一下。这个时候场馆里还在打强网杯，打算等他们打完了过去找师傅们面基。于是成功面基到了 GZ 师傅，空白，还有 miaotony 和 gets 师傅（
没面到 n1 的师傅真可惜&amp;hellip;.
晚上吃饭的时候，沾 Aura 的光，面到了星盟的师傅们，还要到了微信（（但是面的很尴尬，因为完全不熟（（（
还有一些逆天偷拍哥（说的就是你，多多！
晚上特别难绷，因为我发现我跟树木他们学校的指导老师一个房间
👴：能不能给我换个房间啊&amp;hellip; 真是一秒钟都待不下去了
晚秋：来我房间，教你 awdp
👴：我超义父！
好好好，于是去晚秋和 zjl 的房间，学了一会 awdp，然后聊了一下发展规划（（</description>
    </item>
    
    <item>
      <title>Qemu Pwn 入门与调试</title>
      <link>http://littflower.github.io/posts/qemu-pwn-debug-trick/</link>
      <pubDate>Sat, 30 Nov 2024 17:44:58 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/qemu-pwn-debug-trick/</guid>
      <description>前置知识 MMIO 和 PMIO 是 CPU 和外部设备之间两种互为补充的 I/O 方法。
MMIO (Memory-mapped I/O) PMIO (Port-mapped I/O) MMIO 让 CPU 访问外部设备就像访问磁盘虚拟内存空间一样方便，也就是说，内存和 I/O 设备共享同一个地址空间。当 CPU 使用 MMU 将虚拟内存空间地址转化时，可以转化成物理内存空间地址、也可以转化成 I/O 设备的内存。因此，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳 I/O 设备，CPU 必须预留给 I/O 一个地址区域，该地址区域不能给物理内存使用。
PMIO 在端口映射 IO 中，内存和 I/O 设备有各自的地址空间，PMIO 会使用特殊的 CPU 指令专门执行 I/O 操作，I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将 PMIO 称为被隔离的 IO(Isolated I/O)。
如何实现 MMIO 在Linux中， 内核使用ioremap()将IO设备的物理内存地址映射到内核空间的虚拟地址上； 用户空间程序使用mmap(2)系统调用将IO设备的物理内存地址映射到用户空间的虚拟内存地址上，一旦映射完成，用户空间的一段内存就与IO设备的内存关联起来，当用户访问用户空间的这段内存地址范围时，实际上会转化为对IO设备的访问。
如何启动 以下是一个启动脚本 start.sh:
./qemu-system-x86_64 \ -m 1G \ -device strng \ -hda my-disk.img \ -hdb my-seed.img \ -nographic \ -L pc-bios/ \ -enable-kvm \ -device e1000,netdev=net0 \ -netdev user,id=net0,hostfwd=tcp::5555-:22 其中 -device 后面的是设备名。</description>
    </item>
    
    <item>
      <title>2024 强网杯青少赛线上赛题解</title>
      <link>http://littflower.github.io/posts/2024-qwbqs-writeup/</link>
      <pubDate>Mon, 25 Nov 2024 16:55:35 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/2024-qwbqs-writeup/</guid>
      <description>前言 战队名：crazyNAN
战队排名：6
战队整体答题情况：除 web 方向 cyberboard mysqlprobe 外均解出。
这辈子最后一次打强网杯青少赛了，因为我今年刚满 18 岁（（（
一开始把这事情都忘了，还是 Aura 师傅拉我我才想起来，打着玩玩，话又说回来初赛和这 b Aura 有个🥚的关系啊（（
全靠 👴 和 🌳 带飞（
杂鱼 Aura
Wp 赛时开了个飞书云文档，边打边写 wp，感觉确实不错，不用赛后专门整理 wp 了。
我这里就把我做的 pwn 题发一下，剩下的可以戳这个链接看 exp
Pwn clock_in 板子 ret2libc，exp:
from pwn import * from sys import argv proc = &amp;#34;./clock_in&amp;#34; context.log_level = &amp;#34;debug&amp;#34; context.binary = proc elf = ELF(proc, checksec=False) libc = ELF(&amp;#34;./libc.so.6&amp;#34;) io = remote(&amp;#34;101.200.61.16&amp;#34;, 34841) if argv[1] == &amp;#39;r&amp;#39; else process(proc) if args.</description>
    </item>
    
    <item>
      <title>论文笔记《AddressSanitizer: A Fast Address Sanity Checker》</title>
      <link>http://littflower.github.io/posts/paper-notes-of-addresssanitizer-a-fast-address-sanity-checker/</link>
      <pubDate>Mon, 21 Oct 2024 19:14:44 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/paper-notes-of-addresssanitizer-a-fast-address-sanity-checker/</guid>
      <description>0x00. Abstract 对于 C 和 C++ 等编程语言来说，内存访问错误（包括缓冲区溢出和 use after free）仍然是一个严重问题。存在许多内存错误检测器，但大多数检测器要么速度慢，要么局限于有限的错误集，或者两者兼而有之。本文介绍了 AddressSanitizer，一种新的内存错误检测器。这个工具可以查找对堆、堆栈和全局变量的越界访问，以及 use after free。它采用专门的内存分配器和代码工具，足够简单，可以在任何编译器、二进制翻译系统甚至硬件中实现。AddressSanitizer 在不牺牲全面性的情况下实现了效率。它的平均速度仅为 73%，但它可以在错误发生时准确地检测到错误。它在 Chromium 浏览器中发现了 300 多个以前未知的错误，以及其他软件中的许多错误。
0x01. Introduction AddressSanitizer 由两部分组成：检测模块和运行时库。检测模块修改代码以检查每次内存访问的影子态 (shadow state)，并在堆栈和全局对象周围创建中毒红区以检测向上或向下溢出。当前的实现基于 LLVM 编译器基础设施。运行时库替换了 malloc、free 和相关函数，在分配的堆区域周围创建中毒红区，延迟已释放堆区域的重用，并进行错误报告。
总的来说，这篇文章做了以下几件事：
说明了内存错误检测器可以利用影子内存 shadow memory的全面性，并且开销比传统方法低得多； 提出一种新颖的影子态编码方式，可实现紧凑的影子内存（高达 128-to-1），用于检测越界和 use-after-free 错误； 描述一个针对新实现的影子编码的专用内存分配器； 评估一个新的公开可用的工具，该工具可以有效地识别内存错误。 0x02. Related work 影子内存（shadow memory） 总的来说，按照对应用程序地址的处理可以把现有的工具分为两种：
通过直接缩放和偏移（其中完整应用程序地址空间映射到单个影子地址空间）； 通过涉及查表的额外转换来映射到影子地址空间。 直接缩放和偏移的例子有：
TaintTrace LIFT 使用多级转换的例子有：
Valgrind Dr.Memory 还有一些比较 trick 的工具：
Umbra：兼顾布局灵活性和效率，使用可动态调整的缩放和偏移来直接映射地址而非使用查表的方式； BoundLess：利用 64 位寄存器的高 16 位来做到内存复用，但是在慢速路径下会退化； LBC：使用存储在应用程序内存中的特殊值执行快速路径的检查，并在慢速路径上依赖于两级影子内存。 实现 大部分内存检测工具都基于二进制文件，这些工具可以发现堆内存的越界和 UAF，还可以识别未初始化的读取，不过没办法识别堆栈和全局变量的越界错误，好消息是基本不会误报。例如：Valgrind，Dr.Memory，Discover，BoundsChecker 等等
而使用编译时检测的工具虽然可以检测堆栈对象的越界访问，但是无法检测所有的堆栈缓冲区溢出错误，而且可能误报，例如 Mudflap。</description>
    </item>
    
    <item>
      <title>如何计算结构体字节数</title>
      <link>http://littflower.github.io/posts/how-to-calc-the-bytes-of-struct/</link>
      <pubDate>Wed, 15 May 2024 14:35:41 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/how-to-calc-the-bytes-of-struct/</guid>
      <description>计算结构体字节数的关键是搞明白字节对齐。
字节对齐是为了提高内存访问的效率与速度，它的细节和编译器实现有关，但一般而言，遵循以下规则：
结构体变量的首地址是结构体中最宽基本类型成员的大小的倍数； 结构体每个成员相对于结构体首地址的偏移量都是该成员内存大小的整数倍，也就是说相邻的两个不同类型的成员之间可能需要填充字节，填充至相邻两成员的最小公倍数； 结构体所占的总内存大小应为结构体中最宽基本类型成员的倍数，也就是可能在最后一个成员之后填充字节。 注意：结构体不算作基本类型成员。 按照这个规则，可以得出以下结构体所占的内存为 24 字节：
struct node { char a; // 1 字节，但会填充至 4 字节 int b; // 4 字节，至此共 8 字节，与 long long 相同，不需要填充 long long c; // 8 字节，至此共 16 字节 char d; // 1 字节，至此共 17 字节 // 结构体总大小必须为 8 的整数倍，所以填充至 24 字节 }; </description>
    </item>
    
    <item>
      <title>逆向结构体的经验</title>
      <link>http://littflower.github.io/posts/the-experience-of-reverse-struct/</link>
      <pubDate>Tue, 14 May 2024 14:43:08 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/the-experience-of-reverse-struct/</guid>
      <description>主要说一下怎么逆向 Pwn 题里常见的各种数据结构。
0x01. 数组 最简单的一种就是逆向数组，因为数组的形式在经过反编译之后会呈现出指针偏移的形式，e.g. *(p + offset)。
比如说下面这份代码：
int __fastcall main(int argc, const char **argv, const char **envp) { int i; // [rsp+4h] [rbp-Ch] __int64 v5; // [rsp+8h] [rbp-8h] for ( i = 0; i &amp;lt;= 9; ++i ) { *(4LL * i + v5) *= i * i; printf(&amp;#34;%d\n&amp;#34;, *(4LL * i + v5)); } return 0; } 看到这种 *(p + index * offset) 的形式，大概率这里的 v5 是个数组指针，稍微尝试一下，发现可以恢复成如下形式：</description>
    </item>
    
    <item>
      <title>T1DCTF2024 WriteUp</title>
      <link>http://littflower.github.io/posts/t1dctf2024-writeup/</link>
      <pubDate>Tue, 14 May 2024 14:36:43 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/t1dctf2024-writeup/</guid>
      <description>补一下二队内测题。
repeater [easy] Repeater
As is well known, CTFers are all repeaters!
栈溢出题目，sub_11C9() 可以栈溢出，只修改返回地址的 1 字节，可以做到 partial overwrite 无限循环 sub_11C9() 读入 payload。
这里讲一下 fread 等 FILE 相关函数，后面也会用到。
C 语言 FILE 函数
既然没有空字符阶段，printf 就会把 retaddr 打印出来，从而获得 pie base。
接下来的问题是怎么泄漏 libc，ropper 发现程序没有一个能用来控制 rdi 的 gadgets，细心会发现程序在结束 printf 后寄存器 rdi 上居然还保存着 libc 函数的地址，那直接 call puts 就可以泄漏了。
from pwn import * proc = &amp;#34;./pwn&amp;#34; context.binary = proc context.log_level = &amp;#34;debug&amp;#34; io = process(proc) # io = remote(&amp;#34;tld1027.</description>
    </item>
    
    <item>
      <title>foolctf 2024 WriteUp 和一些关于 shellcode 的反思</title>
      <link>http://littflower.github.io/posts/t1d_foolctf-2024-writeups/</link>
      <pubDate>Tue, 09 Apr 2024 18:49:09 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/t1d_foolctf-2024-writeups/</guid>
      <description>愚人节的时候 t1d 在群里扔了两道题，说是愚人节ctf&amp;hellip;
做了之后发现自己是愚人了
facker 题目分析 先来看看程序主体逻辑：
en&amp;hellip;. 大概读一遍可以确定这是个 orw 题，不过一个巨大的 random 糊在脸上预示着这题可能不太好打，下面有个 encrypt 函数，会一次加密 16 字节，跟进去看看：
这个加密算法分两部分，前半部分可以识别出是个 base64 的 decode，后半部分是用刚才读的随机数异或编码 16 字节的前 12 字节。
一开始想着能不能把 random 给绕了，但是 t1d 肯定防了这个：
fd = open(&amp;#34;/dev/random&amp;#34;, 0); for ( i = 0; i != 16; i = strlen(buf) ) read(fd, buf, 0x10uLL); 这个写法会防止读 random 时首字节为空字节导致的截断问题。所以这东西肯定是绕不了了。
再者，关于这个 base64，可以注意到这个 decode 并没有直接在 a1 上做，也就是并没有修改我们输进去的 orw，真正修改 orw 的是后面的异或运算。
（这里我狠狠踩坑了，做题的时候处于逆向习惯一直在想着怎么逆这东西，其实从宏观一点的角度思考就会发现没有修改 orw 的 base64 decode() 我们是完全可以不用理会的）
总结一下，可以输入 66 个字节，前 2 个字节不作处理，之后的 64 个字节分为 4 组，每组只修改了 16 个字节的前 12 个字节。</description>
    </item>
    
    <item>
      <title>Unbreakable CTF 2024题解及反思</title>
      <link>http://littflower.github.io/posts/unbreakablectf2024-writeup/</link>
      <pubDate>Mon, 08 Apr 2024 22:33:57 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/unbreakablectf2024-writeup/</guid>
      <description>Unbreakable CTF 2024 Pwn WriteUps 和 NAN 的队友一起打了 UnbreakableCTF 2024 的二进制方向，动手做了两道题，口胡了一道堆题，有一些感悟和反思放在这里。
harder_assembly 思路 一道 x64 的shellcode 题，难点是禁止在 shellcode 里使用 syscall 以及shellcode 长度只有 15 字节。
后者比较好解决，可以考虑直接调用 read 构造二次输入，这样二次输入的时候就没有长度限制了，构造 orw 即可。
这里我遇到的知识盲区主要是禁用了 syscall，解决方法是使用 int 0x80（即继续使用 x32 API）
翻了一下 stackoverflow，注意到这样一段话：
When called from a 64-bit program it behaves the same way it would behave like if it has been called from a 32-bit program (using the 32-bit calling convention).
This also means that the parameters for &amp;ldquo;int 0x80&amp;rdquo; will be passed in 32-bit registers and the upper 32 bits of the 64-bit registers are ignored.</description>
    </item>
    
    <item>
      <title>AsisCTF2016 b00ks 复现笔记</title>
      <link>http://littflower.github.io/posts/asisctf2016-b00ks/</link>
      <pubDate>Tue, 23 Jan 2024 00:25:35 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/asisctf2016-b00ks/</guid>
      <description>记一道 offbyone 堆题的复现、反思与总结 复现 题目介绍 题目链接
菜单题，选单如下，其中 create 功能会创建一个 book，edit 功能只能修改 book 的 description，print 功能会打印 book 的 id/name/description/author, delete 功能会 free 掉 book name/book description/book self ：
1. Create a book 2. Delete a book 3. Edit a book 4. Print book detail 5. Change current author name 6. Exit 题目每创建一个 book，会涉及到两个用于维护的数据结构：一个是 book struct 本身，一个是 book list。
book struct 结构如下，每个 book struct 耗用内存空间大小为 0x20：
struct book { int id; char *name; char *description; int size; } book list 则是用来存放 book 的数组，主要用在 delete a book 和 edit a book 功能中。</description>
    </item>
    
    <item>
      <title>MoeCTF 2023 Pwn 题目复现</title>
      <link>http://littflower.github.io/posts/moectf-2023-pwn-writeup/</link>
      <pubDate>Sun, 12 Nov 2023 18:08:44 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/moectf-2023-pwn-writeup/</guid>
      <description>MoeCTF2023 Pwn WriteUp 前言 今年暑假比较摆烂&amp;hellip; 最后也没做完 MoeCTF 的 pwn 题, 只能赛后抽时间复现一遍. 复现一遍之后还是复习了不少知识点, 写一篇 wp 以作笔记.
题目复现 test_nc 连接即可.
baby_calculator emmm 打一个交互就可以了.
fd fd 即 file descripter, 又叫文件描述符, 它是一个抽象的指示符, 用一个非负整数表示.它指向了由系统内核维护的一个 file table 中的某个条目 ( entry ), 后者又指向储存文件真实地址的 inode table.
一般来说操作系统会为每个用户进程预留三个默认的 fd: stdin, stdout, stderr. 它们对应的非负整数值分别为 0, 1, 2. 之后的 fd 从 3 开始分配.
反编译得到核心代码:
fd = open(&amp;#34;./flag&amp;#34;, 0, 0LL); new_fd = (4 * fd) | 0x29A; dup2(fd, new_fd); // 将 new_fd 重定向到 fd close(fd); puts(&amp;#34;Which file do you want to read?</description>
    </item>
    
    <item>
      <title>ArchLinux 体验日志与感悟</title>
      <link>http://littflower.github.io/posts/the-taste-of-archlinux/</link>
      <pubDate>Thu, 19 Oct 2023 21:13:56 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/the-taste-of-archlinux/</guid>
      <description>在使用 ArchLinux 4 个月后 前言 高考前几个月和 Rx 聊天的时候，他给我摆拍了一张当时他使用的操作系统 / 生产环境，简洁、优雅的桌面深深吸引了我，自那时起，使用 ArchLinux 为主力生产/生活系统的种子便深深埋在了我心底。
再就是高考结束一周后，连忙入手了一台华硕天选 4，问了两句 Rx 关于注意事项（他甩了 wiki 的链接给我），当时看见他给我发 wiki 的链接我还感觉有点不靠谱，现在想起来属实是应该给 wiki 磕一个 23333
以下记录了一些我使用了 4 个月 Arch Linux 期间的一些体验，希望其中的一些经验及解决方案可以帮到看到这篇文章的友友。
基础配置 基础的安装操作可以右转 Arch wiki，wiki 上写得很详细了，只需要按照这份说明一步一步执行就可以（注意不要跳步），以及不推荐使用 Arch Linux Wiki 提供的一键安装脚本，我认为如果是 Arch Linux 的 target 用户，应该秉持着 Arch Linux 的 &amp;ldquo;Keep It Simple&amp;rdquo; 的 Arch 之道，对自己的生产环境了如指掌，而不是选择一键梭哈。
Arch Linux 的安装方式可以不准确地粗略概括为：通过 U 盘上烧录的 ISO 介质以 root 身份登陆进入一个虚拟控制台，然后对裸机安装基础软件（如 pacman、iptools、vim 等）然后 chroot 进主机的 root，所以不要干出来把东西都装在虚拟控制台里而主机什么都没装这种操作，重启之后全部都会消失（别问我为什么要写这一条
关于安装之后的工作，请浏览 Arch wiki。这里主要说一说显示服务协议以及后续 window manager 或者 compositor 的选择。</description>
    </item>
    
    <item>
      <title>Windows x86 SEH 机制</title>
      <link>http://littflower.github.io/posts/moectf2023-unwind-and-a-little-windows-seh/</link>
      <pubDate>Fri, 13 Oct 2023 20:23:13 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/moectf2023-unwind-and-a-little-windows-seh/</guid>
      <description>Windows x86 SEH 机制暨MoeCTF2023 Unwind 解题报告 前言 去年 MoeCTF 2022 的时候云姐姐出了个除零异常的题，当时在机房几个人七嘴八舌怼汇编还能勉强做出来&amp;hellip;.
今年 MoeCTF 2023 的时候云姐姐又双出了这么一个题，我做的时候就比较坐牢了&amp;hellip;&amp;hellip;想了想还是从原理出发完全地了解一下这个知识点，再做做这么个题。
高难警告
SEH 学习 认识 SEH 使用 SEH，你可以确保在执行意外终止时，可以正确地释放资源（如内存块和文件）。 ——《Structured Exception Handling》
所谓 SEH，全称即 &amp;ldquo;Structure Exception Handler&amp;rdquo; —— 结构化异常处理器。
需要明确：SEH 是针对于异常的一种处理机制。首先，异常分为两方面来讲：硬件异常和软件异常。
硬件异常：这里的“硬件”的定义十分狭隘 —— 仅限于 CPU 异常，例如除零异常，它就是 CPU 在执行除零操作时会自动触发的异常处理机制； 软件异常：由程序模拟的异常，软件异常可以既可以由操作系统触发，也可以由程序员随意触发。 SEH 并非专为 C/C++ 设计，它是 windows 给的一套通用性的解决方案，因此尽管我们可以在代码中随时使用它们，但是应当优先使用 c++ ISO 标准化的异常处理（try - catch）（也就是说不要把这东西往工程代码里写啊喂）
SEH 也有两种处理机制：
异常处理程序 __except 块：它基于 filter-expression 值响应或消除异常； 终止处理程序 __finally 块：无论异常是否终止都要继续调用之。 Windows x86 提供的异常处理机制其实只是一个简单的框架，在此基础上有各编译器提供的增强版异常处理机制。故我们将 windows SEH 机制分为系统实现的原始版本、编译器实现的增强版本 两方面来讲。</description>
    </item>
    
    <item>
      <title>写在入校前</title>
      <link>http://littflower.github.io/posts/written-before-enrollment/</link>
      <pubDate>Thu, 07 Sep 2023 18:23:30 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/written-before-enrollment/</guid>
      <description>写在小花大一开学前 三个月的暑假瞬间就过去了… 让人不禁感慨自己即将步入大学的校门。
说起来自高考出成绩之后，自己先是伤心失意了两三周，虽然没有在深夜默默流泪这种狗血桥段，但是相当一段时间内还是被不甘心、不情愿等等负面情绪充斥着。在报志愿之前，一看自己的成绩，再看看各个曾经想去的、不想去的学校的最低录取位次，无数个瞬间都感觉自己完蛋了：似乎… 我没学上了？
大概沉浸在这种负面情绪里低落了相当一段时间，把自己整日泡在图书馆里做题、写代码、挨学长批评，我真该死啊…
最后稀里糊涂地去了川大… 结果又被调剂去研究自然科学，于是又自闭了半个月… 负面情绪 emo 一直持续到 8 月上旬，彼时我尽量让自己做一只鸵鸟，不去想高考没考好的事实，把自己埋在计算机里：每天帮各种同学看题、自己做题、修缮博客系统、读 arch linux 的文档… 好像日子也算过得下去… 只是感觉生活没什么光亮… 前途没什么希望…
那时每每想起 Rx 学长在自己博客里写过一句话：
感觉自己好像那个什么驴…… 该休息的时候却总想着怎么继续拉磨盘。。
照镜子了… 真难绷。还是跟 Rx，聊起来我的去向，他劝我说：
你就像窗户外那个蝉，在地底下的黑暗里埋了 18 年，只能出来叫 3 个月，然后就死掉了。。
确实，他说以后再也没这么好的时间了… 不如好好休息休息，玩一玩。
仔细一想确实是这个理，于是决定不管怎么样都要出去散散心，既是毕业旅行的仪式感，也是给我自己一点点心理的安慰和交代。
那天看见一个 25 届的学弟发了一条说说：
今天听到 zy （ps：我们名义上的指导老师）又在宣传信息竞赛，还说什么零基础也没事……
但是只有经历过的人才懂，明白水有多深、路有多长、任务有多艰巨。。。
真是让人不禁感慨啊… 曾经的我还是整天追在学长后面问问题的小孩子… 现在我的 25 届学弟已经开始给 26 届新生出 oi 入门考试题目了…
回想起占据了自己高中生活半壁江山的竞赛生涯（我这种彩笔也配说“生涯”吗），一路上走过来很少感受到真切的理解，大部分时候都是在踽踽独行…… 就像是走那条每次从教学楼出来回宿舍的 20 m 的夜路，灯光穿过树叶投在地上斑驳，周围各个年级的同学有说有笑地回答，而我却总感觉到一股直逼灵魂深处的冷意 —— 一种孤独与痛苦。孤独来自于无人理解，痛苦来自于自己学不明白东西的现实。
三年来这条路我走了无数次，却从来没有比那个时候更感到漫长…… 就感觉自己一个人低着头走着直线，只有影子在后面陪我……
现在大抵习惯了孤身一人的感觉… 所以有什么伤心事大都埋在自己心里，寂寞的时候一遍一遍地告诉自己：“享受孤独。”
这三年来我确实做了不少东西，如果不以高考成绩论输赢，那么我的高中生活在我眼里相当成功…… 至少我自己挺满意的：靠自己进了年级上最好的班、靠着运气拿了 oi 的奖、打过四五场 CTF 、模考的时候考过特别好 / 差的成绩、给数学老师写了个学生管理系统、给之前的博客评论插件写了个 bash、作为背锅人建了 E-Butx 社团……</description>
    </item>
    
    <item>
      <title>👋 小花ฅ. 的个人介绍</title>
      <link>http://littflower.github.io/aboutme/</link>
      <pubDate>Mon, 17 Jul 2023 16:32:44 +0000</pubDate>
      
      <guid>http://littflower.github.io/aboutme/</guid>
      <description>❓ 昵称 我是 小花ฅ.，大家通常也称呼为 花花、fafa 等奇奇怪怪的称呼。
“小花” 这个名字没有名物学出处，在高中某一次信息学竞赛结束后为自己起了这个名字，意为“希望自己如同花朵般绽开，如花朵般永远可爱”。“ฅ” 这个符号是小猫的爪子，我很喜欢猫，它们很可爱。
此外，LittFlower.、Floret.、EffloreScence.、maple5124、许江一墨 也是我在各个平台上的可能使用的 ID。当然，也可能存在 ID 的偶然性重复，一位学长就恰巧与我同名。
💻 工作 我目前的工作与生活环境都是 Arch linux + KDE with wayland，它是学长 Rx 推荐的，我很喜欢，但是我拒绝参加任何关于操作系统的口水战，&amp;ldquo;No best, just adjust.&amp;rdquo;
编辑器是 vscode，它很顺手。
博客使用 Github Pages + Hugo + 个人域名 搭建，你可以在 https://blog.littflower.top 访问它。
📘 学习 我正在 SCU 读大一，目前没有进行任何盈利性工作，没有可靠的经济来源，因此经济暂时不独立。
喜欢计算机，并对它的一切未知充满好奇心。
喜欢编程，在高中时我自学了一定程度的 python，C/C++，JavaScript，可惜由于文化课学业限制，每一项都只是浅尝辄止，希望在未来可以深入掌握。
曾经热爱 OI，在高中时参加 CSP、NOIP 等系列赛事，为高中生活增添了相当多的回忆。
尤其热爱 CTF，我现在正在学习 CTF 的各个方向，并可能持续至大学毕业。
🎮 娱乐 初二时妈妈为我购置了真正意义上的第一台笔记本电脑，我曾在那上面游玩暴雪的炉石传说、星际争霸2、守望先锋，初三时我尤其爱玩炉石传说，那是一款绝棒的卡牌游戏。
高中时在 steam 上游玩 Dota2、泰拉瑞亚、纸人2、彩虹六号，可惜精力有限，我并不追求游戏排名，而是信奉“花钱买开心”。
我现在仍在玩 Mc、泰拉瑞亚、炉石传说、空洞骑士、七日杀、七亿人等游戏。
🎾 运动 我喜欢打乒乓球，我经常和爸爸去附近的球馆打球。
对足球、羽毛球也有一定了解，但玩的并不好。</description>
    </item>
    
    <item>
      <title>2022强网杯青少赛题解</title>
      <link>http://littflower.github.io/posts/2022-qwbqs-writeup/</link>
      <pubDate>Fri, 03 Feb 2023 21:27:43 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/2022-qwbqs-writeup/</guid>
      <description>Qwb-青少赛-2022-WP 前言 蒟蒻来写 WP 了&amp;hellip;&amp;hellip; 本来应该是可以进线下的&amp;hellip;奈何工具太老旧&amp;hellip;明年再努力吧.
顺带一提，没补 pwn 题（（（
别问我为什么现在才发
Misc misc题实在是做麻了
misc 题思路都是对的&amp;hellip;脚本假了&amp;hellip;
Misc1 题目链接：Link
首先拿到一个 png 图片，用 010 editor 查看，根据文件头可以发现它是交换了奇偶数位顺序后的加密图片。
50 89 47 4E 0A 0D 0A 1A 00 00 0D 00 48 49 52 44 00 00 BD 02 00 00 6D 02 06 08 00 00 3B 00 C8 1A 00 F7 00 01 49 00 41 44 78 54 EC 9C D9 FD 1C 93 于是第一步解密：</description>
    </item>
    
    <item>
      <title>重读提问的智慧</title>
      <link>http://littflower.github.io/posts/reread-the-wisdom-of-questioning/</link>
      <pubDate>Sat, 27 Aug 2022 20:23:13 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/reread-the-wisdom-of-questioning/</guid>
      <description>重读提问的智慧 0x00 为什么叫”重读“呢&amp;hellip;&amp;hellip;其实在这次读之前已经读过两三遍了&amp;hellip;&amp;hellip;但是还是会在提问的时候被学长批评提的问题不好（
qwq&amp;hellip;学长为了让我长记性，，属实是”煞费苦心“。
因此特地认认真真重读《提问的智慧》，同时做一些摘要，以飨读者。
0x01 简介部分 大家都喜欢回答一个能激发思维、提高理解力、暴漏从未思考过的问题的”好问题“。 帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 不必在技术上很在行，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。 能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 在提问之前 应仔细做到： 尝试上网搜索以找到答案。 翻一翻 github 等知名网站的 issue 等。 尝试自己检查或试验以找到答案。 尝试阅读常见问题文件（FAQ）。 尝试阅读已有问题提示 尝试阅读源代码。 不要将所有问题一股脑拋出。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。 小心别问错了问题。 绝不要自以为够格得到答案，你没有；你并没有。 提问时 A.语气语态 不要妄想用自己的痛苦程度来打动他人，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。 不能粗鲁傲慢，也不该低声下气。 礼多人不怪，而且有时还很有帮助。 使问题容易回复，因此要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感。 B.内容 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 去掉无意义的提问句。 如果你只是想让别人帮忙审查（Review）一下代码，在开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 精确地描述问题并言之有物，尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。话不在多而在精 描述提问的最根本原因（需求），而不是描述一个自己解决方案中的问题。因为自己的解决方案不一定是最优解。 要确信原原本本告诉了问题的症状 在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 C.提问方式 使用清晰、正确、精准且合乎语法的语句。 正确的拼写、标点符号和大小写是很重要的。如果在使用非母语（英语）提问，可以犯点拼写和语法上的小错，但决不能在思考上马虎。 English is not my native language; please excuse typing errors. 使用易于读取且标准的文件格式发送问题，或者是截图（但尽量不要拍电脑屏幕）。 提问后 别让自己卷入口水战，最好不要理睬大多数的口水战。 一些好问题 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</description>
    </item>
    
    <item>
      <title>观《孔子》有感</title>
      <link>http://littflower.github.io/posts/film-review-of-confucius/</link>
      <pubDate>Sun, 27 Feb 2022 16:32:44 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/film-review-of-confucius/</guid>
      <description>观《孔子》感而发 0x00. 前记 语文老师让看的
今天中午看完了《孔子》这部电影，讲道理感觉一般，总的来说这部电影并没有体现出孔子的独特的精神以及特有的人格魅力，并且导演和编剧的历史学、物理学知识实在是让人不敢恭维，哪怕是艺术手法处理或者情节需要，这个剧情也有点过于狗血、离谱。
以上是一个总评，算作是序。
0x01. 聊点好的 我觉得整部电影孔子最闪光的时候莫过于那场为废除活祭制度而展开的辩论。
在这场辩论上，孔子“舌战群儒”，通过正、反面的道理论证夹杂一些小小的诡辩，成功地于朝堂之上把公山狃这种小人说的哑口无言。圆形的朝堂、大夫们的座位，整个场景都非常像古罗马元老院，而位于矛盾中心的孔子颇有一种苏格拉底的味道。
最经典的莫过于孔子以其人之道还治其人之身，“给个话啊”，体现了孔子的从容与智慧，还有一种国产电影少见的黑色幽默。
孔子在鲁国，堕三城，与三大家周旋，这一情节也算是展现了孔子知其不可而为之的悲剧性精神，即使最终受到了季桓子的驱逐，孔子依然不改初心，游历各国，四处讲学，虽历经磨难，却仍守节不屈。
“世人也许能够领悟夫子的痛苦，但永远无法领悟夫子在痛苦中所达到的境界。”
孔子所向往的礼乐制度虽最终没有实现，但孔子坚韧不屈的精神在这部影片中也算是得到了一定程度上的体现。
即使影片中有许多《论语》的引用，但看孔子那一句 “志士仁人，无求生以害仁，有杀身以成仁” 属实让我狠狠感动了一把。
0x02. 不好的 只能说瑜不掩瑕（不是瑕不掩瑜）
首先是一些学术性的问题，虽然说影视作品为了更好的展现人物形象，但是也不能过于离谱&amp;hellip;..
比如说：颜回的死因、子路等人的死亡时间、竹简沉入冰水里、春秋时期的鲁国基本没有活祭制度、春秋的时候没有“大人”这种称谓&amp;hellip;&amp;hellip;
不管是为了艺术效果还是为了其他的什么，这种编排我个人是不敢苟同的，非常容易误导一些不了解孔子历史的小学生。（亲眼见证了有小学生把颜回跳入冰湖里救书当作素材写进作文的）
其次，这部电影并没有很好的表现力和视觉效果，故事情节、人物矛盾的安排都不甚合理，导演对于场景转换、闪回的把控也实在是不敢让人恭维。。。
颜回死的那一段情节，感动吗？并没有，反倒是让人感觉很狗血&amp;hellip;..何必呢，颜回明明死在孔子归鲁之后，在鲁国开宗讲学，整理《易》，发轫出了被称为“颜氏之儒”的学派——影片又何苦改成这样呢？
南子和孔子的那一段情节，为什么要给南子平白加这么多的感情戏？是因为周迅？
编剧专门挑出史书中原本只言片语的这一小段大做文章，其动机不可谓不了然。话说回来，如果能把这段演绎得不媚俗、合情理、有新意，也会十分出彩。——然而结果是：既谈不上媚俗，也逃不掉庸俗；且几无道理可言，牵强之极。周迅可谓是用力过猛，南子这个角色被她演的淫荡有余而富贵不足，就像是《画皮》里的那副狐狸精的模样。
导演想用“世人也许能够领悟夫子的痛苦，但永远无法领悟夫子在痛苦中所达到的境界”来升华主题，可是电影的前段缺乏剧情的铺垫、感情的积累，给人感觉夫子不像是个痛苦中升华的夫子，南子也不像是个心有戚戚的知音。这种台词所期待的那种与观众的共鸣并不是很强烈，因此南子死前的追忆就显得莫名奇妙。
并且我非常同情卫国国君，一把年纪了自己的娇妻临死前想的还是别人&amp;hellip;&amp;hellip;..
情感无法共鸣，技术过于生硬，实在不能说是部佳作。
以上。</description>
    </item>
    
    <item>
      <title>【书感】向儿童学习</title>
      <link>http://littflower.github.io/posts/learn-something-from-children/</link>
      <pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/learn-something-from-children/</guid>
      <description>【书感】向儿童学习 今天早上读了王开岭《精神明亮的人》中的《向儿童学习》一篇，有感，故作此篇。
“假如你们还有一些东西不明白，请问问你们的父母。亲爱的家长们，如果你们有什么不明白的，请问问你们的孩子们。”
作者引了一段凯斯特纳《开学致辞》中对家长和孩子说的话，“让家长向孩子学习”确实给予人不小的震撼。
多少年来，中国的父母、老师们等一干“大人”始终将孩提时代视作是一个没有任何价值的、幼稚的、不够成熟的时代，他们往往焦急的盼望着孩子们可以早点成熟，就像是 “从生命之树进入文明社会的罐头厂” ，变成一个想自己一样的、散发着罐头气味的”正式人“或者”成品人“。
这种观念的根本原因在于教育者们没有意识到童年概念与成人概念可以并存，长期在社会上摸爬滚打的他们下意识的将童年视为成人的预备、过渡期。无非是以”自己三四十年来的生活经验“来裹挟孩子，最终使得这些儿童早早的结束自己的童年，成为一个”罐头人“。一代接一代下去，成为一个有资格呵斥下一代的”罐头人“。
诚然，这些父母长辈的社会经验没有错误，这个社会的确极端复杂，我们每个人作为有限的个体极端无知，但是——
从来如此，便对吗？
**对儿童的成人化塑造，是这个时代最愚蠢、最可笑、最无知的表演之一。**无论是哪个国家、哪个地区，父母们都习惯于将自己的人生经验、”人生哲理“强加于孩子，将自己的焦虑转移给孩子，他们却忘记了——
这样最多只能成为你，只有自己走，才能超越你。
除此之外，大部分的成人的同情心、共情能力是远远不及孩子们的。当今中国社会的许多社会现象，背后都有人心冷漠、世风日下、人性黑暗的影子，成人往往习惯于优先考虑自己的利益，硬生生将社会大家庭变成了”黑暗森林“。
在对于善恶、美丑、好坏的区分上，儿童做出的选择往往要比成人合适得多、果断得多。
但这也不是一个人的改变，这需要全社会的人达成共识，并作出努力。
可惜，道德是自律，而不是他律。
我们只能先要求自己：尽量在长大的同时，保留那么些童心吧。
所谓的长大，表面上是一种增值，实际上，这是在用自己的美好品质，去交换这个社会的某种默认逻辑、某种生存法则。就像是少年不断掏出自己兜中的宝石，去交换巫婆手里的玻璃球，可笑、可怜且可恨。
扪心自问——
从何时起，你开始开始嘲笑天真了？
从何时起，你开始为自己的”幼稚“而鬼鬼祟祟的脸红了？
以上。</description>
    </item>
    
    <item>
      <title>2022 新年致辞</title>
      <link>http://littflower.github.io/posts/2022-new-year-speech/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/2022-new-year-speech/</guid>
      <description>何谓青年信仰 0x00. 序言 撕下2021年日历的最后一页，今天是2022年的第一天。
良久，我在电脑桌前徘徊，想起几周前读过的《看见》，踌躇许久。
凛冬已至，但人心不寒。
这人世间千变万化，惟有一种信仰亘古永恒。
没有什么可以轻易把人打动，除了正义的号角。
没有什么可以轻易把人打动，除了人心里的爱。
没有什么可以轻易把人打动，除了真相。
是啊，在中国，总有一种力量，让我们泪流满面。
这力量，更是一种信仰，一种 “正义、爱、执着于真相” 的信念。
0x01. 何为信仰 自2021年以来，我们的祖国度过了激流般的 $365$ 天，多少繁华往事，多少鲜血汗水，已付笑谈中。
但我想，中华民族的强大，断不是因为上位者的强大，而是因为这个民族的每一份子，这个国民集体的每一个人，都有着最热忱的信念。
这种信念，让我们继续前行，因为这是我们的责任，因为我辈青年是社会的中坚。
**这种信念，更是一种信仰。**而这信仰，把我们照亮，给予我们力量。
当新冠疫情袭卷武汉之时，无论我们身在现场，还是在千里之外，都能感到一致的悲伤；在新疆棉事件发生之时，无论我们是职场白领，还是在校学生，都曾拍案而起，怒不可遏，对那些所谓“名牌”口诛笔伐；当第十四届全国运动会召开之时，无论我们是爱国愤青，还是耄耋老人，都激动地挥舞自己的拳头！
这样的时事数不胜数，这是因为，每一个人都在关注时事。这个国家的国民集体休戚与共，须臾不曾分离。
当我们扪心自问，我们发现，我们对彼此的爱无可置疑，对这个国家的爱无可置疑。
不仅如此，当我们面对蒙冤无助的弱者，当我们面对专横跋扈的恶人，当我们面对穷困潦倒的穷人，当我们面对面目可憎的资产阶级，当我们面对受到侮辱的女性，当我们面对足以影响一名少年未来人生的不公之时，我们就明白，正义还需要多少付出，正义需要多大代价，正义需要多少的勇气！
可是我们不怕，因为，此时此刻，在信仰的影响之下，我们心中，对这个国家、这个民族真挚的爱，已经给了我们如何行事的答案。
是的，**我们不仅赞扬国家的进步，我们还批评它的不尽完美。**乌托邦的幻梦早已死去。当自由民主深入人心之时，这个国家的人民就已像捧着烛火一样小心翼翼地捧着真相，发出一片盈盈之光。
星星之火，可以燎原。
0x02. 回首过去、展望未来 遥想起，30年前，改革开放，我们的父辈苦苦耕耘，何其艰辛。他们用他们的热血、他们的汗水，给予我们一个比过去更好的世界。反观今人，我们是否能够给予我们的孩子一个生活在更好的世界的权力？我们是否可以问心无愧地说出：我们没有推卸责任，未曾辜负历史的托付。
《南方周末》中有一句话：我们越是望向历史深处，就越是坚定。
在这条名为历史的、长度为一百多年的线段的左端点，西方列强用钢枪大炮打开了国门，用武力迫使中国滑向半封建半殖民地的深渊；我们的先贤发现固步自封、封建主义不能救中国，于是漂洋过海以求国家振兴之道。因此，有了西风东渐，是以 “建兵工厂以御外辱，置民业以求国富，办期刊以开民智，造学堂以期未来。”
可是，在这条线段的右端点的今天，在这漫长历史的此端，我们可曾想过，这国家的希望从何而来，我们又能否让着希望延续下去？
我们不是聪明绝顶之辈，我们没有极高的政治权力，我们没有惊为天人极为可观的财富，我们甚至不比任何一代中国人更优秀。**可是时代的接力棒已经落在我们手中，只能我们，也只是我们。这接力棒给了我们一个冲向终点的机会，给了我们一个冲向终点的责任。**我们与时间赛跑，与时代赛跑，与各国的同辈青年人赛跑——在这场世界性的运动会上，我们必须拿好接力棒，义无反顾地向前冲去。
因此，“让无力者有力，让悲观者前行。”
因此，我们必须了解真相，相信真理。
因此，我们要求应然之事，要做心怀理想主义的现实主义者。
这世间千变万化，唯真相亘古不变。
一切都是为了，当我们讲述自己的国家时，我们可以平静、深邃、淡泊。
一切都是因为，我们要对给予我们接力棒的人负责，要对观众席上为我们呐喊的人负责。
我们要对这个国家负责。
当新年的曙光笼罩大地之时，当我们看到它辽阔的天空，当我们看到草原上奔跑的牛马，当我们看到海面上粼粼的波光，当我们看到高山上环绕的云雾，当我们看到夜空中皎洁的月光，当我们看着车流不息的都市，当我们看到阡陌纵横的土地&amp;hellip;&amp;hellip;.
当我们的孩子即将出生，在夜色中发出柔弱却嘹亮的哭泣声，我们知道，没有任何东西比这种信仰更加珍贵。
没有任何时代有如此之多的苦难，同样地，也没有如此多的希望。
0x03. 新年贺词 2022，让我们以我辈青年所独有的信仰，彼此照亮；愿山河锦绣，愿国泰民安。
让我们迎着新年初生的太阳，与你一起，勇敢前行！</description>
    </item>
    
    <item>
      <title>关于爱情观</title>
      <link>http://littflower.github.io/posts/the-concept-of-love/</link>
      <pubDate>Sat, 25 Dec 2021 23:33:07 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/the-concept-of-love/</guid>
      <description>关于爱情观 0x01.起点 说起来有些僵硬，我一度深陷于一个困境，一个难以破开的墙壁。
它竖在我面前，一次次使我质疑我的选择。若我本性如此，难道是我本性错矣？
“如果说《兔子快跑》展示了一个关于爱情的道理的话，它就是：一个人是多么容易把对自己的鄙视误解为对爱情的需要。兔子先生厌恶自己的平庸空洞，于是他不断制造爱的泡沫。……爱情的伟大之处在于它可以遮蔽一个人存在的虚空，爱情的渺小之处在于它只能遮蔽这个虚空而已。”
“我想之所以永远有这么多人在忙着得到爱失去爱抱怨爱唠叨爱，除了伟大的化学反应，还因为爱情是成本很小、‘进入门槛’很低的戏剧。如果要以做成一个企业、创作一个艺术品、解决一个科学难题、拯救一个即将灭绝的物种……来证明自己，所需才华、意志、毅力、资源、运气太多，而要制造一场爱情或者说那种看上去像爱情的东西，只需两个人和一点荷尔蒙而已。于是爱情成了庸人的避难所，于是爱情作为一种劳动密集型产品被大量生产出来。说到底一个人要改变自己太难，改变别人更难，剩下的容易改变的只是自己和别人的关系。在一起，分手，和好，再分手，第三者，第四者……啊，枝繁叶茂的爱情，让一个可忽略可被替代可被抹去而不被察觉的存在，看上去几乎像是生活。”
不对，我应该多想。三思而后行。
多想想。
多想想。
多想想。
半夜翻起身来抱着一本《三体Ⅱ》开始看，半睡半醒中看到罗辑和白蓉的对话，感觉这人的感情线好棒。
$20min$ 后，我睡意全无。
0x02. 思考 如此思想产生于约两个月前，那时我正在读《三体Ⅱ》，书中写道：主人公罗辑与自己的梦中情人“生活”在一起，他如此痴迷于她以至于几乎要和自己现实生活中的女朋友分手，罗辑去看了心理医生&amp;hellip;&amp;hellip;
罗辑没有回学校，开着车径直去看心理医生。
听完罗辑的漫长叙述后，医生对他说。你可能需要一些调整，但没什么大事。
没什么大事？罗辑瞪大了满是血丝的双眼。“我疯狂地爱上了自己构思的小说中的一个虚构人物，和她一起生活，同她出游，甚至于就要因她和自己真实的女朋友分手了，你还说没什么大事？”
医生宽容地笑了笑。
“你知道吗？我把自己最深的爱给了一个幻影！”
“你是不是以为，别人所爱的对象都是真实存在的？”
“这有什么疑问吗？”
“不是的，大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的她(他)，而只是想象中的她(他)，现实中的她(他)只是他们所创造的梦中情人的一个模板，他们迟早会发现梦中情人。”
当我读到这里时，内心深受震撼，不仅是因为为罗辑所谓的幻想中的梦中情人的感觉而感动，也因为这位心理医生对于喜欢的理解，深深触动了我。
这句话的深刻内涵是，每个人内心都有一个“梦中情人”，在每个人自己的时间线的某一个时间节点上，他们遇到了与自己内心中的“模板”契合度较高的那个他/她，于是疯狂心动（crush）。这种 crush 可以是精神品质；也可以是虚无缥缈的主观体验。不论怎么样，只要在看见他/她的那一瞬间，我们感受到了自上而下的电流的感觉，我们就可以将其定义为“喜欢/心动”。同样的，当两个人彼此都“喜欢/心动”（crush）时，两个人的陌生感便开始飞速下降——他们彼此尝试接触对方。
但请注意，这种 crush 并不需要承担任何责任，也不需要履行任何义务，它只是人动物性的一面的直观展现：荷尔蒙爆发所带来的快感是难以估量的，对人的诱惑是难以抵抗的。于是，彼此 crush 的男女们将用各种各样的方式接触彼此：聊天、看电影、吃饭、喝奶茶&amp;hellip;.. Anyway，这些可以用 date 一言以蔽之的方式消解了人与人之间的陌生感，提高了彼此的亲密度，双方的底线也在逐渐探明。
接下来，人的动物性将继续展现：由于这种 crush 的“低风险高回报”性质（几乎没有风险），有一些时间管理大师会同时与多个异性同时展开 date&amp;hellip;..虽然但是，东方爱情观与西方爱情观最大的差异也在此体现。
请注意，在西方爱情观中，上面这种“时间管理操作”并不涉及人的道德品行，换言之，西方人不能定性其为“渣男”/“渣女”；
但在东方爱情观中，这显然违背了社会所谓的道德准则（我甚至需要再写一篇文章分析这所谓的贯穿古今的道德准则）。
继续上文。
事实上，“我喜欢他/她”这句话是不严谨的，更严谨的表述方式是“我在这个时间节点上喜欢他/她”。这是因为，下个节点喜不喜欢，是下个时间节点的状态：我可以继续喜欢，我也可以另觅佳人。这告诉我们，该分开时请果断分开。哪怕是上一秒钟在一起约会，下一秒钟就分手告别（尽管这听起来很忌讳），只要在任意时间节点都能保证自己精神与人格的独立，就都是合理的。显然，因为下一秒钟是上一秒钟的下一个时间节点，而下一个时间节点喜欢与否，与上一个时间节点毫不相干。时间节点的度量单位，显然是相对的。
但是啊，这并不是说一个人可以同时拥有很多段关系。在 date 的时候可以大胆放纵，但当真正需要做出抉择时，任何人都应当慎重。
因此，渣男/渣女的衡量标准不应该是有过多少个 date 对象，而应该是他/她在面临一个足够影响彼此幸福的选择时，是否足够慎重。
轻浮的决定，既是对自我人格的贬低，也是对对方的亵渎。
事实上，当两个人没有彼此确定对方为生命里的唯一时，当两个人没有将自己存在的意义定义为与对方相遇时，一切的“暧昧”都只可以被定义为广义的试探。我们继续往下追问：试探什么？
试探什么？
停下来思考。
人类的思维具有隐藏性，没有人会将自己的内心赤裸裸地暴露给他人&amp;hellip;&amp;hellip;这种以自我保护为目的的外衣包裹住了各种各样的人格，并使之呈现出彼此契合的特征——是的，看起来的契合，也许只不过是外面那一层糖衣。剥开糖衣之后，里面到底是温柔如水，还是残暴如虎，都是未知。这种外表与内在人格的错位毫无疑问是危险的：当前时间节点的情投意合，下个时间节点也许会彼此反目。
嘿，这便是试探的意义。
没有人可以周旋生活于谎言构成的生活中而不被任何人发现，假的终究是假的，糖衣会随着时间的推移而慢慢融化。
是的，通过长期的试探（哪怕是外出旅游或是同居），当两个人试着完全像夫妻一样相处几个月后，一切琐碎的或者是非琐碎的事情都会暴露在彼此眼前。
此时，当彼此看到对方性格中的、品行上的、生活习惯上的与自己不契合的缺陷时，请扪心自问，曾经的那种 crush 是否还存于彼此心中呢？对方还是彼此眼中的那个少年吗？
我们来分类讨论：
若不是，emmm&amp;hellip;快跑 /捂脸 若是，恭喜你，你找到了世人口中所谓的那个“对的人”。 只是，在茫茫人海中觅一精神伴侣，谈何容易？
一言以蔽之，按照以上理论推出的爱情观）应当如下：
爱情的产生总是不失一般性： 看山是山（crush） 看山不是山（疯狂试探并且看到对方的缺点） 看山还是山（发现自己竟然可以包容对方的缺点并继续喜欢） 事实上啊，当“看山还是山”的时候，我应当称之为“爱情”。</description>
    </item>
    
    <item>
      <title>分块思想</title>
      <link>http://littflower.github.io/posts/blocking-algorithm/</link>
      <pubDate>Fri, 19 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/blocking-algorithm/</guid>
      <description>分块思想 一、性质与证明 分块，故名思意，是将一个区间分成几个块，然后对于每个询问，整合一个或多个（甚至全部区间）的信息，但这种分块和整合是有技巧性de，否则很难有效的降低时间复杂度。
先来看一道例题：
老方有一个长度为 $n$ 的序列，被她的学生拜托完成以下三个操作：
修改某位置的元素值 将一段区间的元素加上或减去一个值 求一个区间内的最大最小值 共有 $m$ 个这样的操作，保证 $n, m &amp;lt;= 50000​$
考虑分块。
我们考虑将整个序列划分为 $\sqrt n$ 块，因为这样可以使得总查询时间最短。
证明如下：
​	设这个序列的完整分块数是 $C$ 块，每一个完整个分块都包含 $S$ 个元素，那么显然可能存在一种情况即在区间 $[l, r]$ 的两端包含有不完整的分块。
如图，蓝色部分即为不完整的分块。
可以发现该序列内有 $C​$ 个完整分块和两个不完整分块，且这两个不完整分块内元素数量之和小于 $2S​$ ，则对于一个序列而言，我们要进行的查询总数的极限为 $C + 2S​$ ，则时间复杂度为 $O(C + 2S)​$ ，也就相当于 $O(max{ { C, S } } )​$.
因此，由于 $C * S + 2 * S &amp;gt;= r - l + 1$ ，则可以近似的看作当且仅当 $S = C$ 时，时间复杂度可以取得最小上界， 此时 $C = S = \sqrt n $ .</description>
    </item>
    
    <item>
      <title>区间线段类问题合集</title>
      <link>http://littflower.github.io/posts/collection-of-interval-segment-problems/</link>
      <pubDate>Fri, 12 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/collection-of-interval-segment-problems/</guid>
      <description>0x00.前言 近一个月以来，不管是在模拟赛中，还是在日常做题中，甚至是在CSP考试中，都遇到了各种各样的区间问题，其题目形式、背景多种多样，但其根本都可以归纳为一种区间线段模型，遂加以整理。
0x01. 维护单一线段+选取部分区间 首先来看这一种较为基础的版本。
题目链接：luogu P1803
题目大意：给定 $n$ 个区间，要求维护一条线段（时间线），使得落在该条线段上的区间尽可能的多。注意：任取这条线段上一点，都要满足不被两个及以上的区间覆盖。求最多能放多少个线段。
题目解析：这道题目要求线段上任意一个点都不被两个及以上的区间覆盖，也就是说凡是合法解必然是由不相交的区间构成的。考虑用贪心的策略：**对于所有区间，按左端点排序，然后依次考虑每个区间，能放就放。**这个策略的正确性显然，因为越靠前的区间放置后，对于后面的区间影响越小。如何维护这个线段呢？区间有哪几种关系呢？停下来思考。
显然，区间有且只有 相交、相离、包含 三种关系。
更为具体的，在这个题目背景下，我们不难发现，只需要维护线段的右端点$pos$，依次考虑每个区间，如果区间与线段相交，则跳过这个线段，如果区间被线段包含，则需要用当前区间右端点替换线段右端点，因为这样对最终的答案不会更差，如果区间与线段相离，更新$pos$为当前区间右端点，$ans$++
#include &amp;lt;bits/stdc++.h&amp;gt; #define MAXN (1000007) using namespace std; int n, ans = 1; struct edge { int l, r; }e[MAXN]; bool inline cmp(const edge x, const edge y) { if(x.l == y.l) return x.r &amp;lt; y.r; return x.l &amp;lt; y.l; } int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); for(int i = 1; i &amp;lt;= n; ++i) { scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;e[i].</description>
    </item>
    
    <item>
      <title>测试页面（数学公式）</title>
      <link>http://littflower.github.io/posts/test-of-math/</link>
      <pubDate>Fri, 18 Jun 2021 18:04:39 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/test-of-math/</guid>
      <description>质点运动学 圆周运动 角度 - 角速度 - 角加速度：$\theta -\omega -\alpha$
切线加速度 $a_{t}=\alpha r$（角加速度 × 半径） 法线加速度 $a_{n}=\omega^{2}r$（角速度的方 × 半径） 运动建模及其方程 大部分的模型方程都是基于三角形的勾股定理
牛顿定律及常见力 没什么好记的
转动惯量和力矩 转动惯量和动能的关系：$E_{k}=\dfrac{1}{2}J\omega ^{2}$
转动惯量与角动量：$L=J\omega$
转动惯量结论 质点（微元）、绕中心旋转的薄圆环：$J=mR^{2}$（各质元到轴的垂直距离都相同） 绕中心旋转的圆盘（柱）：$J=\dfrac{1}{2}mR^{2}$ 棒子绕一端转：$J=\dfrac{1}{3}mL^{2}$ 棒子绕中心：$J=\dfrac{1}{12}mL^{2}$ 转动惯量计算（微元法） 例1：设转轴在棒的一端且与棒垂直，棒长为 $L$ ，求转动惯量 $J$
解：在棒上离轴 $x$ 处，取长度元 $dx$，单位长度质量为 $\lambda$，则
$dJ=dm\cdot x^{2}=x^{2}\lambda dx$
$J=\int _{0}^{L}\lambda x^{2}dx=\dfrac{\lambda L^{3}}{3}=\dfrac{1}{3}mL^{2}$
例2：转轴移到中点？（原点在中间，从一端积分到另一端，所以是 $-\dfrac{L}{2}$ 到 $\dfrac{L}{2}$）
$J_{2}=\int ^{\dfrac{L}{2}}_{-\dfrac{L}{2}}\lambda x^{2}dx=\dfrac{\lambda L^{3}}{12}=\dfrac{1}{12}mL^{2}$
例3：求质量为 $m$，密度为 $\rho $，半径为 $R$，厚度为 $h$的均质圆盘的转动惯量（转轴在中心且垂直）
解：将圆盘看成是很多垂直薄圆环（$V_{0}$）组成
$dJ=dm\cdot r^{2}=r^{2}\cdot \rho \cdot V_{0}$
又因为 $V_{0}=h\cdot S=h\cdot 2\pi r\cdot dr$</description>
    </item>
    
    <item>
      <title>友情链接</title>
      <link>http://littflower.github.io/friends/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://littflower.github.io/friends/</guid>
      <description>朋友们 没有你们, 就没有今天的我.
高中时认识的学长 Reverier: 开发爷 @ XDU 2019 BlackBird: pwn👴 @ XDU 2021 YunZh1Jun: 逆向👴 @ XDU 2021 0x401 ltfa1l：House 领域大神 @ SCU 2018 T1d：神秘出题人 @ SCU 2021 N1 Junior imiab: 香香软软小男娘 @ NEUQ 2024 打 CTF 认识的师傅 Delete: From MssCTF2023 @ GDUFE 2023 GZTime: From CTF @ SYSU 2019 </description>
    </item>
    
  </channel>
</rss>
