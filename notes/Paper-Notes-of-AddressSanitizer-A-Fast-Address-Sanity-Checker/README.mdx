<!DOCTYPE html>
<html id="_top" lang="zh-CN" data-theme="light"><head><script>(function () {
        const storageKey = "theme";
        const root = document.documentElement;
        const supportsMatchMedia = typeof window.matchMedia === "function";
        const mediaQuery = supportsMatchMedia
            ? window.matchMedia("(prefers-color-scheme: dark)")
            : null;

        const readStorage = () => {
            try {
                return window.localStorage.getItem(storageKey);
            } catch (error) {
                return null;
            }
        };

        const writeStorage = (value) => {
            try {
                window.localStorage.setItem(storageKey, value);
            } catch (error) {
                return;
            }
        };

        const applyTheme = (value) => {
            const theme = value === "dark" ? "dark" : "light";
            root.setAttribute("data-theme", theme);
            if (document.body) {
                document.body.setAttribute("data-theme", theme);
            } else {
                document.addEventListener(
                    "DOMContentLoaded",
                    () => {
                        if (document.body) {
                            document.body.setAttribute("data-theme", theme);
                        }
                    },
                    { once: true }
                );
            }
            return theme;
        };

        const updateButton = (value) => {
            const theme = value === "dark" ? "dark" : "light";
            const button = document.querySelector("[data-theme-toggle]");
            if (!button) {
                return;
            }
            const label = button.querySelector("[data-theme-toggle-label]");
            const isDark = theme === "dark";
            button.setAttribute("aria-pressed", isDark ? "true" : "false");
            button.setAttribute("title", isDark ? "切换为浅色主题" : "切换为深色主题");
            if (label) {
                label.textContent = isDark ? "深色" : "浅色";
            }
        };

        const stored = readStorage();
        const initial =
            stored === "light" || stored === "dark"
                ? stored
                : mediaQuery && mediaQuery.matches
                  ? "dark"
                  : "light";

        const appliedTheme = applyTheme(initial);
        updateButton(appliedTheme);

        window.__setTheme = (value) => {
            const theme = applyTheme(value);
            writeStorage(theme);
            updateButton(theme);
        };

        window.__toggleTheme = () => {
            const current =
                root.getAttribute("data-theme") === "dark" ? "dark" : "light";
            const next = current === "dark" ? "light" : "dark";
            const theme = applyTheme(next);
            writeStorage(theme);
            updateButton(theme);
        };

        const syncButtonState = () => {
            updateButton(root.getAttribute("data-theme"));
        };

        const attachToggle = () => {
            const button = document.querySelector("[data-theme-toggle]");
            if (!button || button.__themeToggleBound) {
                return;
            }
            button.__themeToggleBound = true;
            button.addEventListener("click", (event) => {
                event.preventDefault();
                if (typeof window.__toggleTheme === "function") {
                    window.__toggleTheme();
                }
            });
        };

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", () => {
                syncButtonState();
                attachToggle();
            });
        } else {
            syncButtonState();
            attachToggle();
        }

        const handleMediaChange = (event) => {
            const storedTheme = readStorage();
            if (storedTheme === "light" || storedTheme === "dark") {
                updateButton(storedTheme);
                return;
            }
            const next = event.matches ? "dark" : "light";
            const theme = applyTheme(next);
            updateButton(theme);
        };

        if (mediaQuery) {
            if (typeof mediaQuery.addEventListener === "function") {
                mediaQuery.addEventListener("change", handleMediaChange);
            } else if (typeof mediaQuery.addListener === "function") {
                mediaQuery.addListener(handleMediaChange);
            }
        }
    })();
    if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
            navigator.serviceWorker.register("/sw.js").catch(() => {});
        });
    }</script><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="color-scheme" content="light dark"/><meta name="language" content="zh-CN"/><title>论文笔记《AddressSanitizer: A Fast Address Sanity Checker》 | 花盆</title><meta name="author" content="LittFlower"/><meta name="description" content="论文笔记《AddressSanitizer: A Fast Address Sanity Checker》"/><meta property="og:title" content="论文笔记《AddressSanitizer: A Fast Address Sanity Checker》 | 花盆"/><meta property="og:description" content="论文笔记《AddressSanitizer: A Fast Address Sanity Checker》"/><meta property="og:site_name" content="花盆"/><meta property="og:locale" content="zh-CN"/><link rel="canonical" href="https://blog.littflower.top/notes/Paper-Notes-of-AddressSanitizer-A-Fast-Address-Sanity-Checker/README.mdx"/><link rel="alternate" type="application/rss+xml" title="花盆" href="/rss.xml"/><link rel="stylesheet" href="/fonts.css" type="text/css" preload/><link rel="stylesheet" href="/style.css" type="text/css" preload/></head><body><div class="top-bar fullwidth"><div class="top-bar-inner fullwidth"><div class="top-bar-group"><a href="/" aria-label="root" class="file-link"><img src="/icons/dir.png" alt/><span>/</span></a><a href=".." aria-label="parent" class="file-link"><img src="/icons/dir.png" alt/><span>..</span></a></div><div class="top-bar-group"><h3><a href="#_content"><code class="hash inline-code">#</code>内容</a></h3><h3><a href="#_top"><code class="hash inline-code">#</code>回到顶部</a></h3><button type="button" data-theme-toggle="true" aria-label="切换亮暗主题" aria-pressed="false" title="切换主题" class="theme-toggle"><code aria-hidden="true" class="hash inline-code">#</code>  <span data-theme-toggle-label="true" class="theme-toggle-label">浅色</span></button></div></div></div><div class="page-shell"><div class="page-files"></div><div class="page-main"><div id="_content" style="scroll-margin-top:48px;" class="page-article"><h2 id="0x00.-abstract" class="scroll-target"><a href="#0x00.-abstract"><code class="hash inline-code">#</code>0x00. Abstract</a></h2>
<p>对于 C 和 C++ 等编程语言来说，内存访问错误（包括缓冲区溢出和 use after free）仍然是一个严重问题。存在许多内存错误检测器，但大多数检测器要么速度慢，要么局限于有限的错误集，或者两者兼而有之。本文介绍了 AddressSanitizer，一种新的内存错误检测器。这个工具可以查找对堆、堆栈和全局变量的越界访问，以及 use after free。它采用专门的内存分配器和代码工具，足够简单，可以在任何编译器、二进制翻译系统甚至硬件中实现。AddressSanitizer 在不牺牲全面性的情况下实现了效率。它的平均速度仅为 73%，但它可以在错误发生时准确地检测到错误。它在 Chromium 浏览器中发现了 300 多个以前未知的错误，以及其他软件中的许多错误。</p>
<h2 id="0x01.-introduction" class="scroll-target"><a href="#0x01.-introduction"><code class="hash inline-code">#</code>0x01. Introduction</a></h2>
<p>AddressSanitizer 由两部分组成：<strong>检测模块</strong>和<strong>运行时库</strong>。<strong>检测模块</strong>修改代码以检查每次内存访问的<em>影子态 (shadow state)</em>，并在堆栈和全局对象周围创建<em>中毒红区</em>以检测向上或向下溢出。当前的实现基于 LLVM 编译器基础设施。<strong>运行时库</strong>替换了 <code class="inline-code">malloc</code>、<code class="inline-code">free</code> 和相关函数，在分配的堆区域周围创建<em>中毒红区</em>，延迟已释放堆区域的重用，并进行错误报告。</p>
<p>总的来说，这篇文章做了以下几件事：</p>
<ul>
<li>说明了内存错误检测器可以利用<em>影子内存 shadow memory</em>的全面性，并且开销比传统方法低得多；</li>
<li>提出一种新颖的影子态编码方式，可实现紧凑的影子内存（高达 128-to-1），用于检测越界和 use-after-free 错误；</li>
<li>描述一个针对新实现的影子编码的专用内存分配器；</li>
<li>评估一个新的公开可用的工具，该工具可以有效地识别内存错误。</li>
</ul>
<h2 id="0x02.-related-work" class="scroll-target"><a href="#0x02.-related-work"><code class="hash inline-code">#</code>0x02. Related work</a></h2>
<h3 id="shadow-memory" class="scroll-target"><a href="#shadow-memory"><code class="hash inline-code">#</code>影子内存（shadow memory）</a></h3>
<p>总的来说，按照对应用程序地址的处理可以把现有的工具分为两种：</p>
<ul>
<li>通过直接缩放和偏移（其中完整应用程序地址空间映射到单个影子地址空间）；</li>
<li>通过涉及查表的额外转换来映射到影子地址空间。</li>
</ul>
<p>直接缩放和偏移的例子有：</p>
<ul>
<li>TaintTrace</li>
<li>LIFT</li>
</ul>
<p>使用多级转换的例子有：</p>
<ul>
<li>Valgrind</li>
<li>Dr.Memory</li>
</ul>
<p>还有一些比较 trick 的工具：</p>
<ul>
<li>Umbra：兼顾布局灵活性和效率，使用可动态调整的缩放和偏移来直接映射地址而非使用查表的方式；</li>
<li>BoundLess：利用 64 位寄存器的高 16 位来做到内存复用，但是在慢速路径下会退化；</li>
<li>LBC：使用存储在应用程序内存中的特殊值执行快速路径的检查，并在慢速路径上依赖于两级影子内存。</li>
</ul>
<h3 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>实现</a></h3>
<p>大部分内存检测工具都基于二进制文件，这些工具可以发现堆内存的越界和 UAF，还可以识别未初始化的读取，不过没办法识别堆栈和全局变量的越界错误，好消息是基本不会误报。例如：Valgrind，Dr.Memory，Discover，BoundsChecker 等等</p>
<p>而使用编译时检测的工具虽然可以检测堆栈对象的越界访问，但是无法检测所有的堆栈缓冲区溢出错误，而且可能误报，例如 Mudflap。</p>
<p>还有一些依赖于静态分析的检测工具，但是只支持 C 语言，例如 CClured，还有不开源的，例如 Insure++。</p>
<p>还有一些内存检测工具基于专门的内存分配器，使用 CPU 页面保护。每个分配的区域都被放置到一个专用页面（或一组页面）中。右侧（和/或左侧）的额外一页被分配并标记为不可访问。随后访问这些页面的页面错误将被报告为越界错误。这些工具会产生大量内存开销，并且在 <code class="inline-code">malloc</code> 密集型应用程序上可能会非常慢（因为每个 <code class="inline-code">malloc</code> 调用都需要至少一个系统调用）。此外，这些工具可能会遗漏某些类别的错误（例如，从 5 字节的内存区域的开头读取偏移量为 6 处的内存）。如果工具报告出错误，错误消息中会提供负责的说明。例如：Electric Fence、Duma、GuardMalloc 和 Page Heap 等工具。</p>
<p>其他一些工具依赖于对 <code class="inline-code">malloc</code> 的实现，包括 DieHarder（DieHard malloc 的后代）和 Dmalloc，有概率、有延迟发现内存错误。他们修改后的 <code class="inline-code">malloc</code> 函数在返回给用户的内存区域的周围添加了<em>中毒红区</em>，并用特殊的 magic 值填充新分配的内存。 free 函数还将 magic 值写入内存区域。</p>
<p>但是这种依赖于 magic number 的实现有一些问题，当 magic number 被读取时，这些工具没办法立刻知道这件事情，现有的 DieHard 只能靠比较程序输出来检测不正确的行为，所以这个报错是概率性的、延迟性的；同理，当 redzone 里填充的 magic number 被覆盖，稍后在空闲时检查这个 redzone 会发现这件事情，但是这些工具没办法知道越界写入或者 UAF 是什么时候发生的（（... <del>对于 malloc 密集的大型程序这就相当于给你报了个“你的程序有一个错误”</del></p>
<p>还有个问题，debug malloc 工具不分析堆栈变量或者全局变量可能存在的内存错误。</p>
<p>现有的堆栈上的金丝雀保护其实只能防止攻击者利用缓冲区溢出劫持程序执行流，无法检测堆栈上的局部变量的越界访问。</p>
<h2 id="0x03.-addresssanitizer-algorithm" class="scroll-target"><a href="#0x03.-addresssanitizer-algorithm"><code class="hash inline-code">#</code>0x03. AddressSanitizer Algorithm</a></h2>
<p>AddressSanitizer 的内存检测方法类似于 Valgrind 的工具 AddCheck，仍然使用影子内存来记录应用程序的每个字节，通过对比来确定程序可能存在的各种内存溢出问题。不过前者更加高效、快速，而且可以检测堆栈、堆和全局变量中的溢出错误。</p>
<h3 id="shadow-memory" class="scroll-target"><a href="#shadow-memory"><code class="hash inline-code">#</code>Shadow Memory</a></h3>
<p>AddressSanitizer 的主要原理是对程序中的虚拟内存提供粗粒度的影子内存（每 8 个字节的内存对应 1 个字节的影子内存）。</p>
<p>具体来说，由于 <code class="inline-code">malloc()</code> 分配的内存空间一般是 8 字节对齐的，通过分析这 8 个字节各自的可访问性，一共有 9 个状态。这 9 个状态可以放在影子内存的 1 个字节内。</p>
<p>AddressSanitizer 依然使用直接缩放和偏移的方案，即将 1/8 的虚拟地址空间专用于其影子内存，并使用映射将剩余 7/8 的地址映射到 1/8 上。给定应用程序内存地址 Addr，影子字节的地址计算为 <code class="inline-code">(Addr >> 3) + Offset</code>，这里的 <code class="inline-code">Offset</code> 是必须为每个平台静态选择的（与 Umbra 的完全动态不同）。</p>
<p>影子内存中每个字节存取一个数字 k，如果 k = 0，则表示该影子内存对应的 8 个字节的内存都能访问；如果 k 在 0 到 7 之间，表示前 k 个字节可以访问；如果 k 为负数，表示这 8 个字节不可寻址，不同的数字表示不同的不可寻址的类型（e.g. Stack buffer overflow, Heap buffer overflow)。具体的映射策略如下图所示。</p>
<p>x64: <code class="inline-code">Shadow = (Mem >> 3) + 0x7fff8000;</code></p>
<table><thead><tr><th>起始地址</th><th>结束地址</th><th>对应区段</th></tr></thead><tbody><tr><td>0x10007fff8000</td><td>0x7fffffffffff</td><td>HighMem</td></tr><tr><td>0x02008fff7000</td><td>0x10007fff7fff</td><td>HighShadow</td></tr><tr><td>0x00008fff7000</td><td>0x02008fff6fff</td><td>ShadowGap</td></tr><tr><td>0x00007fff8000</td><td>0x00008fff6fff</td><td>LowShadow</td></tr><tr><td>0x000000000000</td><td>0x00007fff7fff</td><td>LowMem</td></tr></tbody></table>
<p>x32: <code class="inline-code">Shadow = (Mem >> 3) + 0x20000000;</code></p>
<table><thead><tr><th>起始地址</th><th>结束地址</th><th>对应区段</th></tr></thead><tbody><tr><td>0x40000000</td><td>0xffffffff</td><td>HighMem</td></tr><tr><td>0x28000000</td><td>0x3fffffff</td><td>HighShadow</td></tr><tr><td>0x24000000</td><td>0x27ffffff</td><td>ShadowGap</td></tr><tr><td>0x20000000</td><td>0x23ffffff</td><td>LowShadow</td></tr><tr><td>0x00000000</td><td>0x1fffffff</td><td>LowMem</td></tr></tbody></table>
<h3 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>实现</a></h3>
<p>在读写内存前，会对要读写的内存对应的影子内存的内容进行检查。</p>
<p>8 字节全部可读写：</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-c language-c"><span style="color:#393A34">ShadowAddr </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">Addr </span><span style="color:#AB5959">></span><span style="color:#AB5959">></span><span style="color:#2F798A"> 3</span><span style="color:#2993a3">)</span><span style="color:#AB5959"> +</span><span style="color:#393A34"> Offset</span><span style="color:#999999">;</span><br><span style="color:#1E754F">if</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">ShadowAddr </span><span style="color:#AB5959">!=</span><span style="color:#2F798A"> 0</span><span style="color:#2993a3">)</span><br><span style="color:#59873A">	ReportAndCrash</span><span style="color:#2993a3">(</span><span style="color:#393A34">Addr</span><span style="color:#2993a3">)</span><span style="color:#999999">;</span><br></code></pre></div>
<p>1-，2-，4- 字节访问时，我们需要把 k 和 Addr 的低 3 字节进行比较</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-c language-c"><span style="color:#393A34">ShadowAddr </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">Addr </span><span style="color:#AB5959">></span><span style="color:#AB5959">></span><span style="color:#2F798A"> 3</span><span style="color:#2993a3">)</span><span style="color:#AB5959"> +</span><span style="color:#393A34"> Offset</span><span style="color:#999999">;</span><br><span style="color:#393A34">k </span><span style="color:#999999">=</span><span style="color:#AB5959"> *</span><span style="color:#393A34">ShadowAddr</span><span style="color:#999999">;</span><br><span style="color:#1E754F">if</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">k </span><span style="color:#AB5959">!=</span><span style="color:#2F798A"> 0</span><span style="color:#AB5959"> &#x26;&#x26;</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#a65e2b">(</span><span style="color:#393A34">Addr </span><span style="color:#AB5959">&#x26;</span><span style="color:#2F798A"> 7</span><span style="color:#a65e2b">)</span><span style="color:#AB5959"> +</span><span style="color:#393A34"> AccessSize </span><span style="color:#AB5959">></span><span style="color:#393A34"> k</span><span style="color:#1e754f">)</span><span style="color:#2993a3">)</span><br><span style="color:#59873A">	ReportAndCrash</span><span style="color:#2993a3">(</span><span style="color:#393A34">Addr</span><span style="color:#2993a3">)</span><span style="color:#999999">;</span><br></code></pre></div>
<p>将 AddressSanitizer 检测放置在 LLVM 优化流程的最末端。通过这种方式，我们仅检测那些在 LLVM 优化器执行的所有标量和循环优化中“幸存”下来的内存访问。例如，对由 LLVM 优化掉的本地堆栈对象的内存访问将不会被检测。同时，我们不必检测 LLVM 代码生成器生成的内存访问（例如，寄存器溢出）。错误报告代码（<code class="inline-code">ReportAndCrash(Addr)</code>）最多执行一次，但在代码中插入了很多地方，因此必须紧凑一些。</p>
<h3 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>运行时</a></h3>
<p>运行时库的主要目的是管理影子内存。在应用程序启动时，整个阴影区域都会被映射，以便程序的其他部分无法使用它。影子内存的 Bad 段始终受到保护。</p>
<p><code class="inline-code">malloc</code> 和 <code class="inline-code">free</code> 函数被专门的实现所取代。<code class="inline-code">malloc</code> 函数在返回区域周围分配额外的 redzone。红区被标记为不可寻址或中毒。红区越大，检测到的上溢或下溢就越大。分配器内的内存区域被组织为与一系列对象大小相对应的空闲列表数组。当与用户所请求的内存块大小相对应的空闲内存块为空时，将从操作系统分配一组带有其红区的内存区域（例如 mmap）。对于 n 个区域，我们分配 n + 1 个红区，这样一个区域的右红区通常是另一个区域的左红区：</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-text">+—————————+
| redzone |
+—————————+
|   mem   |
+—————————+
| redzone |
+—————————+
|   mem   |
+—————————+
| redzone |
+—————————+
</code></pre></div>
<p>这个思路非常简单，通过 redzone 可以防止上溢和下溢。</p>
<p>此外，左边的 redzone 用于存储分配器的内部数据（如分配大小、线程 ID 等）；因此，红区的最小大小当前为 32 字节。该内部数据不会被缓冲区下溢损坏，因为这种下溢是在实际存储读写之前立即检测到的。</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-c language-c"><span style="color:#AB5959">struct</span><span style="color:#393A34"> ChunkHeader </span><span style="color:#2993a3">{</span><br><span style="color:#A0ADA0">  // 1-st 8 bytes.</span><br><span style="color:#393A34">  u32 chunk_state       : </span><span style="color:#2F798A">8</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // Must be first.</span><br><span style="color:#393A34">  u32 alloc_tid         : </span><span style="color:#2F798A">24</span><span style="color:#999999">;</span><br><span style="color:#393A34">  u32 free_tid          : </span><span style="color:#2F798A">24</span><span style="color:#999999">;</span><br><span style="color:#393A34">  u32 from_memalign     : </span><span style="color:#2F798A">1</span><span style="color:#999999">;</span><br><span style="color:#393A34">  u32 alloc_type        : </span><span style="color:#2F798A">2</span><span style="color:#999999">;</span><br><span style="color:#393A34">  u32 rz_log            : </span><span style="color:#2F798A">3</span><span style="color:#999999">;</span><br><span style="color:#393A34">  u32 lsan_tag          : </span><span style="color:#2F798A">2</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">  // 2-nd 8 bytes</span><br><span style="color:#A0ADA0">  // This field is used for small sizes. For large sizes it is equal to</span><br><span style="color:#A0ADA0">  // SizeClassMap::kMaxSize and the actual size is stored in the</span><br><span style="color:#A0ADA0">  // SecondaryAllocator's metadata.</span><br><span style="color:#393A34">  u32 user_requested_size : </span><span style="color:#2F798A">29</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">  // align &#x3C; 8 -> 0</span><br><span style="color:#A0ADA0">  // else      -> log2(min(align, 512)) - 2</span><br><span style="color:#393A34">  u32 user_requested_alignment_log : </span><span style="color:#2F798A">3</span><span style="color:#999999">;</span><br><span style="color:#393A34">  u32 alloc_context_id</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><span style="color:#999999">;</span><br></code></pre></div>
<p>free 函数也被 hook 了，它会标记整个内存区域为“中毒状态”并将其隔离，这样该区域就不会很快被 ptmalloc 拿去分配。目前，隔离区以 FIFO 队列的形式实现，该队列随时保存固定数量的内存。</p>
<p>默认情况下，<code class="inline-code">malloc</code> 和 <code class="inline-code">free</code> 会记录当前的调用堆栈，以便提供更多信息丰富的错误报告。<code class="inline-code">malloc</code> 调用堆栈存储在它左侧的 redzone 中（redzone 越大，可存储的帧数越大），而 <code class="inline-code">free</code> 调用堆栈存储在内存区域本身的开头。</p>
<h3 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>局部和全局变量</a></h3>
<p>为了检测对全局变量和堆栈对象的越界访问，AddressSanitizer 必须在此类对象周围创建中毒红区。对于全局变量，红区是在编译时创建的，红区的地址在应用程序启动时传递到运行时库。运行时库函数会标记红区并记录地址以供进一步的错误报告。对于堆栈对象，红区是在运行时创建并中毒的。</p>
<p>比如：</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-c language-c"><span style="color:#AB5959">void</span><span style="color:#59873A"> foo</span><span style="color:#2993a3">(</span><span style="color:#2993a3">)</span><span style="color:#999999"> </span><span style="color:#2993a3">{</span><br><span style="color:#AB5959">	char</span><span style="color:#B07D48"> a</span><span style="color:#1e754f">[</span><span style="color:#2F798A">10</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">	// &#x3C;your function></span><br><span style="color:#1E754F">	return</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br></code></pre></div>
<p>会被优化成：</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-c language-c"><span style="color:#AB5959">void</span><span style="color:#59873A"> foo</span><span style="color:#2993a3">(</span><span style="color:#2993a3">)</span><span style="color:#999999"> </span><span style="color:#2993a3">{</span><br><span style="color:#AB5959">	char</span><span style="color:#B07D48"> rz1</span><span style="color:#1e754f">[</span><span style="color:#2F798A">32</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	char</span><span style="color:#B07D48"> a</span><span style="color:#1e754f">[</span><span style="color:#2F798A">10</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	char</span><span style="color:#B07D48"> rz2</span><span style="color:#1e754f">[</span><span style="color:#2F798A">32</span><span style="color:#AB5959">-</span><span style="color:#2F798A">10</span><span style="color:#AB5959">+</span><span style="color:#2F798A">32</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	unsigned</span><span style="color:#AB5959"> *</span><span style="color:#393A34">shadow </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">unsigned*</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#a65e2b">(</span><span style="color:#a13865">(</span><span style="color:#AB5959">long</span><span style="color:#a13865">)</span><span style="color:#393A34">rz1 </span><span style="color:#AB5959">></span><span style="color:#AB5959">></span><span style="color:#2F798A"> 8</span><span style="color:#a65e2b">)</span><span style="color:#AB5959"> +</span><span style="color:#393A34"> Offset</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0"> // poison the redzones around arr.</span><br><span style="color:#B07D48">	shadow</span><span style="color:#1e754f">[</span><span style="color:#2F798A">0</span><span style="color:#1e754f">]</span><span style="color:#999999"> =</span><span style="color:#AB5959"> 0x</span><span style="color:#2F798A">ffffffff</span><span style="color:#999999">;</span><span style="color:#A0ADA0"> // rz1</span><br><span style="color:#B07D48">	shadow</span><span style="color:#1e754f">[</span><span style="color:#2F798A">1</span><span style="color:#1e754f">]</span><span style="color:#999999"> =</span><span style="color:#AB5959"> 0x</span><span style="color:#2F798A">ffff0200</span><span style="color:#999999">;</span><span style="color:#A0ADA0"> // arr and rz2</span><br><span style="color:#B07D48">	shadow</span><span style="color:#1e754f">[</span><span style="color:#2F798A">2</span><span style="color:#1e754f">]</span><span style="color:#999999"> =</span><span style="color:#AB5959"> 0x</span><span style="color:#2F798A">ffffffff</span><span style="color:#999999">;</span><span style="color:#A0ADA0"> // rz2</span><br><span style="color:#A0ADA0">	// un-poison all.</span><br><span style="color:#B07D48">	shadow</span><span style="color:#1e754f">[</span><span style="color:#2F798A">0</span><span style="color:#1e754f">]</span><span style="color:#999999"> =</span><span style="color:#B07D48"> shadow</span><span style="color:#1e754f">[</span><span style="color:#2F798A">1</span><span style="color:#1e754f">]</span><span style="color:#999999"> =</span><span style="color:#B07D48"> shadow</span><span style="color:#1e754f">[</span><span style="color:#2F798A">2</span><span style="color:#1e754f">]</span><span style="color:#999999"> =</span><span style="color:#2F798A"> 0</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br></code></pre></div>
<h3 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>准确性</a></h3>
<p>理论上，asan 不会产生 false positive（误报），但是会存在 false negative（遗漏），下面结合具体例子进行说明。</p>
<ul>
<li>首先，如果越界访问跳的特别远，越过了红区的话，那就测不出来；</li>
<li>其次，如果在“释放”和后续使用之间分配和释放了大量内存，导致最开始释放的 chunk 已经被复用了，则可能无法检测到 UAF。</li>
<li>再者，如果对于未对齐的字节进行读写，也可能导致测不出来，这个其实有办法解决，但是会导致快速路径变慢。</li>
</ul>
<h3 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>线程安全</a></h3>
<p>AddressSanitizer 是线程安全的。</p>
<p>仅当相应的应用程序内存不可访问时（在 <code class="inline-code">malloc</code> 或 <code class="inline-code">free</code> 期间、创建或销毁栈帧期间、模块初始化期间），影子内存才会被修改。对影子内存的所有其他访问都是读取，<code class="inline-code">malloc</code> 和 <code class="inline-code">free</code> 函数使用线程的本地缓存来避免每次调用时锁定（正如大多数现代 <code class="inline-code">malloc</code> 实现所做的那样）。如果原始程序在内存访问和删除内存之间存在竞争，AddressSanitizer 有时可能会将其检测为 UAF 错误，但不保证如此。</p>
<p>asan 会记录每个 <code class="inline-code">malloc</code> 和 <code class="inline-code">free</code> 的线程 ID，并与线程创建调用堆栈一起在错误消息中报告。</p>
<h2 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>总结</a></h2>
<p>传统观点认为，影子内存要么通过多级映射方案产生高开销，要么通过占用大的连续区域来施加过高的地址空间要求。这个新颖的阴影状态的算法充分减少了影子内存的空间占用，使我们可以使用简单的映射，并且可以以较低的开销实现需求。</p>
<h2 id="bypassing-addresssanitizer" class="scroll-target"><a href="#bypassing-addresssanitizer"><code class="hash inline-code">#</code>Bypassing AddressSanitizer</a></h2>
<p>显而易见的是，ASan 的检查很大一部分是基于影子内存中，此时影子内存的 k 值。假设如果全段影子内存的 k 全为0，我们就可以完全无视掉 ASan，而 2019 年 0ctf 的 babyaegis，正是给了一个写 0 的机会，给了我们一次对一个指针再次读写的机会。</p>
<p>另外，还有几种方法，例如</p>
<p>Adjacent Buffers in the Same Struct/Class:</p>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-c language-c"><span style="color:#999999">#</span><span style="color:#1E754F">include</span><span style="color:#B5695977"> &#x3C;</span><span style="color:#B56959">stdio.h</span><span style="color:#B5695977">></span><br><span style="color:#999999">#</span><span style="color:#1E754F">include</span><span style="color:#B5695977"> &#x3C;</span><span style="color:#B56959">stdlib.h</span><span style="color:#B5695977">></span><br><span style="color:#393A34">class Test</span><span style="color:#2993a3">{</span><br><span style="color:#393A34">public:</span><br><span style="color:#59873A">	Test</span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#1e754f">{</span><br><span style="color:#B07D48">		 command</span><span style="color:#a65e2b">[</span><span style="color:#2F798A">0</span><span style="color:#a65e2b">]</span><span style="color:#999999"> =</span><span style="color:#B5695977"> '</span><span style="color:#B56959">l</span><span style="color:#B5695977">'</span><span style="color:#999999">;</span><br><span style="color:#B07D48">		 command</span><span style="color:#a65e2b">[</span><span style="color:#2F798A">1</span><span style="color:#a65e2b">]</span><span style="color:#999999"> =</span><span style="color:#B5695977"> '</span><span style="color:#B56959">s</span><span style="color:#B5695977">'</span><span style="color:#999999">;</span><br><span style="color:#B07D48">		 command</span><span style="color:#a65e2b">[</span><span style="color:#2F798A">2</span><span style="color:#a65e2b">]</span><span style="color:#999999"> =</span><span style="color:#B5695977"> '</span><span style="color:#A65E2B">\0</span><span style="color:#B5695977">'</span><span style="color:#999999">;</span><br><span style="color:#999999">	</span><span style="color:#1e754f">}</span><br><span style="color:#AB5959">	void</span><span style="color:#59873A"> a</span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#1e754f">{</span><br><span style="color:#59873A">	 scanf</span><span style="color:#a65e2b">(</span><span style="color:#B5695977">"</span><span style="color:#A65E2B">%s</span><span style="color:#B5695977">"</span><span style="color:#999999">,</span><span style="color:#393A34"> buffer</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">	 system</span><span style="color:#a65e2b">(</span><span style="color:#393A34">command</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#999999">	</span><span style="color:#1e754f">}</span><br><span style="color:#393A34">private:</span><br><span style="color:#AB5959">	char</span><span style="color:#B07D48"> buffer</span><span style="color:#1e754f">[</span><span style="color:#2F798A">10</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	char</span><span style="color:#B07D48"> command</span><span style="color:#1e754f">[</span><span style="color:#2F798A">10</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><span style="color:#999999">;</span><br><span style="color:#AB5959">int</span><span style="color:#59873A"> main</span><span style="color:#2993a3">(</span><span style="color:#2993a3">)</span><span style="color:#2993a3">{</span><br><span style="color:#393A34">	Test aTest </span><span style="color:#999999">=</span><span style="color:#59873A"> Test</span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#B07D48">	aTest</span><span style="color:#999999">.</span><span style="color:#59873A">a</span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br></code></pre></div>
<div class="code-snippet"><pre class="code-snippet__pre"><code class="language-bash language-bash"><span style="color:#59873A">$</span><span style="color:#B56959"> g++</span><span style="color:#A65E2B"> -O</span><span style="color:#A65E2B"> -g</span><span style="color:#A65E2B"> -fsanitize=address</span><span style="color:#B56959"> test1.c</span><br><span style="color:#59873A">clang:</span><span style="color:#B56959"> warning:</span><span style="color:#B56959"> treating</span><span style="color:#B5695977"> '</span><span style="color:#B56959">c</span><span style="color:#B5695977">'</span><span style="color:#B56959"> input</span><span style="color:#B56959"> as</span><span style="color:#B5695977"> '</span><span style="color:#B56959">c++</span><span style="color:#B5695977">'</span><span style="color:#B56959"> when</span><span style="color:#B56959"> in</span><span style="color:#B56959"> C++</span><span style="color:#B56959"> mode,</span><span style="color:#B56959"> this</span><span style="color:#B56959"> behavior</span><span style="color:#B56959"> is</span><span style="color:#B56959"> deprecated</span><span style="color:#393A34"> </span><span style="color:#2993a3">[</span><span style="color:#393A34">-Wdeprecated</span><span style="color:#2993a3">]</span><br><br><span style="color:#59873A">$</span><span style="color:#B56959"> ./a.out</span><br><span style="color:#59873A">aaaaaaaaaa/bin/sh</span><span style="color:#999999">;</span><br><span style="color:#59873A">sh-3.2$</span><span style="color:#B56959"> id</span><br><span style="color:#B07D48">uid</span><span style="color:#999999">=</span><span style="color:#B56959">1000</span><span style="color:#2993a3">(</span><span style="color:#59873A">flower</span><span style="color:#2993a3">)</span><span style="color:#B07D48"> gid</span><span style="color:#999999">=</span><span style="color:#B56959">1000</span><span style="color:#2993a3">(</span><span style="color:#59873A">flower</span><span style="color:#2993a3">)</span><span style="color:#B56959"> 组=1000</span><span style="color:#2993a3">(</span><span style="color:#59873A">flower</span><span style="color:#2993a3">)</span><span style="color:#B56959">,950</span><span style="color:#2993a3">(</span><span style="color:#59873A">mihomo</span><span style="color:#2993a3">)</span><span style="color:#B56959">,986</span><span style="color:#2993a3">(</span><span style="color:#59873A">uucp</span><span style="color:#2993a3">)</span><span style="color:#B56959">,994</span><span style="color:#2993a3">(</span><span style="color:#59873A">input</span><span style="color:#2993a3">)</span><span style="color:#B56959">,998</span><span style="color:#2993a3">(</span><span style="color:#59873A">wheel</span><span style="color:#2993a3">)</span><br></code></pre></div>
<p>还可以参考文献：<a href="https://dl.packetstormsecurity.net/papers/general/BreakingAddressSanitizer.pdf" title="https://dl.packetstormsecurity.net/papers/general/BreakingAddressSanitizer.pdf" target="_blank" rel="noopener">Bypassing AddressSanitizer</a>.</p></div></div></div><footer class="footer"><div class="footer-row footer-links"><span class="footer-label">保持联系</span><a href="mailto:xzy1476569428@163.com" class="footer-link"><p><a href="mailto:xzy1476569428@163.com" title="mailto:xzy1476569428@163.com">xzy1476569428@163.com</a></p></a><span aria-hidden="true" class="footer-separator">·</span><a href="/rss.xml" class="footer-link">RSS</a><span aria-hidden="true" class="footer-separator">·</span><a href="https://github.com/LittFlower/my_blog" class="footer-link"><p>GitHub</p></a></div><div class="footer-row footer-meta"><span><p>本站基于
<a href="https://github.com/unvariant/blog">unvariant/blog</a>
改造，除特别说明外内容以 CC BY 4.0 协议共享。</p></span></div></footer></body></html>