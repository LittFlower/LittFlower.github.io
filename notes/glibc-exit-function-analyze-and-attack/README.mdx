<!DOCTYPE html>
<html id="_top" lang="zh-CN" data-theme="light"><head><script>(function () {
        const storageKey = "theme";
        const root = document.documentElement;
        const supportsMatchMedia = typeof window.matchMedia === "function";
        const mediaQuery = supportsMatchMedia
            ? window.matchMedia("(prefers-color-scheme: dark)")
            : null;

        const readStorage = () => {
            try {
                return window.localStorage.getItem(storageKey);
            } catch (error) {
                return null;
            }
        };

        const writeStorage = (value) => {
            try {
                window.localStorage.setItem(storageKey, value);
            } catch (error) {
                return;
            }
        };

        const applyTheme = (value) => {
            const theme = value === "dark" ? "dark" : "light";
            root.setAttribute("data-theme", theme);
            if (document.body) {
                document.body.setAttribute("data-theme", theme);
            } else {
                document.addEventListener(
                    "DOMContentLoaded",
                    () => {
                        if (document.body) {
                            document.body.setAttribute("data-theme", theme);
                        }
                    },
                    { once: true }
                );
            }
            return theme;
        };

        const updateButton = (value) => {
            const theme = value === "dark" ? "dark" : "light";
            const button = document.querySelector("[data-theme-toggle]");
            if (!button) {
                return;
            }
            const label = button.querySelector("[data-theme-toggle-label]");
            const isDark = theme === "dark";
            button.setAttribute("aria-pressed", isDark ? "true" : "false");
            button.setAttribute("title", isDark ? "切换为浅色主题" : "切换为深色主题");
            if (label) {
                label.textContent = isDark ? "深色" : "浅色";
            }
        };

        const stored = readStorage();
        const initial =
            stored === "light" || stored === "dark"
                ? stored
                : mediaQuery && mediaQuery.matches
                  ? "dark"
                  : "light";

        const appliedTheme = applyTheme(initial);
        updateButton(appliedTheme);

        window.__setTheme = (value) => {
            const theme = applyTheme(value);
            writeStorage(theme);
            updateButton(theme);
        };

        window.__toggleTheme = () => {
            const current =
                root.getAttribute("data-theme") === "dark" ? "dark" : "light";
            const next = current === "dark" ? "light" : "dark";
            const theme = applyTheme(next);
            writeStorage(theme);
            updateButton(theme);
        };

        const syncButtonState = () => {
            updateButton(root.getAttribute("data-theme"));
        };

        const attachToggle = () => {
            const button = document.querySelector("[data-theme-toggle]");
            if (!button || button.__themeToggleBound) {
                return;
            }
            button.__themeToggleBound = true;
            button.addEventListener("click", (event) => {
                event.preventDefault();
                if (typeof window.__toggleTheme === "function") {
                    window.__toggleTheme();
                }
            });
        };

        if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", () => {
                syncButtonState();
                attachToggle();
            });
        } else {
            syncButtonState();
            attachToggle();
        }

        const handleMediaChange = (event) => {
            const storedTheme = readStorage();
            if (storedTheme === "light" || storedTheme === "dark") {
                updateButton(storedTheme);
                return;
            }
            const next = event.matches ? "dark" : "light";
            const theme = applyTheme(next);
            updateButton(theme);
        };

        if (mediaQuery) {
            if (typeof mediaQuery.addEventListener === "function") {
                mediaQuery.addEventListener("change", handleMediaChange);
            } else if (typeof mediaQuery.addListener === "function") {
                mediaQuery.addListener(handleMediaChange);
            }
        }
    })();
    if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
            navigator.serviceWorker.register("/sw.js").catch(() => {});
        });
    }</script><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="color-scheme" content="light dark"/><meta name="language" content="zh-CN"/><title>Glibc Exit 函数分析与利用 | 花盆</title><meta name="author" content="LittFlower"/><meta property="og:title" content="Glibc Exit 函数分析与利用 | 花盆"/><meta property="og:site_name" content="花盆"/><meta property="og:locale" content="zh-CN"/><link rel="canonical" href="https://blog.littflower.top/notes/glibc-exit-function-analyze-and-attack/README.mdx"/><link rel="alternate" type="application/rss+xml" title="花盆" href="/rss.xml"/><link rel="stylesheet" href="/fonts.css" type="text/css" preload/><link rel="stylesheet" href="/style.css" type="text/css" preload/></head><body><div class="top-bar fullwidth"><div class="top-bar-inner fullwidth"><div class="top-bar-group"><a href="/" aria-label="root" class="file-link"><img src="/icons/dir.png" alt/><span>/</span></a><a href=".." aria-label="parent" class="file-link"><img src="/icons/dir.png" alt/><span>..</span></a></div><div class="top-bar-group"><h3><a href="#_content"><code class="hash inline-code">#</code>内容</a></h3><h3><a href="#_top"><code class="hash inline-code">#</code>回到顶部</a></h3><button type="button" data-theme-toggle="true" aria-label="切换亮暗主题" aria-pressed="false" title="切换主题" class="theme-toggle"><code aria-hidden="true" class="hash inline-code">#</code>  <span data-theme-toggle-label="true" class="theme-toggle-label">浅色</span></button></div></div></div><div class="page-shell"><div class="page-files"></div><div class="page-main"><div id="_content" style="scroll-margin-top:48px;" class="page-article"><h1 id="glibc-exit" class="scroll-target"><a href="#glibc-exit"><code class="hash inline-code">#</code>Glibc Exit 函数分析与利用</a></h1>
<h2 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>源码分析</a></h2>
<p>用的源码是 glibc 2.35 的，具体版本是 Ubuntu GLIBC 2.35-0ubuntu3.9，在 glibc all in one 里可以下载到。</p>
<p>调试信息我是用 docker 下载的，然后拷出来在我的 arch linux 上慢慢调试。</p>
<p><code class="inline-code">exit</code> 函数定义在 glibc 的 stdlib/exit.c 中，如下：</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#AB5959">void</span><br><span style="color:#59873A">exit</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">int</span><span style="color:#B07D48"> status</span><span style="color:#2993a3">)</span><br><span style="color:#2993a3">{</span><br><span style="color:#59873A">  __run_exit_handlers</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">status</span><span style="color:#999999">,</span><span style="color:#AB5959"> &#x26;</span><span style="color:#393A34">__exit_funcs</span><span style="color:#999999">,</span><span style="color:#1E754F"> true</span><span style="color:#999999">,</span><span style="color:#1E754F"> true</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br><span style="color:#59873A">libc_hidden_def</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">exit</span><span style="color:#2993a3">)</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#CB7676">void</span><br><span style="color:#80A665">exit</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#CB7676">int</span><span style="color:#BD976A"> status</span><span style="color:#5eaab5">)</span><br><span style="color:#5eaab5">{</span><br><span style="color:#80A665">  __run_exit_handlers</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">status</span><span style="color:#666666">,</span><span style="color:#CB7676"> &#x26;</span><span style="color:#DBD7CAEE">__exit_funcs</span><span style="color:#666666">,</span><span style="color:#4D9375"> true</span><span style="color:#666666">,</span><span style="color:#4D9375"> true</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#5eaab5">}</span><br><span style="color:#80A665">libc_hidden_def</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#DBD7CAEE">exit</span><span style="color:#5eaab5">)</span><br></code></pre></div>
<p>有一个很重要的结构 <code class="inline-code">__exit_funcs</code>，如下：</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#AB5959">enum</span><br><span style="color:#2993a3">{</span><br><span style="color:#393A34">  ef_free</span><span style="color:#999999">,</span><span style="color:#A0ADA0">	/* `ef_free' MUST be zero!  */</span><br><span style="color:#393A34">  ef_us</span><span style="color:#999999">,</span><br><span style="color:#393A34">  ef_on</span><span style="color:#999999">,</span><br><span style="color:#393A34">  ef_at</span><span style="color:#999999">,</span><br><span style="color:#393A34">  ef_cxa</span><br><span style="color:#2993a3">}</span><span style="color:#999999">;</span><br><br><span style="color:#AB5959">struct</span><span style="color:#393A34"> exit_function</span><span style="color:#A0ADA0">  // 析构函数的类型，可以是 {ef_free, ef_us, ef_on, ef_at, ef_cxa} 之一</span><br><span style="color:#999999">  </span><span style="color:#2993a3">{</span><span style="color:#A0ADA0">                   // ef_free 表示此位置空闲</span><br><span style="color:#A0ADA0">					  // ef_us 表示此位置被占用，但是不知道函数类型</span><br><span style="color:#A0ADA0">					  // ef_on ef_at ef_cxa 都表示了具体的函数类型，差别在参数上</span><br><span style="color:#A0ADA0">    /* `flavour' should be of type of the `enum' above but since we need</span><br><span style="color:#A0ADA0">       this element in an atomic operation we have to use `long int'.  */</span><br><span style="color:#AB5959">    long</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> flavor</span><span style="color:#999999">;</span><br><span style="color:#AB5959">    union</span><span style="color:#A0ADA0">             // 使用 union 声明结构</span><br><span style="color:#999999">      </span><span style="color:#1e754f">{</span><br><span style="color:#AB5959">	void</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">at</span><span style="color:#a65e2b">)</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#AB5959">void</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	struct</span><br><span style="color:#999999">	  </span><span style="color:#a65e2b">{</span><br><span style="color:#AB5959">	    void</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">fn</span><span style="color:#a13865">)</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#AB5959">int</span><span style="color:#393A34"> status</span><span style="color:#999999">,</span><span style="color:#AB5959"> void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	    void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#999999">;</span><br><span style="color:#999999">	  </span><span style="color:#a65e2b">}</span><span style="color:#393A34"> on</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	struct</span><br><span style="color:#999999">	  </span><span style="color:#a65e2b">{</span><br><span style="color:#AB5959">	    void</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">fn</span><span style="color:#a13865">)</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#999999">,</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> status</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	    void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	    void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">dso_handle</span><span style="color:#999999">;</span><br><span style="color:#999999">	  </span><span style="color:#a65e2b">}</span><span style="color:#393A34"> cxa</span><span style="color:#999999">;</span><br><span style="color:#999999">      </span><span style="color:#1e754f">}</span><span style="color:#393A34"> func</span><span style="color:#999999">;</span><br><span style="color:#999999">  </span><span style="color:#2993a3">}</span><span style="color:#999999">;</span><br><span style="color:#AB5959">struct</span><span style="color:#393A34"> exit_function_list</span><br><span style="color:#999999">  </span><span style="color:#2993a3">{</span><br><span style="color:#AB5959">    struct</span><span style="color:#393A34"> exit_function_list </span><span style="color:#AB5959">*</span><span style="color:#393A34">next</span><span style="color:#999999">;</span><span style="color:#A0ADA0"> // 单链表</span><br><span style="color:#AB5959">    size_t</span><span style="color:#393A34"> idx</span><span style="color:#999999">;</span><span style="color:#A0ADA0">                      // 记录当前节点有多少个析构函数</span><br><span style="color:#AB5959">    struct</span><span style="color:#393A34"> exit_function </span><span style="color:#B07D48">fns</span><span style="color:#1e754f">[</span><span style="color:#2F798A">32</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><span style="color:#A0ADA0">    // 析构函数数组</span><br><span style="color:#999999">  </span><span style="color:#2993a3">}</span><span style="color:#999999">;</span><br><br><span style="color:#AB5959">extern</span><span style="color:#AB5959"> struct</span><span style="color:#393A34"> exit_function_list </span><span style="color:#AB5959">*</span><span style="color:#393A34">__exit_funcs attribute_hidden</span><span style="color:#999999">;</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#CB7676">enum</span><br><span style="color:#5eaab5">{</span><br><span style="color:#DBD7CAEE">  ef_free</span><span style="color:#666666">,</span><span style="color:#758575DD">	/* `ef_free' MUST be zero!  */</span><br><span style="color:#DBD7CAEE">  ef_us</span><span style="color:#666666">,</span><br><span style="color:#DBD7CAEE">  ef_on</span><span style="color:#666666">,</span><br><span style="color:#DBD7CAEE">  ef_at</span><span style="color:#666666">,</span><br><span style="color:#DBD7CAEE">  ef_cxa</span><br><span style="color:#5eaab5">}</span><span style="color:#666666">;</span><br><br><span style="color:#CB7676">struct</span><span style="color:#DBD7CAEE"> exit_function</span><span style="color:#758575DD">  // 析构函数的类型，可以是 {ef_free, ef_us, ef_on, ef_at, ef_cxa} 之一</span><br><span style="color:#666666">  </span><span style="color:#5eaab5">{</span><span style="color:#758575DD">                   // ef_free 表示此位置空闲</span><br><span style="color:#758575DD">					  // ef_us 表示此位置被占用，但是不知道函数类型</span><br><span style="color:#758575DD">					  // ef_on ef_at ef_cxa 都表示了具体的函数类型，差别在参数上</span><br><span style="color:#758575DD">    /* `flavour' should be of type of the `enum' above but since we need</span><br><span style="color:#758575DD">       this element in an atomic operation we have to use `long int'.  */</span><br><span style="color:#CB7676">    long</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> flavor</span><span style="color:#666666">;</span><br><span style="color:#CB7676">    union</span><span style="color:#758575DD">             // 使用 union 声明结构</span><br><span style="color:#666666">      </span><span style="color:#4d9375">{</span><br><span style="color:#CB7676">	void</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">at</span><span style="color:#d4976c">)</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#CB7676">void</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	struct</span><br><span style="color:#666666">	  </span><span style="color:#d4976c">{</span><br><span style="color:#CB7676">	    void</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">fn</span><span style="color:#d9739f">)</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#CB7676">int</span><span style="color:#DBD7CAEE"> status</span><span style="color:#666666">,</span><span style="color:#CB7676"> void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	    void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#666666">;</span><br><span style="color:#666666">	  </span><span style="color:#d4976c">}</span><span style="color:#DBD7CAEE"> on</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	struct</span><br><span style="color:#666666">	  </span><span style="color:#d4976c">{</span><br><span style="color:#CB7676">	    void</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">fn</span><span style="color:#d9739f">)</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#666666">,</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> status</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	    void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	    void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">dso_handle</span><span style="color:#666666">;</span><br><span style="color:#666666">	  </span><span style="color:#d4976c">}</span><span style="color:#DBD7CAEE"> cxa</span><span style="color:#666666">;</span><br><span style="color:#666666">      </span><span style="color:#4d9375">}</span><span style="color:#DBD7CAEE"> func</span><span style="color:#666666">;</span><br><span style="color:#666666">  </span><span style="color:#5eaab5">}</span><span style="color:#666666">;</span><br><span style="color:#CB7676">struct</span><span style="color:#DBD7CAEE"> exit_function_list</span><br><span style="color:#666666">  </span><span style="color:#5eaab5">{</span><br><span style="color:#CB7676">    struct</span><span style="color:#DBD7CAEE"> exit_function_list </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">next</span><span style="color:#666666">;</span><span style="color:#758575DD"> // 单链表</span><br><span style="color:#CB7676">    size_t</span><span style="color:#DBD7CAEE"> idx</span><span style="color:#666666">;</span><span style="color:#758575DD">                      // 记录当前节点有多少个析构函数</span><br><span style="color:#CB7676">    struct</span><span style="color:#DBD7CAEE"> exit_function </span><span style="color:#BD976A">fns</span><span style="color:#4d9375">[</span><span style="color:#4C9A91">32</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><span style="color:#758575DD">    // 析构函数数组</span><br><span style="color:#666666">  </span><span style="color:#5eaab5">}</span><span style="color:#666666">;</span><br><br><span style="color:#CB7676">extern</span><span style="color:#CB7676"> struct</span><span style="color:#DBD7CAEE"> exit_function_list </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">__exit_funcs attribute_hidden</span><span style="color:#666666">;</span><br></code></pre></div>
<p><strong>总结</strong>：这里的 <code class="inline-code">__exit_funcs</code> 是一个单向链表，链表中每个节点都会注册若干个析构函数用来释放/回收资源。</p>
<p>剩下的看注释。</p>
<p>同时可以看到调用了 <code class="inline-code">__run_exit_handlers</code>，其中</p>
<p>跟进去看：</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#A0ADA0">/* Call all functions registered with `atexit' and `on_exit',</span><br><span style="color:#A0ADA0">   in the reverse of the order in which they were registered</span><br><span style="color:#A0ADA0">   perform stdio cleanup, and terminate program execution with STATUS.  */</span><br><span style="color:#A0ADA0">/* 上面这段注释的意思是，调用 atexit 和 on_exit 注册的函数，</span><br><span style="color:#A0ADA0">   调用顺序为注册时的逆序</span><br><span style="color:#A0ADA0">   最后会带着状态码终止程序执行                                              */</span><br><span style="color:#AB5959">void</span><br><span style="color:#393A34">attribute_hidden</span><br><span style="color:#59873A">__run_exit_handlers</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">int</span><span style="color:#B07D48"> status</span><span style="color:#999999">,</span><span style="color:#AB5959"> struct</span><span style="color:#393A34"> exit_function_list </span><span style="color:#AB5959">**</span><span style="color:#B07D48">listp</span><span style="color:#999999">,</span><br><span style="color:#AB5959">		     bool</span><span style="color:#B07D48"> run_list_atexit</span><span style="color:#999999">,</span><span style="color:#AB5959"> bool</span><span style="color:#B07D48"> run_dtors</span><span style="color:#2993a3">)</span><br><span style="color:#2993a3">{</span><br><span style="color:#A0ADA0">  /* First, call the TLS destructors.  */</span><br><span style="color:#A0ADA0">  /* 首先释放线程局部储存, 即 TLS \</span><br><span style="color:#A0ADA0">	 这里是一个攻击点                     */</span><br><br><span style="color:#999999">#</span><span style="color:#1E754F">ifndef</span><span style="color:#59873A"> SHARED</span><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">&#x26;</span><span style="color:#393A34">__call_tls_dtors </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#1e754f">)</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#1E754F">    if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">run_dtors</span><span style="color:#1e754f">)</span><br><span style="color:#59873A">      __call_tls_dtors</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#59873A">  __libc_lock_lock</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* We do it this way to handle recursive calls to exit () made by</span><br><span style="color:#A0ADA0">     the functions registered with `atexit' and `on_exit'. We call</span><br><span style="color:#A0ADA0">     everyone on the list and use the status value in the last</span><br><span style="color:#A0ADA0">     exit (). */</span><br><span style="color:#1E754F">  while</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1E754F">true</span><span style="color:#1e754f">)</span><br><span style="color:#999999">    </span><span style="color:#1e754f">{</span><br><span style="color:#AB5959">      struct</span><span style="color:#393A34"> exit_function_list </span><span style="color:#AB5959">*</span><span style="color:#393A34">cur</span><span style="color:#999999">;</span><br><br><span style="color:#393A34">    restart:</span><br><span style="color:#393A34">      cur </span><span style="color:#999999">=</span><span style="color:#AB5959"> *</span><span style="color:#393A34">listp</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 取出链表中的节点</span><br><br><span style="color:#1E754F">      if</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">cur </span><span style="color:#AB5959">==</span><span style="color:#1E754F"> NULL</span><span style="color:#a65e2b">)</span><br><span style="color:#999999">	</span><span style="color:#a65e2b">{</span><br><span style="color:#A0ADA0">	  /* Exit processing complete.  We will not allow any more</span><br><span style="color:#A0ADA0">	     atexit/on_exit registrations.  */</span><br><span style="color:#393A34">	  __exit_funcs_done </span><span style="color:#999999">=</span><span style="color:#1E754F"> true</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	  break</span><span style="color:#999999">;</span><br><span style="color:#999999">	</span><span style="color:#a65e2b">}</span><br><br><span style="color:#1E754F">      while</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#B07D48">cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">idx</span><span style="color:#AB5959"> </span><span style="color:#AB5959">></span><span style="color:#2F798A"> 0</span><span style="color:#a65e2b">)</span><span style="color:#A0ADA0">  // 如果该节点有注册的函数，那么遍历取出</span><br><span style="color:#999999">	</span><span style="color:#a65e2b">{</span><br><span style="color:#AB5959">	  struct</span><span style="color:#393A34"> exit_function </span><span style="color:#AB5959">*const</span><span style="color:#393A34"> f </span><span style="color:#999999">=</span><span style="color:#AB5959"> &#x26;</span><span style="color:#B07D48">cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">fns</span><span style="color:#a13865">[</span><span style="color:#AB5959">--</span><span style="color:#B07D48">cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">idx</span><span style="color:#a13865">]</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 取出</span><br><span style="color:#AB5959">	  const</span><span style="color:#AB5959"> uint64_t</span><span style="color:#393A34"> new_exitfn_called </span><span style="color:#999999">=</span><span style="color:#393A34"> __new_exitfn_called</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">	  switch</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#B07D48">f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">flavor</span><span style="color:#a13865">)</span><br><span style="color:#999999">	    </span><span style="color:#a13865">{</span><br><span style="color:#AB5959">	      void</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">atfct</span><span style="color:#bda437">)</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#AB5959">void</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	      void</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">onfct</span><span style="color:#bda437">)</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#AB5959">int</span><span style="color:#393A34"> status</span><span style="color:#999999">,</span><span style="color:#AB5959"> void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	      void</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">cxafct</span><span style="color:#bda437">)</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#999999">,</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> status</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	      void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">arg</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">	    case</span><span style="color:#393A34"> ef_free</span><span style="color:#999999">:</span><span style="color:#A0ADA0">  // 如果注册的函数是 ef_free ef_us，不执行</span><br><span style="color:#1E754F">	    case</span><span style="color:#393A34"> ef_us</span><span style="color:#999999">:</span><br><span style="color:#1E754F">	      break</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	    case</span><span style="color:#393A34"> ef_on</span><span style="color:#999999">:</span><br><span style="color:#393A34">	      onfct </span><span style="color:#999999">=</span><span style="color:#B07D48"> f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">func</span><span style="color:#999999">.</span><span style="color:#B07D48">on</span><span style="color:#393A34">.</span><span style="color:#B07D48">fn</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 取出函数指针</span><br><span style="color:#393A34">	      arg </span><span style="color:#999999">=</span><span style="color:#B07D48"> f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">func</span><span style="color:#999999">.</span><span style="color:#B07D48">on</span><span style="color:#393A34">.</span><span style="color:#B07D48">arg</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> PTR_DEMANGLE</span><br><span style="color:#59873A">	      PTR_DEMANGLE</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">onfct</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#A0ADA0">	      /* Unlock the list while we call a foreign function.  */</span><br><span style="color:#59873A">	      __libc_lock_unlock</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">	      onfct</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">status</span><span style="color:#999999">,</span><span style="color:#393A34"> arg</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 调用</span><br><span style="color:#59873A">	      __libc_lock_lock</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	      break</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	    case</span><span style="color:#393A34"> ef_at</span><span style="color:#999999">:</span><br><span style="color:#393A34">	      atfct </span><span style="color:#999999">=</span><span style="color:#B07D48"> f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">func</span><span style="color:#999999">.</span><span style="color:#B07D48">at</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 取出函数指针</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> PTR_DEMANGLE</span><br><span style="color:#59873A">	      PTR_DEMANGLE</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">atfct</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#A0ADA0">	      /* Unlock the list while we call a foreign function.  */</span><br><span style="color:#59873A">	      __libc_lock_unlock</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">	      atfct</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 调用</span><br><span style="color:#59873A">	      __libc_lock_lock</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	      break</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	    case</span><span style="color:#393A34"> ef_cxa</span><span style="color:#999999">:</span><br><span style="color:#A0ADA0">	      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span><br><span style="color:#A0ADA0">		 we must mark this function as ef_free.  */</span><br><span style="color:#B07D48">	      f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">flavor</span><span style="color:#999999"> =</span><span style="color:#393A34"> ef_free</span><span style="color:#999999">;</span><br><span style="color:#393A34">	      cxafct </span><span style="color:#999999">=</span><span style="color:#B07D48"> f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">func</span><span style="color:#999999">.</span><span style="color:#B07D48">cxa</span><span style="color:#393A34">.</span><span style="color:#B07D48">fn</span><span style="color:#999999">;</span><br><span style="color:#393A34">	      arg </span><span style="color:#999999">=</span><span style="color:#B07D48"> f</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">func</span><span style="color:#999999">.</span><span style="color:#B07D48">cxa</span><span style="color:#393A34">.</span><span style="color:#B07D48">arg</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> PTR_DEMANGLE</span><br><span style="color:#59873A">	      PTR_DEMANGLE</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">cxafct</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#A0ADA0">	      /* Unlock the list while we call a foreign function.  */</span><br><span style="color:#59873A">	      __libc_lock_unlock</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">	      cxafct</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">arg</span><span style="color:#999999">,</span><span style="color:#393A34"> status</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 调用</span><br><span style="color:#59873A">	      __libc_lock_lock</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	      break</span><span style="color:#999999">;</span><br><span style="color:#999999">	    </span><span style="color:#a13865">}</span><br><br><span style="color:#1E754F">	  if</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#59873A">__glibc_unlikely</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">new_exitfn_called </span><span style="color:#AB5959">!=</span><span style="color:#393A34"> __new_exitfn_called</span><span style="color:#bda437">)</span><span style="color:#a13865">)</span><br><span style="color:#A0ADA0">	    /* The last exit function, or another thread, has registered</span><br><span style="color:#A0ADA0">	       more exit functions.  Start the loop over.  */</span><br><span style="color:#1E754F">	    goto</span><span style="color:#393A34"> restart</span><span style="color:#999999">;</span><br><span style="color:#999999">	</span><span style="color:#a65e2b">}</span><br><br><span style="color:#AB5959">      *</span><span style="color:#393A34">listp </span><span style="color:#999999">=</span><span style="color:#B07D48"> cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">next</span><span style="color:#999999">;</span><br><span style="color:#1E754F">      if</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">listp </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#a65e2b">)</span><br><span style="color:#A0ADA0">	/* Don't free the last element in the chain, this is the statically</span><br><span style="color:#A0ADA0">	   allocate element.  */</span><br><span style="color:#A0ADA0">	/* 上面这段注释的意思是，最后一个链表节点为 libc .data 段中的 initial，不需要释放</span><br><span style="color:#A0ADA0">	   除此以外的节点都是malloc申请得到的, 所以需要释放  */</span><br><span style="color:#59873A">	free</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">cur</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#999999">    </span><span style="color:#1e754f">}</span><br><br><span style="color:#59873A">  __libc_lock_unlock</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">__exit_funcs_lock</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">run_list_atexit</span><span style="color:#1e754f">)</span><span style="color:#A0ADA0">  // 调用 _atexit</span><br><span style="color:#59873A">    RUN_HOOK</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">__libc_atexit</span><span style="color:#999999">,</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#59873A">  _exit</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">status</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#758575DD">/* Call all functions registered with `atexit' and `on_exit',</span><br><span style="color:#758575DD">   in the reverse of the order in which they were registered</span><br><span style="color:#758575DD">   perform stdio cleanup, and terminate program execution with STATUS.  */</span><br><span style="color:#758575DD">/* 上面这段注释的意思是，调用 atexit 和 on_exit 注册的函数，</span><br><span style="color:#758575DD">   调用顺序为注册时的逆序</span><br><span style="color:#758575DD">   最后会带着状态码终止程序执行                                              */</span><br><span style="color:#CB7676">void</span><br><span style="color:#DBD7CAEE">attribute_hidden</span><br><span style="color:#80A665">__run_exit_handlers</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#CB7676">int</span><span style="color:#BD976A"> status</span><span style="color:#666666">,</span><span style="color:#CB7676"> struct</span><span style="color:#DBD7CAEE"> exit_function_list </span><span style="color:#CB7676">**</span><span style="color:#BD976A">listp</span><span style="color:#666666">,</span><br><span style="color:#CB7676">		     bool</span><span style="color:#BD976A"> run_list_atexit</span><span style="color:#666666">,</span><span style="color:#CB7676"> bool</span><span style="color:#BD976A"> run_dtors</span><span style="color:#5eaab5">)</span><br><span style="color:#5eaab5">{</span><br><span style="color:#758575DD">  /* First, call the TLS destructors.  */</span><br><span style="color:#758575DD">  /* 首先释放线程局部储存, 即 TLS \</span><br><span style="color:#758575DD">	 这里是一个攻击点                     */</span><br><br><span style="color:#666666">#</span><span style="color:#4D9375">ifndef</span><span style="color:#80A665"> SHARED</span><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">&#x26;</span><span style="color:#DBD7CAEE">__call_tls_dtors </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#4d9375">)</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#4D9375">    if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">run_dtors</span><span style="color:#4d9375">)</span><br><span style="color:#80A665">      __call_tls_dtors</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#80A665">  __libc_lock_lock</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* We do it this way to handle recursive calls to exit () made by</span><br><span style="color:#758575DD">     the functions registered with `atexit' and `on_exit'. We call</span><br><span style="color:#758575DD">     everyone on the list and use the status value in the last</span><br><span style="color:#758575DD">     exit (). */</span><br><span style="color:#4D9375">  while</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4D9375">true</span><span style="color:#4d9375">)</span><br><span style="color:#666666">    </span><span style="color:#4d9375">{</span><br><span style="color:#CB7676">      struct</span><span style="color:#DBD7CAEE"> exit_function_list </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">cur</span><span style="color:#666666">;</span><br><br><span style="color:#DBD7CAEE">    restart:</span><br><span style="color:#DBD7CAEE">      cur </span><span style="color:#666666">=</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">listp</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 取出链表中的节点</span><br><br><span style="color:#4D9375">      if</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">cur </span><span style="color:#CB7676">==</span><span style="color:#4D9375"> NULL</span><span style="color:#d4976c">)</span><br><span style="color:#666666">	</span><span style="color:#d4976c">{</span><br><span style="color:#758575DD">	  /* Exit processing complete.  We will not allow any more</span><br><span style="color:#758575DD">	     atexit/on_exit registrations.  */</span><br><span style="color:#DBD7CAEE">	  __exit_funcs_done </span><span style="color:#666666">=</span><span style="color:#4D9375"> true</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	  break</span><span style="color:#666666">;</span><br><span style="color:#666666">	</span><span style="color:#d4976c">}</span><br><br><span style="color:#4D9375">      while</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#BD976A">cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">idx</span><span style="color:#CB7676"> </span><span style="color:#CB7676">></span><span style="color:#4C9A91"> 0</span><span style="color:#d4976c">)</span><span style="color:#758575DD">  // 如果该节点有注册的函数，那么遍历取出</span><br><span style="color:#666666">	</span><span style="color:#d4976c">{</span><br><span style="color:#CB7676">	  struct</span><span style="color:#DBD7CAEE"> exit_function </span><span style="color:#CB7676">*const</span><span style="color:#DBD7CAEE"> f </span><span style="color:#666666">=</span><span style="color:#CB7676"> &#x26;</span><span style="color:#BD976A">cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">fns</span><span style="color:#d9739f">[</span><span style="color:#CB7676">--</span><span style="color:#BD976A">cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">idx</span><span style="color:#d9739f">]</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 取出</span><br><span style="color:#CB7676">	  const</span><span style="color:#CB7676"> uint64_t</span><span style="color:#DBD7CAEE"> new_exitfn_called </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> __new_exitfn_called</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">	  switch</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#BD976A">f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">flavor</span><span style="color:#d9739f">)</span><br><span style="color:#666666">	    </span><span style="color:#d9739f">{</span><br><span style="color:#CB7676">	      void</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">atfct</span><span style="color:#e6cc77">)</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#CB7676">void</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	      void</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">onfct</span><span style="color:#e6cc77">)</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#CB7676">int</span><span style="color:#DBD7CAEE"> status</span><span style="color:#666666">,</span><span style="color:#CB7676"> void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	      void</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">cxafct</span><span style="color:#e6cc77">)</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#666666">,</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> status</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	      void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">arg</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">	    case</span><span style="color:#DBD7CAEE"> ef_free</span><span style="color:#666666">:</span><span style="color:#758575DD">  // 如果注册的函数是 ef_free ef_us，不执行</span><br><span style="color:#4D9375">	    case</span><span style="color:#DBD7CAEE"> ef_us</span><span style="color:#666666">:</span><br><span style="color:#4D9375">	      break</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	    case</span><span style="color:#DBD7CAEE"> ef_on</span><span style="color:#666666">:</span><br><span style="color:#DBD7CAEE">	      onfct </span><span style="color:#666666">=</span><span style="color:#BD976A"> f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">func</span><span style="color:#666666">.</span><span style="color:#BD976A">on</span><span style="color:#DBD7CAEE">.</span><span style="color:#BD976A">fn</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 取出函数指针</span><br><span style="color:#DBD7CAEE">	      arg </span><span style="color:#666666">=</span><span style="color:#BD976A"> f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">func</span><span style="color:#666666">.</span><span style="color:#BD976A">on</span><span style="color:#DBD7CAEE">.</span><span style="color:#BD976A">arg</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> PTR_DEMANGLE</span><br><span style="color:#80A665">	      PTR_DEMANGLE</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">onfct</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#758575DD">	      /* Unlock the list while we call a foreign function.  */</span><br><span style="color:#80A665">	      __libc_lock_unlock</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#80A665">	      onfct</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">status</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> arg</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 调用</span><br><span style="color:#80A665">	      __libc_lock_lock</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	      break</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	    case</span><span style="color:#DBD7CAEE"> ef_at</span><span style="color:#666666">:</span><br><span style="color:#DBD7CAEE">	      atfct </span><span style="color:#666666">=</span><span style="color:#BD976A"> f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">func</span><span style="color:#666666">.</span><span style="color:#BD976A">at</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 取出函数指针</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> PTR_DEMANGLE</span><br><span style="color:#80A665">	      PTR_DEMANGLE</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">atfct</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#758575DD">	      /* Unlock the list while we call a foreign function.  */</span><br><span style="color:#80A665">	      __libc_lock_unlock</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#80A665">	      atfct</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 调用</span><br><span style="color:#80A665">	      __libc_lock_lock</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	      break</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	    case</span><span style="color:#DBD7CAEE"> ef_cxa</span><span style="color:#666666">:</span><br><span style="color:#758575DD">	      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span><br><span style="color:#758575DD">		 we must mark this function as ef_free.  */</span><br><span style="color:#BD976A">	      f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">flavor</span><span style="color:#666666"> =</span><span style="color:#DBD7CAEE"> ef_free</span><span style="color:#666666">;</span><br><span style="color:#DBD7CAEE">	      cxafct </span><span style="color:#666666">=</span><span style="color:#BD976A"> f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">func</span><span style="color:#666666">.</span><span style="color:#BD976A">cxa</span><span style="color:#DBD7CAEE">.</span><span style="color:#BD976A">fn</span><span style="color:#666666">;</span><br><span style="color:#DBD7CAEE">	      arg </span><span style="color:#666666">=</span><span style="color:#BD976A"> f</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">func</span><span style="color:#666666">.</span><span style="color:#BD976A">cxa</span><span style="color:#DBD7CAEE">.</span><span style="color:#BD976A">arg</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> PTR_DEMANGLE</span><br><span style="color:#80A665">	      PTR_DEMANGLE</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">cxafct</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#758575DD">	      /* Unlock the list while we call a foreign function.  */</span><br><span style="color:#80A665">	      __libc_lock_unlock</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#80A665">	      cxafct</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">arg</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> status</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 调用</span><br><span style="color:#80A665">	      __libc_lock_lock</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	      break</span><span style="color:#666666">;</span><br><span style="color:#666666">	    </span><span style="color:#d9739f">}</span><br><br><span style="color:#4D9375">	  if</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#80A665">__glibc_unlikely</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">new_exitfn_called </span><span style="color:#CB7676">!=</span><span style="color:#DBD7CAEE"> __new_exitfn_called</span><span style="color:#e6cc77">)</span><span style="color:#d9739f">)</span><br><span style="color:#758575DD">	    /* The last exit function, or another thread, has registered</span><br><span style="color:#758575DD">	       more exit functions.  Start the loop over.  */</span><br><span style="color:#4D9375">	    goto</span><span style="color:#DBD7CAEE"> restart</span><span style="color:#666666">;</span><br><span style="color:#666666">	</span><span style="color:#d4976c">}</span><br><br><span style="color:#CB7676">      *</span><span style="color:#DBD7CAEE">listp </span><span style="color:#666666">=</span><span style="color:#BD976A"> cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">next</span><span style="color:#666666">;</span><br><span style="color:#4D9375">      if</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">listp </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#d4976c">)</span><br><span style="color:#758575DD">	/* Don't free the last element in the chain, this is the statically</span><br><span style="color:#758575DD">	   allocate element.  */</span><br><span style="color:#758575DD">	/* 上面这段注释的意思是，最后一个链表节点为 libc .data 段中的 initial，不需要释放</span><br><span style="color:#758575DD">	   除此以外的节点都是malloc申请得到的, 所以需要释放  */</span><br><span style="color:#80A665">	free</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">cur</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#666666">    </span><span style="color:#4d9375">}</span><br><br><span style="color:#80A665">  __libc_lock_unlock</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">__exit_funcs_lock</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">run_list_atexit</span><span style="color:#4d9375">)</span><span style="color:#758575DD">  // 调用 _atexit</span><br><span style="color:#80A665">    RUN_HOOK</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">__libc_atexit</span><span style="color:#666666">,</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#80A665">  _exit</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">status</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#5eaab5">}</span><br></code></pre></div>
<p>比如一个比较简单的程序，在 exit 释放资源时，调用 <code class="inline-code">__run_exit_handlers</code> 如下：</p>
<p><img src="https://pic1.imgdb.cn/item/67dbb71388c538a9b5c1a060.png" alt/></p>
<p>这里比较明显的看到 <code class="inline-code">__exit_funcs</code> 里只有一个 <code class="inline-code">initial</code>，它就在 libc 里。</p>
<h3 id="__exit_funcs" class="scroll-target"><a href="#__exit_funcs"><code class="hash inline-code">#</code><code class="inline-code">__exit_funcs</code> 里有什么</a></h3>
<p>比较显然的是这些函数都是在 main 运行前注册的，那么就要去思考，elf 程序是如何启动的（这里可以自行去看 ctfwiki）？</p>
<p>（假设读者已经看完了）所以 <code class="inline-code">__exit_funcs</code> 里的析构函数应该都是通过 <code class="inline-code">__libc_start_main</code> 注册的。</p>
<p>看一下 <code class="inline-code">__libc_start_main</code>:</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#A0ADA0">/* Note: The init and fini parameters are no longer used.  fini is</span><br><span style="color:#A0ADA0">   completely unused, init is still called if not NULL, but the</span><br><span style="color:#A0ADA0">   current startup code always passes NULL.  (In the future, it would</span><br><span style="color:#A0ADA0">   be possible to use fini to pass a version code if init is NULL, to</span><br><span style="color:#A0ADA0">   indicate the link-time glibc without introducing a hard</span><br><span style="color:#A0ADA0">   incompatibility for new programs with older glibc versions.)</span><br><br><span style="color:#A0ADA0">   For dynamically linked executables, the dynamic segment is used to</span><br><span style="color:#A0ADA0">   locate constructors and destructors.  For statically linked</span><br><span style="color:#A0ADA0">   executables, the relevant symbols are access directly.  */</span><br><br><span style="color:#A0ADA0">/* 上面这段注释的意思是，`init` 参数和 `fini` 参数都已经弃用了 */</span><br><span style="color:#393A34">STATIC </span><span style="color:#AB5959">int</span><br><span style="color:#59873A">LIBC_START_MAIN</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">int</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">main</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">int</span><span style="color:#999999">,</span><span style="color:#AB5959"> char</span><span style="color:#AB5959"> **</span><span style="color:#999999">,</span><span style="color:#AB5959"> char</span><span style="color:#AB5959"> **</span><span style="color:#393A34"> MAIN_AUXVEC_DECL</span><span style="color:#1e754f">)</span><span style="color:#999999">,</span><br><span style="color:#AB5959">		 int</span><span style="color:#B07D48"> argc</span><span style="color:#999999">,</span><span style="color:#AB5959"> char</span><span style="color:#AB5959"> **</span><span style="color:#B07D48">argv</span><span style="color:#999999">,</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> LIBC_START_MAIN_AUXVEC_ARG</span><br><span style="color:#59873A">		 ElfW</span><span style="color:#1e754f">(</span><span style="color:#998418">auxv_t</span><span style="color:#1e754f">)</span><span style="color:#AB5959"> *</span><span style="color:#393A34">auxvec</span><span style="color:#999999">,</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#59873A">		 __typeof</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">main</span><span style="color:#1e754f">)</span><span style="color:#B07D48"> init</span><span style="color:#999999">,</span><br><span style="color:#AB5959">		 void</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">fini</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">void</span><span style="color:#1e754f">)</span><span style="color:#999999">,</span><br><span style="color:#AB5959">		 void</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">rtld_fini</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#AB5959">void</span><span style="color:#1e754f">)</span><span style="color:#999999">,</span><span style="color:#AB5959"> void</span><span style="color:#AB5959"> *</span><span style="color:#B07D48">stack_end</span><span style="color:#2993a3">)</span><br><span style="color:#2993a3">{</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifndef</span><span style="color:#59873A"> SHARED</span><br><span style="color:#AB5959">  char</span><span style="color:#AB5959"> **</span><span style="color:#393A34">ev </span><span style="color:#999999">=</span><span style="color:#AB5959"> &#x26;</span><span style="color:#B07D48">argv</span><span style="color:#1e754f">[</span><span style="color:#393A34">argc </span><span style="color:#AB5959">+</span><span style="color:#2F798A"> 1</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><br><span style="color:#393A34">  __environ </span><span style="color:#999999">=</span><span style="color:#393A34"> ev</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* Store the lowest stack address.  This is done in ld.so if this is</span><br><span style="color:#A0ADA0">     the code for the DSO.  */</span><br><span style="color:#393A34">  __libc_stack_end </span><span style="color:#999999">=</span><span style="color:#393A34"> stack_end</span><span style="color:#999999">;</span><br><br><span style="color:#393A34">  ...</span><br><br><span style="color:#A0ADA0">  /* Do static pie self relocation after tunables and cpu features</span><br><span style="color:#A0ADA0">     are setup for ifunc resolvers. Before this point relocations</span><br><span style="color:#A0ADA0">     must be avoided.  */</span><br><span style="color:#59873A">  _dl_relocate_static_pie</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* Perform IREL{,A} relocations.  */</span><br><span style="color:#59873A">  ARCH_SETUP_IREL</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* The stack guard goes into the TCB, so initialize it early.  */</span><br><span style="color:#59873A">  ARCH_SETUP_TLS</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* In some architectures, IREL{,A} relocations happen after TLS setup in</span><br><span style="color:#A0ADA0">     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc's</span><br><span style="color:#A0ADA0">     hwcap and platform fields available in the TCB.  */</span><br><span style="color:#59873A">  ARCH_APPLY_IREL</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* Set up the stack checker's canary.  */</span><br><span style="color:#AB5959">  uintptr_t</span><span style="color:#393A34"> stack_chk_guard </span><span style="color:#999999">=</span><span style="color:#59873A"> _dl_setup_stack_chk_guard</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">_dl_random</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F"> ifdef</span><span style="color:#59873A"> THREAD_SET_STACK_GUARD</span><br><span style="color:#59873A">  THREAD_SET_STACK_GUARD</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">stack_chk_guard</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F"> else</span><br><span style="color:#393A34">  __stack_chk_guard </span><span style="color:#999999">=</span><span style="color:#393A34"> stack_chk_guard</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F"> endif</span><br><br><span style="color:#393A34">  ...</span><br><br><span style="color:#A0ADA0">  /* Set up the pointer guard value.  */</span><br><span style="color:#AB5959">  uintptr_t</span><span style="color:#393A34"> pointer_chk_guard </span><span style="color:#999999">=</span><span style="color:#59873A"> _dl_setup_pointer_guard</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">_dl_random</span><span style="color:#999999">,</span><br><span style="color:#393A34">							 stack_chk_guard</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F"> ifdef</span><span style="color:#59873A"> THREAD_SET_POINTER_GUARD</span><br><span style="color:#59873A">  THREAD_SET_POINTER_GUARD</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">pointer_chk_guard</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F"> else</span><br><span style="color:#393A34">  __pointer_chk_guard_local </span><span style="color:#999999">=</span><span style="color:#393A34"> pointer_chk_guard</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F"> endif</span><br><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><span style="color:#A0ADA0"> /* !SHARED  */</span><br><br><span style="color:#A0ADA0">  /* Register the destructor of the dynamic linker if there is any.  */</span><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#59873A">__glibc_likely</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">rtld_fini </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><br><span style="color:#59873A">    __cxa_atexit</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#a65e2b">(</span><span style="color:#AB5959">void</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#AB5959">*</span><span style="color:#a13865">)</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#a13865">)</span><span style="color:#a65e2b">)</span><span style="color:#393A34"> rtld_fini</span><span style="color:#999999">,</span><span style="color:#1E754F"> NULL</span><span style="color:#999999">,</span><span style="color:#1E754F"> NULL</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 重点看这里</span><br><br><span style="color:#393A34">  ...</span><br><br><span style="color:#A0ADA0">  /* Register the destructor of the statically-linked program.  */</span><br><span style="color:#59873A">  __cxa_atexit</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">call_fini</span><span style="color:#999999">,</span><span style="color:#1E754F"> NULL</span><span style="color:#999999">,</span><span style="color:#1E754F"> NULL</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#393A34">  ...</span><br><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">init </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#1e754f">)</span><br><span style="color:#A0ADA0">    /* This is a legacy program which supplied its own init</span><br><span style="color:#A0ADA0">       routine.  */</span><br><span style="color:#999999">    </span><span style="color:#1e754f">(</span><span style="color:#AB5959">*</span><span style="color:#393A34">init</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">argc</span><span style="color:#999999">,</span><span style="color:#393A34"> argv</span><span style="color:#999999">,</span><span style="color:#393A34"> __environ MAIN_AUXVEC_PARAM</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 注意这里，`init` 如果有的话也会调用</span><br><span style="color:#1E754F">  else</span><br><span style="color:#A0ADA0">    /* This is a current program.  Use the dynamic segment to find</span><br><span style="color:#A0ADA0">       constructors.  */</span><br><span style="color:#59873A">    call_init</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">argc</span><span style="color:#999999">,</span><span style="color:#393A34"> argv</span><span style="color:#999999">,</span><span style="color:#393A34"> __environ</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* Auditing checkpoint: we have a new object.  */</span><br><span style="color:#59873A">  _dl_audit_preinit</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#59873A">GL</span><span style="color:#a65e2b">(</span><span style="color:#393A34">dl_ns</span><span style="color:#a65e2b">)</span><span style="color:#a65e2b">[</span><span style="color:#393A34">LM_ID_BASE</span><span style="color:#a65e2b">]</span><span style="color:#999999">.</span><span style="color:#B07D48">_ns_loaded</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#59873A">__glibc_unlikely</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#59873A">GLRO</span><span style="color:#a13865">(</span><span style="color:#393A34">dl_debug_mask</span><span style="color:#a13865">)</span><span style="color:#AB5959"> &#x26;</span><span style="color:#393A34"> DL_DEBUG_IMPCALLS</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><br><span style="color:#59873A">    GLRO</span><span style="color:#1e754f">(</span><span style="color:#393A34">dl_debug_printf</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#B5695977">"</span><span style="color:#A65E2B">\n</span><span style="color:#B56959">transferring control: </span><span style="color:#A65E2B">%s\n\n</span><span style="color:#B5695977">"</span><span style="color:#999999">,</span><span style="color:#B07D48"> argv</span><span style="color:#a65e2b">[</span><span style="color:#2F798A">0</span><span style="color:#a65e2b">]</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#B31D28;font-style:italic">#else</span><span style="color:#A0ADA0"> /* !SHARED */</span><br><span style="color:#59873A">  call_init</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">argc</span><span style="color:#999999">,</span><span style="color:#393A34"> argv</span><span style="color:#999999">,</span><span style="color:#393A34"> __environ</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#59873A">  _dl_debug_initialize</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#2F798A">0</span><span style="color:#999999">,</span><span style="color:#393A34"> LM_ID_BASE</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#B31D28;font-style:italic">#endif</span><br><br><span style="color:#59873A">  __libc_start_call_main</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">main</span><span style="color:#999999">,</span><span style="color:#393A34"> argc</span><span style="color:#999999">,</span><span style="color:#393A34"> argv </span><span style="color:#B07D48">MAIN_AUXVEC_PARAM</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#758575DD">/* Note: The init and fini parameters are no longer used.  fini is</span><br><span style="color:#758575DD">   completely unused, init is still called if not NULL, but the</span><br><span style="color:#758575DD">   current startup code always passes NULL.  (In the future, it would</span><br><span style="color:#758575DD">   be possible to use fini to pass a version code if init is NULL, to</span><br><span style="color:#758575DD">   indicate the link-time glibc without introducing a hard</span><br><span style="color:#758575DD">   incompatibility for new programs with older glibc versions.)</span><br><br><span style="color:#758575DD">   For dynamically linked executables, the dynamic segment is used to</span><br><span style="color:#758575DD">   locate constructors and destructors.  For statically linked</span><br><span style="color:#758575DD">   executables, the relevant symbols are access directly.  */</span><br><br><span style="color:#758575DD">/* 上面这段注释的意思是，`init` 参数和 `fini` 参数都已经弃用了 */</span><br><span style="color:#DBD7CAEE">STATIC </span><span style="color:#CB7676">int</span><br><span style="color:#80A665">LIBC_START_MAIN</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#CB7676">int</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">main</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">int</span><span style="color:#666666">,</span><span style="color:#CB7676"> char</span><span style="color:#CB7676"> **</span><span style="color:#666666">,</span><span style="color:#CB7676"> char</span><span style="color:#CB7676"> **</span><span style="color:#DBD7CAEE"> MAIN_AUXVEC_DECL</span><span style="color:#4d9375">)</span><span style="color:#666666">,</span><br><span style="color:#CB7676">		 int</span><span style="color:#BD976A"> argc</span><span style="color:#666666">,</span><span style="color:#CB7676"> char</span><span style="color:#CB7676"> **</span><span style="color:#BD976A">argv</span><span style="color:#666666">,</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> LIBC_START_MAIN_AUXVEC_ARG</span><br><span style="color:#80A665">		 ElfW</span><span style="color:#4d9375">(</span><span style="color:#B8A965">auxv_t</span><span style="color:#4d9375">)</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">auxvec</span><span style="color:#666666">,</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#80A665">		 __typeof</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">main</span><span style="color:#4d9375">)</span><span style="color:#BD976A"> init</span><span style="color:#666666">,</span><br><span style="color:#CB7676">		 void</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">fini</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">void</span><span style="color:#4d9375">)</span><span style="color:#666666">,</span><br><span style="color:#CB7676">		 void</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">rtld_fini</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#CB7676">void</span><span style="color:#4d9375">)</span><span style="color:#666666">,</span><span style="color:#CB7676"> void</span><span style="color:#CB7676"> *</span><span style="color:#BD976A">stack_end</span><span style="color:#5eaab5">)</span><br><span style="color:#5eaab5">{</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifndef</span><span style="color:#80A665"> SHARED</span><br><span style="color:#CB7676">  char</span><span style="color:#CB7676"> **</span><span style="color:#DBD7CAEE">ev </span><span style="color:#666666">=</span><span style="color:#CB7676"> &#x26;</span><span style="color:#BD976A">argv</span><span style="color:#4d9375">[</span><span style="color:#DBD7CAEE">argc </span><span style="color:#CB7676">+</span><span style="color:#4C9A91"> 1</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><br><br><span style="color:#DBD7CAEE">  __environ </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> ev</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* Store the lowest stack address.  This is done in ld.so if this is</span><br><span style="color:#758575DD">     the code for the DSO.  */</span><br><span style="color:#DBD7CAEE">  __libc_stack_end </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> stack_end</span><span style="color:#666666">;</span><br><br><span style="color:#DBD7CAEE">  ...</span><br><br><span style="color:#758575DD">  /* Do static pie self relocation after tunables and cpu features</span><br><span style="color:#758575DD">     are setup for ifunc resolvers. Before this point relocations</span><br><span style="color:#758575DD">     must be avoided.  */</span><br><span style="color:#80A665">  _dl_relocate_static_pie</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* Perform IREL{,A} relocations.  */</span><br><span style="color:#80A665">  ARCH_SETUP_IREL</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* The stack guard goes into the TCB, so initialize it early.  */</span><br><span style="color:#80A665">  ARCH_SETUP_TLS</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* In some architectures, IREL{,A} relocations happen after TLS setup in</span><br><span style="color:#758575DD">     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc's</span><br><span style="color:#758575DD">     hwcap and platform fields available in the TCB.  */</span><br><span style="color:#80A665">  ARCH_APPLY_IREL</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* Set up the stack checker's canary.  */</span><br><span style="color:#CB7676">  uintptr_t</span><span style="color:#DBD7CAEE"> stack_chk_guard </span><span style="color:#666666">=</span><span style="color:#80A665"> _dl_setup_stack_chk_guard</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">_dl_random</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375"> ifdef</span><span style="color:#80A665"> THREAD_SET_STACK_GUARD</span><br><span style="color:#80A665">  THREAD_SET_STACK_GUARD</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">stack_chk_guard</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375"> else</span><br><span style="color:#DBD7CAEE">  __stack_chk_guard </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> stack_chk_guard</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375"> endif</span><br><br><span style="color:#DBD7CAEE">  ...</span><br><br><span style="color:#758575DD">  /* Set up the pointer guard value.  */</span><br><span style="color:#CB7676">  uintptr_t</span><span style="color:#DBD7CAEE"> pointer_chk_guard </span><span style="color:#666666">=</span><span style="color:#80A665"> _dl_setup_pointer_guard</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">_dl_random</span><span style="color:#666666">,</span><br><span style="color:#DBD7CAEE">							 stack_chk_guard</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375"> ifdef</span><span style="color:#80A665"> THREAD_SET_POINTER_GUARD</span><br><span style="color:#80A665">  THREAD_SET_POINTER_GUARD</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">pointer_chk_guard</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375"> else</span><br><span style="color:#DBD7CAEE">  __pointer_chk_guard_local </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> pointer_chk_guard</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375"> endif</span><br><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><span style="color:#758575DD"> /* !SHARED  */</span><br><br><span style="color:#758575DD">  /* Register the destructor of the dynamic linker if there is any.  */</span><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#80A665">__glibc_likely</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">rtld_fini </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><br><span style="color:#80A665">    __cxa_atexit</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#d4976c">(</span><span style="color:#CB7676">void</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#CB7676">*</span><span style="color:#d9739f">)</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#d9739f">)</span><span style="color:#d4976c">)</span><span style="color:#DBD7CAEE"> rtld_fini</span><span style="color:#666666">,</span><span style="color:#4D9375"> NULL</span><span style="color:#666666">,</span><span style="color:#4D9375"> NULL</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 重点看这里</span><br><br><span style="color:#DBD7CAEE">  ...</span><br><br><span style="color:#758575DD">  /* Register the destructor of the statically-linked program.  */</span><br><span style="color:#80A665">  __cxa_atexit</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">call_fini</span><span style="color:#666666">,</span><span style="color:#4D9375"> NULL</span><span style="color:#666666">,</span><span style="color:#4D9375"> NULL</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#DBD7CAEE">  ...</span><br><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">init </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#4d9375">)</span><br><span style="color:#758575DD">    /* This is a legacy program which supplied its own init</span><br><span style="color:#758575DD">       routine.  */</span><br><span style="color:#666666">    </span><span style="color:#4d9375">(</span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">init</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">argc</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> argv</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> __environ MAIN_AUXVEC_PARAM</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 注意这里，`init` 如果有的话也会调用</span><br><span style="color:#4D9375">  else</span><br><span style="color:#758575DD">    /* This is a current program.  Use the dynamic segment to find</span><br><span style="color:#758575DD">       constructors.  */</span><br><span style="color:#80A665">    call_init</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">argc</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> argv</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> __environ</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* Auditing checkpoint: we have a new object.  */</span><br><span style="color:#80A665">  _dl_audit_preinit</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#80A665">GL</span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">dl_ns</span><span style="color:#d4976c">)</span><span style="color:#d4976c">[</span><span style="color:#DBD7CAEE">LM_ID_BASE</span><span style="color:#d4976c">]</span><span style="color:#666666">.</span><span style="color:#BD976A">_ns_loaded</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#80A665">__glibc_unlikely</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#80A665">GLRO</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">dl_debug_mask</span><span style="color:#d9739f">)</span><span style="color:#CB7676"> &#x26;</span><span style="color:#DBD7CAEE"> DL_DEBUG_IMPCALLS</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><br><span style="color:#80A665">    GLRO</span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">dl_debug_printf</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#C98A7D77">"</span><span style="color:#C99076">\n</span><span style="color:#C98A7D">transferring control: </span><span style="color:#C99076">%s\n\n</span><span style="color:#C98A7D77">"</span><span style="color:#666666">,</span><span style="color:#BD976A"> argv</span><span style="color:#d4976c">[</span><span style="color:#4C9A91">0</span><span style="color:#d4976c">]</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#FDAEB7;font-style:italic">#else</span><span style="color:#758575DD"> /* !SHARED */</span><br><span style="color:#80A665">  call_init</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">argc</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> argv</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> __environ</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#80A665">  _dl_debug_initialize</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4C9A91">0</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> LM_ID_BASE</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#FDAEB7;font-style:italic">#endif</span><br><br><span style="color:#80A665">  __libc_start_call_main</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">main</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> argc</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> argv </span><span style="color:#BD976A">MAIN_AUXVEC_PARAM</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#5eaab5">}</span><br></code></pre></div>
<p>也就是说，glibc 2.31 之后的 <code class="inline-code">initial</code> 里的析构函数只有 <code class="inline-code">rtld_fini</code> 这个指针对应的函数，而在 glibc2.31 之前，这个 <code class="inline-code">rtld_fini</code> 函数指针都是 <code class="inline-code">_dl_fini</code>。</p>
<p>关于 <code class="inline-code">init</code> 和 <code class="inline-code">fini</code> 函数指针，前者会遍历程序 .init_array 段里的所有构造函数地址，而后者往往是空指针，所以 .fini_array 里的析构函数地址一般都是由<code class="inline-code">rtld_fini</code> 指针里存放的函数管理。</p>
<p>一般情况下，<code class="inline-code">rtld_fini</code> 里存放的最常见的析构函数就是 <code class="inline-code">_dl_fini</code>，这个在源码里还是能找到：</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#AB5959">void</span><br><span style="color:#59873A">_dl_fini</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">void</span><span style="color:#2993a3">)</span><br><span style="color:rgba(255, 18, 18, 0.8)">{</span><br><span style="color:#393A34">  ...</span><br><span style="color:#1E754F">  for</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#998418">Lmid_t</span><span style="color:#393A34"> ns </span><span style="color:#999999">=</span><span style="color:#59873A"> GL</span><span style="color:#a65e2b">(</span><span style="color:#393A34">dl_nns</span><span style="color:#a65e2b">)</span><span style="color:#AB5959"> -</span><span style="color:#2F798A"> 1</span><span style="color:#999999">;</span><span style="color:#393A34"> ns </span><span style="color:#AB5959">></span><span style="color:#AB5959">=</span><span style="color:#2F798A"> 0</span><span style="color:#999999">;</span><span style="color:#AB5959"> --</span><span style="color:#393A34">ns</span><span style="color:#1e754f">)</span><br><span style="color:#999999">    </span><span style="color:rgba(255, 18, 18, 0.8)">{</span><br><span style="color:#A0ADA0">      /* Protect against concurrent loads and unloads.  */</span><br><span style="color:#59873A">      __rtld_lock_lock_recursive</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#59873A">GL</span><span style="color:#a13865">(</span><span style="color:#393A34">dl_load_lock</span><span style="color:#a13865">)</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">    // 重点看这个</span><br><br><span style="color:#AB5959">      unsigned</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> nloaded </span><span style="color:#999999">=</span><span style="color:#59873A"> GL</span><span style="color:#a65e2b">(</span><span style="color:#393A34">dl_ns</span><span style="color:#a65e2b">)</span><span style="color:#a65e2b">[</span><span style="color:#393A34">ns</span><span style="color:#a65e2b">]</span><span style="color:#999999">.</span><span style="color:#B07D48">_ns_nloaded</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">      /* No need to do anything for empty namespaces or those used for</span><br><span style="color:#A0ADA0">	 auditing DSOs.  */</span><br><span style="color:#1E754F">      if</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">nloaded </span><span style="color:#AB5959">==</span><span style="color:#2F798A"> 0</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> SHARED</span><br><span style="color:#AB5959">	  ||</span><span style="color:#59873A"> GL</span><span style="color:#a13865">(</span><span style="color:#393A34">dl_ns</span><span style="color:#a13865">)</span><span style="color:#a13865">[</span><span style="color:#393A34">ns</span><span style="color:#a13865">]</span><span style="color:#999999">.</span><span style="color:#B07D48">_ns_loaded</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_auditing</span><span style="color:#AB5959"> !=</span><span style="color:#393A34"> do_audit</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#999999">	  </span><span style="color:#a65e2b">)</span><br><span style="color:#59873A">	__rtld_lock_unlock_recursive</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#59873A">GL</span><span style="color:#a13865">(</span><span style="color:#393A34">dl_load_lock</span><span style="color:#a13865">)</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 重点看这个</span><br><span style="color:#1E754F">      else</span><br><span style="color:#999999">	</span><span style="color:#a65e2b">{</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> SHARED</span><br><span style="color:#59873A">	  _dl_audit_activity_nsid</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">ns</span><span style="color:#999999">,</span><span style="color:#393A34"> LA_ACT_DELETE</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><br><span style="color:#A0ADA0">	  /* Now we can allocate an array to hold all the pointers and</span><br><span style="color:#A0ADA0">	     copy the pointers in.  */</span><br><span style="color:#AB5959">	  struct</span><span style="color:#393A34"> link_map </span><span style="color:#AB5959">*</span><span style="color:#B07D48">maps</span><span style="color:#a13865">[</span><span style="color:#393A34">nloaded</span><span style="color:#a13865">]</span><span style="color:#999999">;</span><br><br><span style="color:#AB5959">	  unsigned</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> i</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	  struct</span><span style="color:#393A34"> link_map </span><span style="color:#AB5959">*</span><span style="color:#393A34">l</span><span style="color:#999999">;</span><br><span style="color:#59873A">	  assert</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">nloaded </span><span style="color:#AB5959">!=</span><span style="color:#2F798A"> 0</span><span style="color:#AB5959"> ||</span><span style="color:#59873A"> GL</span><span style="color:#bda437">(</span><span style="color:#393A34">dl_ns</span><span style="color:#bda437">)</span><span style="color:#bda437">[</span><span style="color:#393A34">ns</span><span style="color:#bda437">]</span><span style="color:#999999">.</span><span style="color:#B07D48">_ns_loaded</span><span style="color:#AB5959"> ==</span><span style="color:#1E754F"> NULL</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><span style="color:#1E754F">	  for</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">l </span><span style="color:#999999">=</span><span style="color:#59873A"> GL</span><span style="color:#bda437">(</span><span style="color:#393A34">dl_ns</span><span style="color:#bda437">)</span><span style="color:#bda437">[</span><span style="color:#393A34">ns</span><span style="color:#bda437">]</span><span style="color:#999999">.</span><span style="color:#B07D48">_ns_loaded</span><span style="color:#999999">,</span><span style="color:#393A34"> i </span><span style="color:#999999">=</span><span style="color:#2F798A"> 0</span><span style="color:#999999">;</span><span style="color:#393A34"> l </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#999999">;</span><span style="color:#393A34"> l </span><span style="color:#999999">=</span><span style="color:#B07D48"> l</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_next</span><span style="color:#a13865">)</span><br><span style="color:#A0ADA0">	    /* Do not handle ld.so in secondary namespaces.  */</span><br><span style="color:#1E754F">	    if</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">l </span><span style="color:#AB5959">==</span><span style="color:#B07D48"> l</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_real</span><span style="color:#a13865">)</span><br><span style="color:#999999">	      </span><span style="color:#a13865">{</span><br><span style="color:#59873A">		assert</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">i </span><span style="color:#AB5959">&#x3C;</span><span style="color:#393A34"> nloaded</span><span style="color:#bda437">)</span><span style="color:#999999">;</span><br><br><span style="color:#B07D48">		maps</span><span style="color:#bda437">[</span><span style="color:#393A34">i</span><span style="color:#bda437">]</span><span style="color:#999999"> =</span><span style="color:#393A34"> l</span><span style="color:#999999">;</span><br><span style="color:#B07D48">		l</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_idx</span><span style="color:#999999"> =</span><span style="color:#393A34"> i</span><span style="color:#999999">;</span><br><span style="color:#AB5959">		++</span><span style="color:#393A34">i</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">		/* Bump l_direct_opencount of all objects so that they</span><br><span style="color:#A0ADA0">		   are not dlclose()ed from underneath us.  */</span><br><span style="color:#AB5959">		++</span><span style="color:#B07D48">l</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_direct_opencount</span><span style="color:#999999">;</span><br><span style="color:#999999">	      </span><span style="color:#a13865">}</span><br><span style="color:#59873A">	  assert</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">ns </span><span style="color:#AB5959">!=</span><span style="color:#393A34"> LM_ID_BASE </span><span style="color:#AB5959">||</span><span style="color:#393A34"> i </span><span style="color:#AB5959">==</span><span style="color:#393A34"> nloaded</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">	  assert</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">ns </span><span style="color:#AB5959">==</span><span style="color:#393A34"> LM_ID_BASE </span><span style="color:#AB5959">||</span><span style="color:#393A34"> i </span><span style="color:#AB5959">==</span><span style="color:#393A34"> nloaded </span><span style="color:#AB5959">||</span><span style="color:#393A34"> i </span><span style="color:#AB5959">==</span><span style="color:#393A34"> nloaded </span><span style="color:#AB5959">-</span><span style="color:#2F798A"> 1</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">	  unsigned</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> nmaps </span><span style="color:#999999">=</span><span style="color:#393A34"> i</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">	  /* Now we have to do the sorting.  We can skip looking for the</span><br><span style="color:#A0ADA0">	     binary itself which is at the front of the search list for</span><br><span style="color:#A0ADA0">	     the main namespace.  */</span><br><span style="color:#A0ADA0">	  /* 对maps进行排序, 确定析构顺序 */</span><br><span style="color:#59873A">	  _dl_sort_maps</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">maps</span><span style="color:#999999">,</span><span style="color:#393A34"> nmaps</span><span style="color:#999999">,</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#393A34">ns </span><span style="color:#AB5959">==</span><span style="color:#393A34"> LM_ID_BASE</span><span style="color:#bda437">)</span><span style="color:#999999">,</span><span style="color:#1E754F"> true</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">	  /* We do not rely on the linked list of loaded object anymore</span><br><span style="color:#A0ADA0">	     from this point on.  We have our own list here (maps).  The</span><br><span style="color:#A0ADA0">	     various members of this list cannot vanish since the open</span><br><span style="color:#A0ADA0">	     count is too high and will be decremented in this loop.  So</span><br><span style="color:#A0ADA0">	     we release the lock so that some code which might be called</span><br><span style="color:#A0ADA0">	     from a destructor can directly or indirectly access the</span><br><span style="color:#A0ADA0">	     lock.  */</span><br><span style="color:#59873A">	  __rtld_lock_unlock_recursive</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#59873A">GL</span><span style="color:#bda437">(</span><span style="color:#393A34">dl_load_lock</span><span style="color:#bda437">)</span><span style="color:#a13865">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">	  /* 'maps' now contains the objects in the right order.  Now</span><br><span style="color:#A0ADA0">	     call the destructors.  We have to process this array from</span><br><span style="color:#A0ADA0">	     the front.  */</span><br><span style="color:#1E754F">	  for</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#393A34">i </span><span style="color:#999999">=</span><span style="color:#2F798A"> 0</span><span style="color:#999999">;</span><span style="color:#393A34"> i </span><span style="color:#AB5959">&#x3C;</span><span style="color:#393A34"> nmaps</span><span style="color:#999999">;</span><span style="color:#AB5959"> ++</span><span style="color:#393A34">i</span><span style="color:#a13865">)</span><br><span style="color:#999999">	    </span><span style="color:#a13865">{</span><br><span style="color:#AB5959">	      struct</span><span style="color:#393A34"> link_map </span><span style="color:#AB5959">*</span><span style="color:#393A34">l </span><span style="color:#999999">=</span><span style="color:#B07D48"> maps</span><span style="color:#bda437">[</span><span style="color:#393A34">i</span><span style="color:#bda437">]</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">	      if</span><span style="color:#999999"> </span><span style="color:#bda437">(</span><span style="color:#B07D48">l</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_init_called</span><span style="color:#bda437">)</span><br><span style="color:#999999">		</span><span style="color:#bda437">{</span><br><span style="color:#59873A">		  _dl_call_fini</span><span style="color:#999999"> </span><span style="color:#296aa3">(</span><span style="color:#393A34">l</span><span style="color:#296aa3">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 调用的这个函数的实现在下方</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> SHARED</span><br><span style="color:#A0ADA0">		  /* Auditing checkpoint: another object closed.  */</span><br><span style="color:#59873A">		  _dl_audit_objclose</span><span style="color:#999999"> </span><span style="color:#296aa3">(</span><span style="color:#393A34">l</span><span style="color:#296aa3">)</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#999999">		</span><span style="color:#bda437">}</span><br><br><span style="color:#A0ADA0">	      /* Correct the previous increment.  */</span><br><span style="color:#AB5959">	      --</span><span style="color:#B07D48">l</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_direct_opencount</span><span style="color:#999999">;</span><br><span style="color:#999999">	    </span><span style="color:#a13865">}</span><br><span style="color:#393A34">	  ...</span><br><span style="color:#a65e2b">}</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#CB7676">void</span><br><span style="color:#80A665">_dl_fini</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#CB7676">void</span><span style="color:#5eaab5">)</span><br><span style="color:rgba(255, 18, 18, 0.8)">{</span><br><span style="color:#DBD7CAEE">  ...</span><br><span style="color:#4D9375">  for</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#B8A965">Lmid_t</span><span style="color:#DBD7CAEE"> ns </span><span style="color:#666666">=</span><span style="color:#80A665"> GL</span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">dl_nns</span><span style="color:#d4976c">)</span><span style="color:#CB7676"> -</span><span style="color:#4C9A91"> 1</span><span style="color:#666666">;</span><span style="color:#DBD7CAEE"> ns </span><span style="color:#CB7676">></span><span style="color:#CB7676">=</span><span style="color:#4C9A91"> 0</span><span style="color:#666666">;</span><span style="color:#CB7676"> --</span><span style="color:#DBD7CAEE">ns</span><span style="color:#4d9375">)</span><br><span style="color:#666666">    </span><span style="color:rgba(255, 18, 18, 0.8)">{</span><br><span style="color:#758575DD">      /* Protect against concurrent loads and unloads.  */</span><br><span style="color:#80A665">      __rtld_lock_lock_recursive</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#80A665">GL</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">dl_load_lock</span><span style="color:#d9739f">)</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><span style="color:#758575DD">    // 重点看这个</span><br><br><span style="color:#CB7676">      unsigned</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> nloaded </span><span style="color:#666666">=</span><span style="color:#80A665"> GL</span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">dl_ns</span><span style="color:#d4976c">)</span><span style="color:#d4976c">[</span><span style="color:#DBD7CAEE">ns</span><span style="color:#d4976c">]</span><span style="color:#666666">.</span><span style="color:#BD976A">_ns_nloaded</span><span style="color:#666666">;</span><br><span style="color:#758575DD">      /* No need to do anything for empty namespaces or those used for</span><br><span style="color:#758575DD">	 auditing DSOs.  */</span><br><span style="color:#4D9375">      if</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">nloaded </span><span style="color:#CB7676">==</span><span style="color:#4C9A91"> 0</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> SHARED</span><br><span style="color:#CB7676">	  ||</span><span style="color:#80A665"> GL</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">dl_ns</span><span style="color:#d9739f">)</span><span style="color:#d9739f">[</span><span style="color:#DBD7CAEE">ns</span><span style="color:#d9739f">]</span><span style="color:#666666">.</span><span style="color:#BD976A">_ns_loaded</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_auditing</span><span style="color:#CB7676"> !=</span><span style="color:#DBD7CAEE"> do_audit</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#666666">	  </span><span style="color:#d4976c">)</span><br><span style="color:#80A665">	__rtld_lock_unlock_recursive</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#80A665">GL</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">dl_load_lock</span><span style="color:#d9739f">)</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 重点看这个</span><br><span style="color:#4D9375">      else</span><br><span style="color:#666666">	</span><span style="color:#d4976c">{</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> SHARED</span><br><span style="color:#80A665">	  _dl_audit_activity_nsid</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">ns</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> LA_ACT_DELETE</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><br><span style="color:#758575DD">	  /* Now we can allocate an array to hold all the pointers and</span><br><span style="color:#758575DD">	     copy the pointers in.  */</span><br><span style="color:#CB7676">	  struct</span><span style="color:#DBD7CAEE"> link_map </span><span style="color:#CB7676">*</span><span style="color:#BD976A">maps</span><span style="color:#d9739f">[</span><span style="color:#DBD7CAEE">nloaded</span><span style="color:#d9739f">]</span><span style="color:#666666">;</span><br><br><span style="color:#CB7676">	  unsigned</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> i</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	  struct</span><span style="color:#DBD7CAEE"> link_map </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">l</span><span style="color:#666666">;</span><br><span style="color:#80A665">	  assert</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">nloaded </span><span style="color:#CB7676">!=</span><span style="color:#4C9A91"> 0</span><span style="color:#CB7676"> ||</span><span style="color:#80A665"> GL</span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">dl_ns</span><span style="color:#e6cc77">)</span><span style="color:#e6cc77">[</span><span style="color:#DBD7CAEE">ns</span><span style="color:#e6cc77">]</span><span style="color:#666666">.</span><span style="color:#BD976A">_ns_loaded</span><span style="color:#CB7676"> ==</span><span style="color:#4D9375"> NULL</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><span style="color:#4D9375">	  for</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">l </span><span style="color:#666666">=</span><span style="color:#80A665"> GL</span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">dl_ns</span><span style="color:#e6cc77">)</span><span style="color:#e6cc77">[</span><span style="color:#DBD7CAEE">ns</span><span style="color:#e6cc77">]</span><span style="color:#666666">.</span><span style="color:#BD976A">_ns_loaded</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> i </span><span style="color:#666666">=</span><span style="color:#4C9A91"> 0</span><span style="color:#666666">;</span><span style="color:#DBD7CAEE"> l </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#666666">;</span><span style="color:#DBD7CAEE"> l </span><span style="color:#666666">=</span><span style="color:#BD976A"> l</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_next</span><span style="color:#d9739f">)</span><br><span style="color:#758575DD">	    /* Do not handle ld.so in secondary namespaces.  */</span><br><span style="color:#4D9375">	    if</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">l </span><span style="color:#CB7676">==</span><span style="color:#BD976A"> l</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_real</span><span style="color:#d9739f">)</span><br><span style="color:#666666">	      </span><span style="color:#d9739f">{</span><br><span style="color:#80A665">		assert</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">i </span><span style="color:#CB7676">&#x3C;</span><span style="color:#DBD7CAEE"> nloaded</span><span style="color:#e6cc77">)</span><span style="color:#666666">;</span><br><br><span style="color:#BD976A">		maps</span><span style="color:#e6cc77">[</span><span style="color:#DBD7CAEE">i</span><span style="color:#e6cc77">]</span><span style="color:#666666"> =</span><span style="color:#DBD7CAEE"> l</span><span style="color:#666666">;</span><br><span style="color:#BD976A">		l</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_idx</span><span style="color:#666666"> =</span><span style="color:#DBD7CAEE"> i</span><span style="color:#666666">;</span><br><span style="color:#CB7676">		++</span><span style="color:#DBD7CAEE">i</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">		/* Bump l_direct_opencount of all objects so that they</span><br><span style="color:#758575DD">		   are not dlclose()ed from underneath us.  */</span><br><span style="color:#CB7676">		++</span><span style="color:#BD976A">l</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_direct_opencount</span><span style="color:#666666">;</span><br><span style="color:#666666">	      </span><span style="color:#d9739f">}</span><br><span style="color:#80A665">	  assert</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">ns </span><span style="color:#CB7676">!=</span><span style="color:#DBD7CAEE"> LM_ID_BASE </span><span style="color:#CB7676">||</span><span style="color:#DBD7CAEE"> i </span><span style="color:#CB7676">==</span><span style="color:#DBD7CAEE"> nloaded</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><span style="color:#80A665">	  assert</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">ns </span><span style="color:#CB7676">==</span><span style="color:#DBD7CAEE"> LM_ID_BASE </span><span style="color:#CB7676">||</span><span style="color:#DBD7CAEE"> i </span><span style="color:#CB7676">==</span><span style="color:#DBD7CAEE"> nloaded </span><span style="color:#CB7676">||</span><span style="color:#DBD7CAEE"> i </span><span style="color:#CB7676">==</span><span style="color:#DBD7CAEE"> nloaded </span><span style="color:#CB7676">-</span><span style="color:#4C9A91"> 1</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">	  unsigned</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> nmaps </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> i</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">	  /* Now we have to do the sorting.  We can skip looking for the</span><br><span style="color:#758575DD">	     binary itself which is at the front of the search list for</span><br><span style="color:#758575DD">	     the main namespace.  */</span><br><span style="color:#758575DD">	  /* 对maps进行排序, 确定析构顺序 */</span><br><span style="color:#80A665">	  _dl_sort_maps</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">maps</span><span style="color:#666666">,</span><span style="color:#DBD7CAEE"> nmaps</span><span style="color:#666666">,</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">ns </span><span style="color:#CB7676">==</span><span style="color:#DBD7CAEE"> LM_ID_BASE</span><span style="color:#e6cc77">)</span><span style="color:#666666">,</span><span style="color:#4D9375"> true</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">	  /* We do not rely on the linked list of loaded object anymore</span><br><span style="color:#758575DD">	     from this point on.  We have our own list here (maps).  The</span><br><span style="color:#758575DD">	     various members of this list cannot vanish since the open</span><br><span style="color:#758575DD">	     count is too high and will be decremented in this loop.  So</span><br><span style="color:#758575DD">	     we release the lock so that some code which might be called</span><br><span style="color:#758575DD">	     from a destructor can directly or indirectly access the</span><br><span style="color:#758575DD">	     lock.  */</span><br><span style="color:#80A665">	  __rtld_lock_unlock_recursive</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#80A665">GL</span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">dl_load_lock</span><span style="color:#e6cc77">)</span><span style="color:#d9739f">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">	  /* 'maps' now contains the objects in the right order.  Now</span><br><span style="color:#758575DD">	     call the destructors.  We have to process this array from</span><br><span style="color:#758575DD">	     the front.  */</span><br><span style="color:#4D9375">	  for</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">i </span><span style="color:#666666">=</span><span style="color:#4C9A91"> 0</span><span style="color:#666666">;</span><span style="color:#DBD7CAEE"> i </span><span style="color:#CB7676">&#x3C;</span><span style="color:#DBD7CAEE"> nmaps</span><span style="color:#666666">;</span><span style="color:#CB7676"> ++</span><span style="color:#DBD7CAEE">i</span><span style="color:#d9739f">)</span><br><span style="color:#666666">	    </span><span style="color:#d9739f">{</span><br><span style="color:#CB7676">	      struct</span><span style="color:#DBD7CAEE"> link_map </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">l </span><span style="color:#666666">=</span><span style="color:#BD976A"> maps</span><span style="color:#e6cc77">[</span><span style="color:#DBD7CAEE">i</span><span style="color:#e6cc77">]</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">	      if</span><span style="color:#666666"> </span><span style="color:#e6cc77">(</span><span style="color:#BD976A">l</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_init_called</span><span style="color:#e6cc77">)</span><br><span style="color:#666666">		</span><span style="color:#e6cc77">{</span><br><span style="color:#80A665">		  _dl_call_fini</span><span style="color:#666666"> </span><span style="color:#6394bf">(</span><span style="color:#DBD7CAEE">l</span><span style="color:#6394bf">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 调用的这个函数的实现在下方</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> SHARED</span><br><span style="color:#758575DD">		  /* Auditing checkpoint: another object closed.  */</span><br><span style="color:#80A665">		  _dl_audit_objclose</span><span style="color:#666666"> </span><span style="color:#6394bf">(</span><span style="color:#DBD7CAEE">l</span><span style="color:#6394bf">)</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#666666">		</span><span style="color:#e6cc77">}</span><br><br><span style="color:#758575DD">	      /* Correct the previous increment.  */</span><br><span style="color:#CB7676">	      --</span><span style="color:#BD976A">l</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_direct_opencount</span><span style="color:#666666">;</span><br><span style="color:#666666">	    </span><span style="color:#d9739f">}</span><br><span style="color:#DBD7CAEE">	  ...</span><br><span style="color:#d4976c">}</span><br></code></pre></div>
<p>注意，这个函数在高版本并没有被移除，不要被一些博客误导了。</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#AB5959">void</span><br><span style="color:#59873A">_dl_call_fini</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#B07D48">closure_map</span><span style="color:#2993a3">)</span><br><span style="color:#2993a3">{</span><br><span style="color:#AB5959">  struct</span><span style="color:#393A34"> link_map </span><span style="color:#AB5959">*</span><span style="color:#393A34">map </span><span style="color:#999999">=</span><span style="color:#393A34"> closure_map</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* When debugging print a message first.  */</span><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#59873A">__glibc_unlikely</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#59873A">GLRO</span><span style="color:#a13865">(</span><span style="color:#393A34">dl_debug_mask</span><span style="color:#a13865">)</span><span style="color:#AB5959"> &#x26;</span><span style="color:#393A34"> DL_DEBUG_IMPCALLS</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><br><span style="color:#59873A">    _dl_debug_printf</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#B5695977">"</span><span style="color:#A65E2B">\n</span><span style="color:#B56959">calling fini: </span><span style="color:#A65E2B">%s</span><span style="color:#B56959"> [</span><span style="color:#A65E2B">%lu</span><span style="color:#B56959">]</span><span style="color:#A65E2B">\n\n</span><span style="color:#B5695977">"</span><span style="color:#999999">,</span><span style="color:#B07D48"> map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_name</span><span style="color:#999999">,</span><span style="color:#B07D48"> map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_ns</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#A0ADA0">  /* Make sure nothing happens if we are called twice.  */</span><br><span style="color:#B07D48">  map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_init_called</span><span style="color:#999999"> =</span><span style="color:#2F798A"> 0</span><span style="color:#999999">;</span><br><br><span style="color:#59873A">  ElfW</span><span style="color:#1e754f">(</span><span style="color:#393A34">Dyn</span><span style="color:#1e754f">)</span><span style="color:#AB5959"> *</span><span style="color:#393A34">fini_array </span><span style="color:#999999">=</span><span style="color:#B07D48"> map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_info</span><span style="color:#1e754f">[</span><span style="color:#393A34">DT_FINI_ARRAY</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">fini_array </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#1e754f">)</span><br><span style="color:#999999">    </span><span style="color:#1e754f">{</span><br><span style="color:#A0ADA0">        /*</span><br><span style="color:#A0ADA0">            l->l_addr: 模块 l 的加载基地址</span><br><span style="color:#A0ADA0">            l->l_info[DT_FINI_ARRAY]: 模块 l 中 fini_array 节的描述符</span><br><span style="color:#A0ADA0">            l->l_info[DT_FINI_ARRAY]->d_un.d_ptr: 模块 l 中 fini_arrary 节的偏移</span><br><span style="color:#A0ADA0">            array: 为模块 l 的 fini_array 节的内存地址</span><br><span style="color:#A0ADA0">        */</span><br><span style="color:#59873A">      ElfW</span><span style="color:#a65e2b">(</span><span style="color:#393A34">Addr</span><span style="color:#a65e2b">)</span><span style="color:#AB5959"> *</span><span style="color:#393A34">array </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#59873A">ElfW</span><span style="color:#a13865">(</span><span style="color:#393A34">Addr</span><span style="color:#a13865">)</span><span style="color:#AB5959"> *</span><span style="color:#a65e2b">)</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#B07D48">map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_addr</span><br><span style="color:#AB5959">                                          +</span><span style="color:#B07D48"> fini_array</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">d_un</span><span style="color:#999999">.</span><span style="color:#B07D48">d_ptr</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">      size_t</span><span style="color:#393A34"> sz </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#B07D48">map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_info</span><span style="color:#a13865">[</span><span style="color:#393A34">DT_FINI_ARRAYSZ</span><span style="color:#a13865">]</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">d_un</span><span style="color:#999999">.</span><span style="color:#B07D48">d_val</span><br><span style="color:#AB5959">                   /</span><span style="color:#AB5959"> sizeof</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#59873A">ElfW</span><span style="color:#bda437">(</span><span style="color:#393A34">Addr</span><span style="color:#bda437">)</span><span style="color:#a13865">)</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">      while</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">sz</span><span style="color:#AB5959">--</span><span style="color:#AB5959"> </span><span style="color:#AB5959">></span><span style="color:#2F798A"> 0</span><span style="color:#a65e2b">)</span><span style="color:#A0ADA0"> //从后往前, 调用fini_array中的每一个析构函数</span><br><span style="color:#999999">        </span><span style="color:#a65e2b">(</span><span style="color:#a13865">(</span><span style="color:#998418">fini_t</span><span style="color:#a13865">)</span><span style="color:#B07D48"> array</span><span style="color:#a13865">[</span><span style="color:#393A34">sz</span><span style="color:#a13865">]</span><span style="color:#a65e2b">)</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#999999">    </span><span style="color:#1e754f">}</span><br><br><span style="color:#A0ADA0">  /* Next try the old-style destructor.  */</span><br><span style="color:#A0ADA0">  /* 调用fini段中的函数 */</span><br><span style="color:#59873A">  ElfW</span><span style="color:#1e754f">(</span><span style="color:#393A34">Dyn</span><span style="color:#1e754f">)</span><span style="color:#AB5959"> *</span><span style="color:#393A34">fini </span><span style="color:#999999">=</span><span style="color:#B07D48"> map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_info</span><span style="color:#1e754f">[</span><span style="color:#393A34">DT_FINI</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">fini </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#1e754f">)</span><br><span style="color:#59873A">    DL_CALL_DT_FINI</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">map</span><span style="color:#999999">,</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#a13865">(</span><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#a13865">)</span><span style="color:#B07D48"> map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_addr</span><span style="color:#AB5959"> +</span><span style="color:#B07D48"> fini</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">d_un</span><span style="color:#999999">.</span><span style="color:#B07D48">d_ptr</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#CB7676">void</span><br><span style="color:#80A665">_dl_call_fini</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#BD976A">closure_map</span><span style="color:#5eaab5">)</span><br><span style="color:#5eaab5">{</span><br><span style="color:#CB7676">  struct</span><span style="color:#DBD7CAEE"> link_map </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">map </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> closure_map</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* When debugging print a message first.  */</span><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#80A665">__glibc_unlikely</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#80A665">GLRO</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">dl_debug_mask</span><span style="color:#d9739f">)</span><span style="color:#CB7676"> &#x26;</span><span style="color:#DBD7CAEE"> DL_DEBUG_IMPCALLS</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><br><span style="color:#80A665">    _dl_debug_printf</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#C98A7D77">"</span><span style="color:#C99076">\n</span><span style="color:#C98A7D">calling fini: </span><span style="color:#C99076">%s</span><span style="color:#C98A7D"> [</span><span style="color:#C99076">%lu</span><span style="color:#C98A7D">]</span><span style="color:#C99076">\n\n</span><span style="color:#C98A7D77">"</span><span style="color:#666666">,</span><span style="color:#BD976A"> map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_name</span><span style="color:#666666">,</span><span style="color:#BD976A"> map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_ns</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#758575DD">  /* Make sure nothing happens if we are called twice.  */</span><br><span style="color:#BD976A">  map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_init_called</span><span style="color:#666666"> =</span><span style="color:#4C9A91"> 0</span><span style="color:#666666">;</span><br><br><span style="color:#80A665">  ElfW</span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">Dyn</span><span style="color:#4d9375">)</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">fini_array </span><span style="color:#666666">=</span><span style="color:#BD976A"> map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_info</span><span style="color:#4d9375">[</span><span style="color:#DBD7CAEE">DT_FINI_ARRAY</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">fini_array </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#4d9375">)</span><br><span style="color:#666666">    </span><span style="color:#4d9375">{</span><br><span style="color:#758575DD">        /*</span><br><span style="color:#758575DD">            l->l_addr: 模块 l 的加载基地址</span><br><span style="color:#758575DD">            l->l_info[DT_FINI_ARRAY]: 模块 l 中 fini_array 节的描述符</span><br><span style="color:#758575DD">            l->l_info[DT_FINI_ARRAY]->d_un.d_ptr: 模块 l 中 fini_arrary 节的偏移</span><br><span style="color:#758575DD">            array: 为模块 l 的 fini_array 节的内存地址</span><br><span style="color:#758575DD">        */</span><br><span style="color:#80A665">      ElfW</span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">Addr</span><span style="color:#d4976c">)</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">array </span><span style="color:#666666">=</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#80A665">ElfW</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">Addr</span><span style="color:#d9739f">)</span><span style="color:#CB7676"> *</span><span style="color:#d4976c">)</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#BD976A">map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_addr</span><br><span style="color:#CB7676">                                          +</span><span style="color:#BD976A"> fini_array</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">d_un</span><span style="color:#666666">.</span><span style="color:#BD976A">d_ptr</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">      size_t</span><span style="color:#DBD7CAEE"> sz </span><span style="color:#666666">=</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#BD976A">map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_info</span><span style="color:#d9739f">[</span><span style="color:#DBD7CAEE">DT_FINI_ARRAYSZ</span><span style="color:#d9739f">]</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">d_un</span><span style="color:#666666">.</span><span style="color:#BD976A">d_val</span><br><span style="color:#CB7676">                   /</span><span style="color:#CB7676"> sizeof</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#80A665">ElfW</span><span style="color:#e6cc77">(</span><span style="color:#DBD7CAEE">Addr</span><span style="color:#e6cc77">)</span><span style="color:#d9739f">)</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">      while</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">sz</span><span style="color:#CB7676">--</span><span style="color:#CB7676"> </span><span style="color:#CB7676">></span><span style="color:#4C9A91"> 0</span><span style="color:#d4976c">)</span><span style="color:#758575DD"> //从后往前, 调用fini_array中的每一个析构函数</span><br><span style="color:#666666">        </span><span style="color:#d4976c">(</span><span style="color:#d9739f">(</span><span style="color:#B8A965">fini_t</span><span style="color:#d9739f">)</span><span style="color:#BD976A"> array</span><span style="color:#d9739f">[</span><span style="color:#DBD7CAEE">sz</span><span style="color:#d9739f">]</span><span style="color:#d4976c">)</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#666666">    </span><span style="color:#4d9375">}</span><br><br><span style="color:#758575DD">  /* Next try the old-style destructor.  */</span><br><span style="color:#758575DD">  /* 调用fini段中的函数 */</span><br><span style="color:#80A665">  ElfW</span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">Dyn</span><span style="color:#4d9375">)</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">fini </span><span style="color:#666666">=</span><span style="color:#BD976A"> map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_info</span><span style="color:#4d9375">[</span><span style="color:#DBD7CAEE">DT_FINI</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">fini </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#4d9375">)</span><br><span style="color:#80A665">    DL_CALL_DT_FINI</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">map</span><span style="color:#666666">,</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#d9739f">(</span><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#d9739f">)</span><span style="color:#BD976A"> map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_addr</span><span style="color:#CB7676"> +</span><span style="color:#BD976A"> fini</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">d_un</span><span style="color:#666666">.</span><span style="color:#BD976A">d_ptr</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#5eaab5">}</span><br></code></pre></div>
<p>在低版本里这个函数被实现在 <code class="inline-code">_dl_fini.c</code> 里，但是内容基本上是差不多的。</p>
<p>这里 <code class="inline-code">fini_array->d_un.d_ptr</code> 是不可写的，所以只能通过修改 <code class="inline-code">map->l_addr</code> 的方式劫持程序执行流。</p>
<p>而且实际调试发现，高版本中并没有直接去 call 这个函数，用的是 <code class="inline-code">jmp</code> 之类的方式，所以一开始调试的时候找不到符号搞得人很蒙圈。</p>
<h2 id class="scroll-target"><a href="#"><code class="hash inline-code">#</code>攻击</a></h2>
<h3 id="__exit_funcs" class="scroll-target"><a href="#__exit_funcs"><code class="hash inline-code">#</code>劫持 <code class="inline-code">__exit_funcs</code></a></h3>
<p>并非不能劫持，但是比较麻烦。</p>
<p><img src="https://pic1.imgdb.cn/item/67dbb77788c538a9b5c1a155.png" alt/></p>
<p>重点看这里的 <code class="inline-code">ror</code> 对节点的 <code class="inline-code">fn</code> 字段进行循环异或，然后用 <code class="inline-code">fs:[0x30]</code> 异或，fs 指向当前线程的控制块，也就是 <code class="inline-code">tcbhead_t</code> 结构体：</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#1E754F">typedef</span><span style="color:#AB5959"> struct</span><br><span style="color:#2993a3">{</span><br><span style="color:#AB5959">    void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">tcb</span><span style="color:#999999">;</span><span style="color:#A0ADA0">                /* Pointer to the TCB.  Not necessarily the</span><br><span style="color:#A0ADA0">                               thread descriptor used by libpthread.  */</span><br><span style="color:#998418">    dtv_t</span><span style="color:#AB5959"> *</span><span style="color:#393A34">dtv</span><span style="color:#999999">;</span><br><span style="color:#AB5959">    void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">self</span><span style="color:#999999">;</span><span style="color:#A0ADA0">                /* Pointer to the thread descriptor.  */</span><br><span style="color:#AB5959">    int</span><span style="color:#393A34"> multiple_threads</span><span style="color:#999999">;</span><br><span style="color:#AB5959">    int</span><span style="color:#393A34"> gscope_flag</span><span style="color:#999999">;</span><br><span style="color:#AB5959">    uintptr_t</span><span style="color:#393A34"> sysinfo</span><span style="color:#999999">;</span><br><span style="color:#AB5959">    uintptr_t</span><span style="color:#393A34"> stack_guard</span><span style="color:#999999">;</span><span style="color:#A0ADA0">        //栈canary, fs:0x28</span><br><span style="color:#AB5959">    uintptr_t</span><span style="color:#393A34"> pointer_guard</span><span style="color:#999999">;</span><span style="color:#A0ADA0">      //指针加密, fs:0x30</span><br><span style="color:#AB5959">    unsigned</span><span style="color:#AB5959"> long</span><span style="color:#AB5959"> int</span><span style="color:#B07D48"> vgetcpu_cache</span><span style="color:#1e754f">[</span><span style="color:#2F798A">2</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">    /* Bit 0: X86_FEATURE_1_IBT.</span><br><span style="color:#A0ADA0">         Bit 1: X86_FEATURE_1_SHSTK.</span><br><span style="color:#A0ADA0">       */</span><br><span style="color:#AB5959">    unsigned</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> feature_1</span><span style="color:#999999">;</span><br><span style="color:#AB5959">    int</span><span style="color:#393A34"> __glibc_unused1</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">    /* Reservation of some values for the TM ABI.  */</span><br><span style="color:#AB5959">    void</span><span style="color:#AB5959"> *</span><span style="color:#B07D48">__private_tm</span><span style="color:#1e754f">[</span><span style="color:#2F798A">4</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">    /* GCC split stack support.  */</span><br><span style="color:#AB5959">    void</span><span style="color:#AB5959"> *</span><span style="color:#393A34">__private_ss</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">    /* The lowest address of shadow stack,  */</span><br><span style="color:#AB5959">    unsigned</span><span style="color:#AB5959"> long</span><span style="color:#AB5959"> long</span><span style="color:#AB5959"> int</span><span style="color:#393A34"> ssp_base</span><span style="color:#999999">;</span><br><span style="color:#A0ADA0">    /* Must be kept even if it is no longer used by glibc since programs,</span><br><span style="color:#A0ADA0">         like AddressSanitizer, depend on the size of tcbhead_t.  */</span><br><span style="color:#393A34">    __128bits </span><span style="color:#B07D48">__glibc_unused2</span><span style="color:#1e754f">[</span><span style="color:#2F798A">8</span><span style="color:#1e754f">]</span><span style="color:#1e754f">[</span><span style="color:#2F798A">4</span><span style="color:#1e754f">]</span><span style="color:#59873A"> __attribute__</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#a65e2b">(</span><span style="color:#59873A">aligned</span><span style="color:#999999"> </span><span style="color:#a13865">(</span><span style="color:#2F798A">32</span><span style="color:#a13865">)</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#B07D48">__padding</span><span style="color:#1e754f">[</span><span style="color:#2F798A">8</span><span style="color:#1e754f">]</span><span style="color:#999999">;</span><br><span style="color:#2993a3">}</span><span style="color:#998418"> tcbhead_t</span><span style="color:#999999">;</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#4D9375">typedef</span><span style="color:#CB7676"> struct</span><br><span style="color:#5eaab5">{</span><br><span style="color:#CB7676">    void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">tcb</span><span style="color:#666666">;</span><span style="color:#758575DD">                /* Pointer to the TCB.  Not necessarily the</span><br><span style="color:#758575DD">                               thread descriptor used by libpthread.  */</span><br><span style="color:#B8A965">    dtv_t</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">dtv</span><span style="color:#666666">;</span><br><span style="color:#CB7676">    void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">self</span><span style="color:#666666">;</span><span style="color:#758575DD">                /* Pointer to the thread descriptor.  */</span><br><span style="color:#CB7676">    int</span><span style="color:#DBD7CAEE"> multiple_threads</span><span style="color:#666666">;</span><br><span style="color:#CB7676">    int</span><span style="color:#DBD7CAEE"> gscope_flag</span><span style="color:#666666">;</span><br><span style="color:#CB7676">    uintptr_t</span><span style="color:#DBD7CAEE"> sysinfo</span><span style="color:#666666">;</span><br><span style="color:#CB7676">    uintptr_t</span><span style="color:#DBD7CAEE"> stack_guard</span><span style="color:#666666">;</span><span style="color:#758575DD">        //栈canary, fs:0x28</span><br><span style="color:#CB7676">    uintptr_t</span><span style="color:#DBD7CAEE"> pointer_guard</span><span style="color:#666666">;</span><span style="color:#758575DD">      //指针加密, fs:0x30</span><br><span style="color:#CB7676">    unsigned</span><span style="color:#CB7676"> long</span><span style="color:#CB7676"> int</span><span style="color:#BD976A"> vgetcpu_cache</span><span style="color:#4d9375">[</span><span style="color:#4C9A91">2</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><br><span style="color:#758575DD">    /* Bit 0: X86_FEATURE_1_IBT.</span><br><span style="color:#758575DD">         Bit 1: X86_FEATURE_1_SHSTK.</span><br><span style="color:#758575DD">       */</span><br><span style="color:#CB7676">    unsigned</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> feature_1</span><span style="color:#666666">;</span><br><span style="color:#CB7676">    int</span><span style="color:#DBD7CAEE"> __glibc_unused1</span><span style="color:#666666">;</span><br><span style="color:#758575DD">    /* Reservation of some values for the TM ABI.  */</span><br><span style="color:#CB7676">    void</span><span style="color:#CB7676"> *</span><span style="color:#BD976A">__private_tm</span><span style="color:#4d9375">[</span><span style="color:#4C9A91">4</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><br><span style="color:#758575DD">    /* GCC split stack support.  */</span><br><span style="color:#CB7676">    void</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">__private_ss</span><span style="color:#666666">;</span><br><span style="color:#758575DD">    /* The lowest address of shadow stack,  */</span><br><span style="color:#CB7676">    unsigned</span><span style="color:#CB7676"> long</span><span style="color:#CB7676"> long</span><span style="color:#CB7676"> int</span><span style="color:#DBD7CAEE"> ssp_base</span><span style="color:#666666">;</span><br><span style="color:#758575DD">    /* Must be kept even if it is no longer used by glibc since programs,</span><br><span style="color:#758575DD">         like AddressSanitizer, depend on the size of tcbhead_t.  */</span><br><span style="color:#DBD7CAEE">    __128bits </span><span style="color:#BD976A">__glibc_unused2</span><span style="color:#4d9375">[</span><span style="color:#4C9A91">8</span><span style="color:#4d9375">]</span><span style="color:#4d9375">[</span><span style="color:#4C9A91">4</span><span style="color:#4d9375">]</span><span style="color:#80A665"> __attribute__</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#d4976c">(</span><span style="color:#80A665">aligned</span><span style="color:#666666"> </span><span style="color:#d9739f">(</span><span style="color:#4C9A91">32</span><span style="color:#d9739f">)</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#BD976A">__padding</span><span style="color:#4d9375">[</span><span style="color:#4C9A91">8</span><span style="color:#4d9375">]</span><span style="color:#666666">;</span><br><span style="color:#5eaab5">}</span><span style="color:#B8A965"> tcbhead_t</span><span style="color:#666666">;</span><br></code></pre></div>
<p>所以如果要伪造这个链表的话，需要能泄漏或者能修改 <code class="inline-code">pointer_guard</code> 的值，然后能往 libc 的 <code class="inline-code">__exit_funcs</code> 写入伪造好的链表位置。</p>
<p>这个异或加密是全版本都有的。</p>
<h3 id="exit-hook" class="scroll-target"><a href="#exit-hook"><code class="hash inline-code">#</code>打 exit hook</a></h3>
<p>其实就是打原理部分提到的 <code class="inline-code">_dl_fini</code> 里的 <code class="inline-code">__rtld_lock_lock_recursive</code> 和 <code class="inline-code">__rtld_lock_unlock_recursive</code>，这两个函数在低版本（大致为 2.31 前）被实现成函数指针的形式，也就是存放在 ld 里，并且是存放的地方是可写的，这是常说的 exit hook。</p>
<p>也就是</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-text">_rtld_global._dl_rtld_lock_recursive(&(_rtld_global._dl_load_lock).mutex)
_rtld_global._dl_rtld_unlock_recursive(&(_rtld_global._dl_load_lock).mutex)
</code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-text">_rtld_global._dl_rtld_lock_recursive(&(_rtld_global._dl_load_lock).mutex)
_rtld_global._dl_rtld_unlock_recursive(&(_rtld_global._dl_load_lock).mutex)
</code></pre></div>
<p>这两个指针可以调试得出，可以把函数指针改为 <code class="inline-code">system</code>，参数改为 <code class="inline-code">binsh</code> 实现 getshell。</p>
<p>高版本把这个地方设置为了不可写，如下图</p>
<p><img src="https://pic1.imgdb.cn/item/67eab2410ba3d5a1d7e85be9.png" alt/>
<img src="https://pic1.imgdb.cn/item/67eab26e0ba3d5a1d7e85c0c.png" alt/></p>
<p>所以也就没办法打这个了。</p>
<h3 id="_dl_fini-l_addr" class="scroll-target"><a href="#_dl_fini-l_addr"><code class="hash inline-code">#</code>打 <code class="inline-code">_dl_fini</code> 的 <code class="inline-code">l_addr</code></a></h3>
<p>前面说过 <code class="inline-code">rtld_fini</code> 会负责调用程序的 .fini_array 里的析构函数，其实就是在 <code class="inline-code">_dl_call_fini</code> 里做的。</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">fini_array </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#2993a3">)</span><br><span style="color:#999999">    </span><span style="color:#2993a3">{</span><br><span style="color:#59873A">      ElfW</span><span style="color:#1e754f">(</span><span style="color:#393A34">Addr</span><span style="color:#1e754f">)</span><span style="color:#AB5959"> *</span><span style="color:#393A34">array </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#59873A">ElfW</span><span style="color:#a65e2b">(</span><span style="color:#393A34">Addr</span><span style="color:#a65e2b">)</span><span style="color:#AB5959"> *</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#B07D48">map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_addr</span><br><span style="color:#AB5959">                                          +</span><span style="color:#B07D48"> fini_array</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">d_un</span><span style="color:#999999">.</span><span style="color:#B07D48">d_ptr</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#AB5959">      size_t</span><span style="color:#393A34"> sz </span><span style="color:#999999">=</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#B07D48">map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_info</span><span style="color:#a65e2b">[</span><span style="color:#393A34">DT_FINI_ARRAYSZ</span><span style="color:#a65e2b">]</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">d_un</span><span style="color:#999999">.</span><span style="color:#B07D48">d_val</span><br><span style="color:#AB5959">                   /</span><span style="color:#AB5959"> sizeof</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#59873A">ElfW</span><span style="color:#a13865">(</span><span style="color:#393A34">Addr</span><span style="color:#a13865">)</span><span style="color:#a65e2b">)</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><br><span style="color:#1E754F">      while</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">sz</span><span style="color:#AB5959">--</span><span style="color:#AB5959"> </span><span style="color:#AB5959">></span><span style="color:#2F798A"> 0</span><span style="color:#1e754f">)</span><br><span style="color:#999999">        </span><span style="color:#1e754f">(</span><span style="color:#a65e2b">(</span><span style="color:#998418">fini_t</span><span style="color:#a65e2b">)</span><span style="color:#B07D48"> array</span><span style="color:#a65e2b">[</span><span style="color:#393A34">sz</span><span style="color:#a65e2b">]</span><span style="color:#1e754f">)</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#1e754f">)</span><span style="color:#999999">;</span><br><span style="color:#999999">    </span><span style="color:#2993a3">}</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#DBD7CAEE">fini_array </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#5eaab5">)</span><br><span style="color:#666666">    </span><span style="color:#5eaab5">{</span><br><span style="color:#80A665">      ElfW</span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">Addr</span><span style="color:#4d9375">)</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">array </span><span style="color:#666666">=</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#80A665">ElfW</span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">Addr</span><span style="color:#d4976c">)</span><span style="color:#CB7676"> *</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#BD976A">map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_addr</span><br><span style="color:#CB7676">                                          +</span><span style="color:#BD976A"> fini_array</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">d_un</span><span style="color:#666666">.</span><span style="color:#BD976A">d_ptr</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#CB7676">      size_t</span><span style="color:#DBD7CAEE"> sz </span><span style="color:#666666">=</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#BD976A">map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_info</span><span style="color:#d4976c">[</span><span style="color:#DBD7CAEE">DT_FINI_ARRAYSZ</span><span style="color:#d4976c">]</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">d_un</span><span style="color:#666666">.</span><span style="color:#BD976A">d_val</span><br><span style="color:#CB7676">                   /</span><span style="color:#CB7676"> sizeof</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#80A665">ElfW</span><span style="color:#d9739f">(</span><span style="color:#DBD7CAEE">Addr</span><span style="color:#d9739f">)</span><span style="color:#d4976c">)</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><br><span style="color:#4D9375">      while</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">sz</span><span style="color:#CB7676">--</span><span style="color:#CB7676"> </span><span style="color:#CB7676">></span><span style="color:#4C9A91"> 0</span><span style="color:#4d9375">)</span><br><span style="color:#666666">        </span><span style="color:#4d9375">(</span><span style="color:#d4976c">(</span><span style="color:#B8A965">fini_t</span><span style="color:#d4976c">)</span><span style="color:#BD976A"> array</span><span style="color:#d4976c">[</span><span style="color:#DBD7CAEE">sz</span><span style="color:#d4976c">]</span><span style="color:#4d9375">)</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#4d9375">)</span><span style="color:#666666">;</span><br><span style="color:#666666">    </span><span style="color:#5eaab5">}</span><br></code></pre></div>
<p>仔细调试一下这一部分函数，会发现这里有大量可以操作的函数逻辑，例如，笔者在本地调试一个很简单的 poc 时，<code class="inline-code">maps</code> 里一共存储了 4 个 link_map 指针，如下图（存在栈上）：</p>
<p><img src="https://pic1.imgdb.cn/item/67eabf7d0ba3d5a1d7e863b4.png" alt/></p>
<p>而在 pwndbg 中也可以输入 <code class="inline-code">linkmap</code> 直接看到。</p>
<p>显然这四个模块里存放的析构函数都应该是要被调用的，所以理论上都可以打。最常见的打法就是打第一个模块，它的 <code class="inline-code">map->l_addr</code> 是一个 pie 地址，通过调整（做部分写）可以实现无限 main 函数执行等功能。</p>
<p>因此这里的利用点有很多，具体题目具体分析即可。</p>
<h3 id="l_info-fini_array" class="scroll-target"><a href="#l_info-fini_array"><code class="hash inline-code">#</code>劫持 <code class="inline-code">l_info</code> 伪造 <code class="inline-code">fini_array</code> 节</a></h3>
<p>攻击面还是在上面那个函数，局部变量 <code class="inline-code">fini_array</code> 是通过 <code class="inline-code">map->l_info[26]</code> 确定的，那么如果这个地址可控，那就可以把 <code class="inline-code">fini_array</code> 伪造到堆上，最终可以打出一个 rop 的效果，实现 orw 等等。</p>
<p>但是这个在高版本中利用面并不广泛，因为需要任意地址写堆地址这种，那为什么不打 house of apple2 呢？</p>
<h3 id="fini" class="scroll-target"><a href="#fini"><code class="hash inline-code">#</code>打 fini</a></h3>
<p>由于 <code class="inline-code">_dl_call_fini</code> 最后会调用</p>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#59873A">  ElfW</span><span style="color:#2993a3">(</span><span style="color:#393A34">Dyn</span><span style="color:#2993a3">)</span><span style="color:#AB5959"> *</span><span style="color:#393A34">fini </span><span style="color:#999999">=</span><span style="color:#393A34"> map</span><span style="color:#AB5959">-</span><span style="color:#AB5959">></span><span style="color:#B07D48">l_info</span><span style="color:#2993a3">[</span><span style="color:#393A34">DT_FINI</span><span style="color:#2993a3">]</span><span style="color:#999999">;</span><br><span style="color:#1E754F">  if</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">fini </span><span style="color:#AB5959">!=</span><span style="color:#1E754F"> NULL</span><span style="color:#2993a3">)</span><br><span style="color:#59873A">    DL_CALL_DT_FINI</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#393A34">map</span><span style="color:#999999">,</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#a65e2b">(</span><span style="color:#AB5959">void</span><span style="color:#AB5959"> *</span><span style="color:#a65e2b">)</span><span style="color:#393A34"> map</span><span style="color:#AB5959">-</span><span style="color:#AB5959">></span><span style="color:#393A34">l_addr </span><span style="color:#AB5959">+</span><span style="color:#393A34"> fini</span><span style="color:#AB5959">-</span><span style="color:#AB5959">></span><span style="color:#393A34">d_un.d_ptr</span><span style="color:#1e754f">)</span><span style="color:#2993a3">)</span><span style="color:#999999">;</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#80A665">  ElfW</span><span style="color:#5eaab5">(</span><span style="color:#DBD7CAEE">Dyn</span><span style="color:#5eaab5">)</span><span style="color:#CB7676"> *</span><span style="color:#DBD7CAEE">fini </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> map</span><span style="color:#CB7676">-</span><span style="color:#CB7676">></span><span style="color:#BD976A">l_info</span><span style="color:#5eaab5">[</span><span style="color:#DBD7CAEE">DT_FINI</span><span style="color:#5eaab5">]</span><span style="color:#666666">;</span><br><span style="color:#4D9375">  if</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#DBD7CAEE">fini </span><span style="color:#CB7676">!=</span><span style="color:#4D9375"> NULL</span><span style="color:#5eaab5">)</span><br><span style="color:#80A665">    DL_CALL_DT_FINI</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#DBD7CAEE">map</span><span style="color:#666666">,</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#d4976c">(</span><span style="color:#CB7676">void</span><span style="color:#CB7676"> *</span><span style="color:#d4976c">)</span><span style="color:#DBD7CAEE"> map</span><span style="color:#CB7676">-</span><span style="color:#CB7676">></span><span style="color:#DBD7CAEE">l_addr </span><span style="color:#CB7676">+</span><span style="color:#DBD7CAEE"> fini</span><span style="color:#CB7676">-</span><span style="color:#CB7676">></span><span style="color:#DBD7CAEE">d_un.d_ptr</span><span style="color:#4d9375">)</span><span style="color:#5eaab5">)</span><span style="color:#666666">;</span><br></code></pre></div>
<p>这么个东西，所以这里也可以尝试去劫持 fini 实现攻击。</p>
<h3 id="__libc_atexit" class="scroll-target"><a href="#__libc_atexit"><code class="hash inline-code">#</code>打 <code class="inline-code">__libc_atexit</code></a></h3>
<p>这个函数在 <code class="inline-code">run_exit_handlers</code> 里，遍历完 <code class="inline-code">exit_funcs</code> 后会 <code class="inline-code">RUN_HOOK(__libc_atexit, ());</code>，那么劫持 <code class="inline-code">__libc_atexit</code> 就可以打 ogg。</p>
<p>但是这个打法不稳定，高版本栈基本上不满足条件，而且这个地址不可写。</p>
<h3 id="__call_tls_dtors" class="scroll-target"><a href="#__call_tls_dtors"><code class="hash inline-code">#</code>打 <code class="inline-code">__call_tls_dtors</code></a></h3>
<div class="code-snippet"><pre data-theme="light" class="code-snippet__pre code-snippet__pre--light"><code class="language-c language-c"><span style="color:#AB5959">void</span><br><span style="color:#59873A">__call_tls_dtors</span><span style="color:#999999"> </span><span style="color:#2993a3">(</span><span style="color:#AB5959">void</span><span style="color:#2993a3">)</span><br><span style="color:#2993a3">{</span><br><span style="color:#1E754F">  while</span><span style="color:#999999"> </span><span style="color:#1e754f">(</span><span style="color:#393A34">tls_dtor_list</span><span style="color:#1e754f">)</span><br><span style="color:#999999">    </span><span style="color:#1e754f">{</span><br><span style="color:#AB5959">      struct</span><span style="color:#393A34"> dtor_list </span><span style="color:#AB5959">*</span><span style="color:#393A34">cur </span><span style="color:#999999">=</span><span style="color:#393A34"> tls_dtor_list</span><span style="color:#999999">;</span><br><span style="color:#393A34">      dtor_func func </span><span style="color:#999999">=</span><span style="color:#B07D48"> cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">func</span><span style="color:#999999">;</span><br><span style="color:#999999">#</span><span style="color:#1E754F">ifdef</span><span style="color:#59873A"> PTR_DEMANGLE</span><br><span style="color:#59873A">      PTR_DEMANGLE</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">func</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><span style="color:#A0ADA0">  // 这里有指针保护</span><br><span style="color:#999999">#</span><span style="color:#1E754F">endif</span><br><span style="color:#393A34">​</span><br><span style="color:#393A34">      tls_dtor_list </span><span style="color:#999999">=</span><span style="color:#B07D48"> tls_dtor_list</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">next</span><span style="color:#999999">;</span><br><span style="color:#59873A">      func</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#B07D48">cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">obj</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">      atomic_fetch_add_release</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#AB5959">&#x26;</span><span style="color:#B07D48">cur</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">map</span><span style="color:#999999">-</span><span style="color:#999999">></span><span style="color:#B07D48">l_tls_dtor_count</span><span style="color:#999999">,</span><span style="color:#AB5959"> -</span><span style="color:#2F798A">1</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#59873A">      free</span><span style="color:#999999"> </span><span style="color:#a65e2b">(</span><span style="color:#393A34">cur</span><span style="color:#a65e2b">)</span><span style="color:#999999">;</span><br><span style="color:#999999">    </span><span style="color:#1e754f">}</span><br><span style="color:#2993a3">}</span><br></code></pre><pre data-theme="dark" class="code-snippet__pre code-snippet__pre--dark"><code class="language-c language-c"><span style="color:#CB7676">void</span><br><span style="color:#80A665">__call_tls_dtors</span><span style="color:#666666"> </span><span style="color:#5eaab5">(</span><span style="color:#CB7676">void</span><span style="color:#5eaab5">)</span><br><span style="color:#5eaab5">{</span><br><span style="color:#4D9375">  while</span><span style="color:#666666"> </span><span style="color:#4d9375">(</span><span style="color:#DBD7CAEE">tls_dtor_list</span><span style="color:#4d9375">)</span><br><span style="color:#666666">    </span><span style="color:#4d9375">{</span><br><span style="color:#CB7676">      struct</span><span style="color:#DBD7CAEE"> dtor_list </span><span style="color:#CB7676">*</span><span style="color:#DBD7CAEE">cur </span><span style="color:#666666">=</span><span style="color:#DBD7CAEE"> tls_dtor_list</span><span style="color:#666666">;</span><br><span style="color:#DBD7CAEE">      dtor_func func </span><span style="color:#666666">=</span><span style="color:#BD976A"> cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">func</span><span style="color:#666666">;</span><br><span style="color:#666666">#</span><span style="color:#4D9375">ifdef</span><span style="color:#80A665"> PTR_DEMANGLE</span><br><span style="color:#80A665">      PTR_DEMANGLE</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">func</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><span style="color:#758575DD">  // 这里有指针保护</span><br><span style="color:#666666">#</span><span style="color:#4D9375">endif</span><br><span style="color:#DBD7CAEE">​</span><br><span style="color:#DBD7CAEE">      tls_dtor_list </span><span style="color:#666666">=</span><span style="color:#BD976A"> tls_dtor_list</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">next</span><span style="color:#666666">;</span><br><span style="color:#80A665">      func</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#BD976A">cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">obj</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#80A665">      atomic_fetch_add_release</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#CB7676">&#x26;</span><span style="color:#BD976A">cur</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">map</span><span style="color:#666666">-</span><span style="color:#666666">></span><span style="color:#BD976A">l_tls_dtor_count</span><span style="color:#666666">,</span><span style="color:#CB7676"> -</span><span style="color:#4C9A91">1</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#80A665">      free</span><span style="color:#666666"> </span><span style="color:#d4976c">(</span><span style="color:#DBD7CAEE">cur</span><span style="color:#d4976c">)</span><span style="color:#666666">;</span><br><span style="color:#666666">    </span><span style="color:#4d9375">}</span><br><span style="color:#5eaab5">}</span><br></code></pre></div>
<p>这个全版本都能用，但是最大的问题在于 <code class="inline-code">fs:[0x30]</code> 也就是 <code class="inline-code">pointer_guard</code> 不好泄漏或者修改，如果可以修改/泄漏的话，那依然可以随便打，但还是那句话，高版本既然可以任意地址写了，为什么不打 house of apple2 呢？</p>
<p>话又说回来了，如果题目真的专门考这个点的话，那也是可以打一打的。</p></div></div></div><footer class="footer"><div class="footer-row footer-links"><span class="footer-label">保持联系</span><a href="mailto:xzy1476569428@163.com" class="footer-link"><p><a href="mailto:xzy1476569428@163.com" title="mailto:xzy1476569428@163.com">xzy1476569428@163.com</a></p></a><span aria-hidden="true" class="footer-separator">·</span><a href="/rss.xml" class="footer-link">RSS</a><span aria-hidden="true" class="footer-separator">·</span><a href="https://github.com/LittFlower/my_blog" class="footer-link"><p>GitHub</p></a></div><div class="footer-row footer-meta"><span><p>本站基于
<a href="https://github.com/unvariant/blog">unvariant/blog</a>
改造，除特别说明外内容以 CC BY 4.0 协议共享。</p></span></div></footer></body></html>