<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pwn on 一只花盆.</title>
    <link>http://littflower.github.io/tags/pwn/</link>
    <description>Recent content in Pwn on 一只花盆.</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Nov 2024 16:55:35 +0800</lastBuildDate><atom:link href="http://littflower.github.io/tags/pwn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2024 强网杯青少赛题解</title>
      <link>http://littflower.github.io/posts/2024-qwbqs-writeup/</link>
      <pubDate>Mon, 25 Nov 2024 16:55:35 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/2024-qwbqs-writeup/</guid>
      <description>前言 战队名：crazyNAN
战队排名：6
战队整体答题情况：除 web 方向 cyberboard mysqlprobe 外均解出。
这辈子最后一次打强网杯青少赛了，因为我今年刚满 18 岁（（（
一开始把这事情都忘了，还是 Aura 师傅拉我我才想起来，打着玩玩，话又说回来初赛和这 b Aura 有个🥚的关系啊（（
全靠 👴 和 🌳 带飞（
杂鱼 Aura
Wp 赛时开了个飞书云文档，边打边写 wp，感觉确实不错，不用赛后专门整理 wp 了。
我这里就把我做的 pwn 题发一下，剩下的可以戳这个链接看 exp
Pwn clock_in 板子 ret2libc，exp:
from pwn import * from sys import argv proc = &amp;#34;./clock_in&amp;#34; context.log_level = &amp;#34;debug&amp;#34; context.binary = proc elf = ELF(proc, checksec=False) libc = ELF(&amp;#34;./libc.so.6&amp;#34;) io = remote(&amp;#34;101.200.61.16&amp;#34;, 34841) if argv[1] == &amp;#39;r&amp;#39; else process(proc) if args.</description>
    </item>
    
    <item>
      <title>论文笔记《AddressSanitizer: A Fast Address Sanity Checker》</title>
      <link>http://littflower.github.io/posts/paper-notes-of-addresssanitizer-a-fast-address-sanity-checker/</link>
      <pubDate>Mon, 21 Oct 2024 19:14:44 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/paper-notes-of-addresssanitizer-a-fast-address-sanity-checker/</guid>
      <description>0x00. Abstract 对于 C 和 C++ 等编程语言来说，内存访问错误（包括缓冲区溢出和 use after free）仍然是一个严重问题。存在许多内存错误检测器，但大多数检测器要么速度慢，要么局限于有限的错误集，或者两者兼而有之。本文介绍了 AddressSanitizer，一种新的内存错误检测器。这个工具可以查找对堆、堆栈和全局变量的越界访问，以及 use after free。它采用专门的内存分配器和代码工具，足够简单，可以在任何编译器、二进制翻译系统甚至硬件中实现。AddressSanitizer 在不牺牲全面性的情况下实现了效率。它的平均速度仅为 73%，但它可以在错误发生时准确地检测到错误。它在 Chromium 浏览器中发现了 300 多个以前未知的错误，以及其他软件中的许多错误。
0x01. Introduction AddressSanitizer 由两部分组成：检测模块和运行时库。检测模块修改代码以检查每次内存访问的影子态 (shadow state)，并在堆栈和全局对象周围创建中毒红区以检测向上或向下溢出。当前的实现基于 LLVM 编译器基础设施。运行时库替换了 malloc、free 和相关函数，在分配的堆区域周围创建中毒红区，延迟已释放堆区域的重用，并进行错误报告。
总的来说，这篇文章做了以下几件事：
说明了内存错误检测器可以利用影子内存 shadow memory的全面性，并且开销比传统方法低得多； 提出一种新颖的影子态编码方式，可实现紧凑的影子内存（高达 128-to-1），用于检测越界和 use-after-free 错误； 描述一个针对新实现的影子编码的专用内存分配器； 评估一个新的公开可用的工具，该工具可以有效地识别内存错误。 0x02. Related work 影子内存（shadow memory） 总的来说，按照对应用程序地址的处理可以把现有的工具分为两种：
通过直接缩放和偏移（其中完整应用程序地址空间映射到单个影子地址空间）； 通过涉及查表的额外转换来映射到影子地址空间。 直接缩放和偏移的例子有：
TaintTrace LIFT 使用多级转换的例子有：
Valgrind Dr.Memory 还有一些比较 trick 的工具：
Umbra：兼顾布局灵活性和效率，使用可动态调整的缩放和偏移来直接映射地址而非使用查表的方式； BoundLess：利用 64 位寄存器的高 16 位来做到内存复用，但是在慢速路径下会退化； LBC：使用存储在应用程序内存中的特殊值执行快速路径的检查，并在慢速路径上依赖于两级影子内存。 实现 大部分内存检测工具都基于二进制文件，这些工具可以发现堆内存的越界和 UAF，还可以识别未初始化的读取，不过没办法识别堆栈和全局变量的越界错误，好消息是基本不会误报。例如：Valgrind，Dr.Memory，Discover，BoundsChecker 等等
而使用编译时检测的工具虽然可以检测堆栈对象的越界访问，但是无法检测所有的堆栈缓冲区溢出错误，而且可能误报，例如 Mudflap。</description>
    </item>
    
    <item>
      <title>T1DCTF2024 WriteUp</title>
      <link>http://littflower.github.io/posts/t1dctf2024-writeup/</link>
      <pubDate>Tue, 14 May 2024 14:36:43 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/t1dctf2024-writeup/</guid>
      <description>补一下二队内测题。
repeater [easy] Repeater
As is well known, CTFers are all repeaters!
栈溢出题目，sub_11C9() 可以栈溢出，只修改返回地址的 1 字节，可以做到 partial overwrite 无限循环 sub_11C9() 读入 payload。
这里讲一下 fread 等 FILE 相关函数，后面也会用到。
C 语言 FILE 函数
既然没有空字符阶段，printf 就会把 retaddr 打印出来，从而获得 pie base。
接下来的问题是怎么泄漏 libc，ropper 发现程序没有一个能用来控制 rdi 的 gadgets，细心会发现程序在结束 printf 后寄存器 rdi 上居然还保存着 libc 函数的地址，那直接 call puts 就可以泄漏了。
from pwn import * proc = &amp;#34;./pwn&amp;#34; context.binary = proc context.log_level = &amp;#34;debug&amp;#34; io = process(proc) # io = remote(&amp;#34;tld1027.</description>
    </item>
    
    <item>
      <title>foolctf 2024 WriteUp 和一些关于 shellcode 的反思</title>
      <link>http://littflower.github.io/posts/t1d_foolctf-2024-writeups/</link>
      <pubDate>Tue, 09 Apr 2024 18:49:09 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/t1d_foolctf-2024-writeups/</guid>
      <description>愚人节的时候 t1d 在群里扔了两道题，说是愚人节ctf&amp;hellip;
做了之后发现自己是愚人了
facker 题目分析 先来看看程序主体逻辑：
en&amp;hellip;. 大概读一遍可以确定这是个 orw 题，不过一个巨大的 random 糊在脸上预示着这题可能不太好打，下面有个 encrypt 函数，会一次加密 16 字节，跟进去看看：
这个加密算法分两部分，前半部分可以识别出是个 base64 的 decode，后半部分是用刚才读的随机数异或编码 16 字节的前 12 字节。
一开始想着能不能把 random 给绕了，但是 t1d 肯定防了这个：
fd = open(&amp;#34;/dev/random&amp;#34;, 0); for ( i = 0; i != 16; i = strlen(buf) ) read(fd, buf, 0x10uLL); 这个写法会防止读 random 时首字节为空字节导致的截断问题。所以这东西肯定是绕不了了。
再者，关于这个 base64，可以注意到这个 decode 并没有直接在 a1 上做，也就是并没有修改我们输进去的 orw，真正修改 orw 的是后面的异或运算。
（这里我狠狠踩坑了，做题的时候处于逆向习惯一直在想着怎么逆这东西，其实从宏观一点的角度思考就会发现没有修改 orw 的 base64 decode() 我们是完全可以不用理会的）
总结一下，可以输入 66 个字节，前 2 个字节不作处理，之后的 64 个字节分为 4 组，每组只修改了 16 个字节的前 12 个字节。</description>
    </item>
    
    <item>
      <title>Unbreakable CTF 2024题解及反思</title>
      <link>http://littflower.github.io/posts/unbreakablectf2024-writeup/</link>
      <pubDate>Mon, 08 Apr 2024 22:33:57 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/unbreakablectf2024-writeup/</guid>
      <description>Unbreakable CTF 2024 Pwn WriteUps 和 NAN 的队友一起打了 UnbreakableCTF 2024 的二进制方向，动手做了两道题，口胡了一道堆题，有一些感悟和反思放在这里。
harder_assembly 思路 一道 x64 的shellcode 题，难点是禁止在 shellcode 里使用 syscall 以及shellcode 长度只有 15 字节。
后者比较好解决，可以考虑直接调用 read 构造二次输入，这样二次输入的时候就没有长度限制了，构造 orw 即可。
这里我遇到的知识盲区主要是禁用了 syscall，解决方法是使用 int 0x80（即继续使用 x32 API）
翻了一下 stackoverflow，注意到这样一段话：
When called from a 64-bit program it behaves the same way it would behave like if it has been called from a 32-bit program (using the 32-bit calling convention).
This also means that the parameters for &amp;ldquo;int 0x80&amp;rdquo; will be passed in 32-bit registers and the upper 32 bits of the 64-bit registers are ignored.</description>
    </item>
    
    <item>
      <title>AsisCTF2016 b00ks 复现笔记</title>
      <link>http://littflower.github.io/posts/asisctf2016-b00ks/</link>
      <pubDate>Tue, 23 Jan 2024 00:25:35 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/asisctf2016-b00ks/</guid>
      <description>记一道 offbyone 堆题的复现、反思与总结 复现 题目介绍 题目链接
菜单题，选单如下，其中 create 功能会创建一个 book，edit 功能只能修改 book 的 description，print 功能会打印 book 的 id/name/description/author, delete 功能会 free 掉 book name/book description/book self ：
1. Create a book 2. Delete a book 3. Edit a book 4. Print book detail 5. Change current author name 6. Exit 题目每创建一个 book，会涉及到两个用于维护的数据结构：一个是 book struct 本身，一个是 book list。
book struct 结构如下，每个 book struct 耗用内存空间大小为 0x20：
struct book { int id; char *name; char *description; int size; } book list 则是用来存放 book 的数组，主要用在 delete a book 和 edit a book 功能中。</description>
    </item>
    
    <item>
      <title>MoeCTF 2023 Pwn 题目复现</title>
      <link>http://littflower.github.io/posts/moectf-2023-pwn-writeup/</link>
      <pubDate>Sun, 12 Nov 2023 18:08:44 +0800</pubDate>
      
      <guid>http://littflower.github.io/posts/moectf-2023-pwn-writeup/</guid>
      <description>MoeCTF2023 Pwn WriteUp 前言 今年暑假比较摆烂&amp;hellip; 最后也没做完 MoeCTF 的 pwn 题, 只能赛后抽时间复现一遍. 复现一遍之后还是复习了不少知识点, 写一篇 wp 以作笔记.
题目复现 test_nc 连接即可.
baby_calculator emmm 打一个交互就可以了.
fd fd 即 file descripter, 又叫文件描述符, 它是一个抽象的指示符, 用一个非负整数表示.它指向了由系统内核维护的一个 file table 中的某个条目 ( entry ), 后者又指向储存文件真实地址的 inode table.
一般来说操作系统会为每个用户进程预留三个默认的 fd: stdin, stdout, stderr. 它们对应的非负整数值分别为 0, 1, 2. 之后的 fd 从 3 开始分配.
反编译得到核心代码:
fd = open(&amp;#34;./flag&amp;#34;, 0, 0LL); new_fd = (4 * fd) | 0x29A; dup2(fd, new_fd); // 将 new_fd 重定向到 fd close(fd); puts(&amp;#34;Which file do you want to read?</description>
    </item>
    
    <item>
      <title>2022强网杯青少赛题解</title>
      <link>http://littflower.github.io/posts/2022-qwbqs-writeup/</link>
      <pubDate>Fri, 03 Feb 2023 21:27:43 +0000</pubDate>
      
      <guid>http://littflower.github.io/posts/2022-qwbqs-writeup/</guid>
      <description>Qwb-青少赛-2022-WP 前言 蒟蒻来写 WP 了&amp;hellip;&amp;hellip; 本来应该是可以进线下的&amp;hellip;奈何工具太老旧&amp;hellip;明年再努力吧.
顺带一提，没补 pwn 题（（（
别问我为什么现在才发
Misc misc题实在是做麻了
misc 题思路都是对的&amp;hellip;脚本假了&amp;hellip;
Misc1 题目链接：Link
首先拿到一个 png 图片，用 010 editor 查看，根据文件头可以发现它是交换了奇偶数位顺序后的加密图片。
50 89 47 4E 0A 0D 0A 1A 00 00 0D 00 48 49 52 44 00 00 BD 02 00 00 6D 02 06 08 00 00 3B 00 C8 1A 00 F7 00 01 49 00 41 44 78 54 EC 9C D9 FD 1C 93 于是第一步解密：</description>
    </item>
    
  </channel>
</rss>
